<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>p:\stuff\projects\minigamesproject\minigamesproject\assets\_assets\scripts\bearded man studios\scripts\networking\forge\networking\commonserver.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using BeardedManStudios.Forge.Networking.Frame;
using System;
using System.Collections.Generic;
using System.Threading;

namespace BeardedManStudios.Forge.Networking
{
	public class CommonServerLogic
	{
		private NetWorker server;

		public CommonServerLogic(NetWorker server)
		{
			this.server = server;
		}

		public bool PlayerIsReceiver(NetworkingPlayer player, FrameStream frame, float proximityDistance, NetworkingPlayer skipPlayer = null, int proximityModeUpdateFrequency = 0)
		{
			// Don&#39;t send messages to a player who has not been accepted by the server yet
			if ((!player.Accepted &amp;&amp; !player.PendingAccepted) || player == skipPlayer)
				return false;

			if (player == frame.Sender)
			{
				// Don&#39;t send a message to the sending player if it was meant for others
				if (frame.Receivers == Receivers.Others || frame.Receivers == Receivers.OthersBuffered || frame.Receivers == Receivers.OthersProximity || frame.Receivers == Receivers.OthersProximityGrid)
					return false;
			}

			// check if sender is null as it doesn&#39;t get sent in certain cases
			if (frame.Sender != null)
			{
				return PlayerIsDistanceReceiver(frame.Sender, player, frame, proximityDistance, proximityModeUpdateFrequency);
			}
			return true;
		}

		public bool PlayerIsDistanceReceiver(NetworkingPlayer sender, NetworkingPlayer player, FrameStream frame, float proximityDistance, float proximityModeUpdateFrequency)
		{
			// check for distance here so the owner doesn&#39;t need to be sent in stream, used for NCW field proximity check
			if (sender != null)
			{
				if ((frame.Receivers == Receivers.AllProximity || frame.Receivers == Receivers.OthersProximity))
				{
					return proximityDistanceCheck(sender, player, proximityDistance, proximityModeUpdateFrequency);
				}
				else if((frame.Receivers == Receivers.AllProximityGrid || frame.Receivers == Receivers.OthersProximityGrid))
				{
					return proximityGridCheck(sender, player, proximityDistance, proximityModeUpdateFrequency);
				}
			}
			return true;
		}

		private bool proximityDistanceCheck(NetworkingPlayer sender, NetworkingPlayer player, float proximityDistance, float proximityModeUpdateFrequency)
		{
			// If the target player is not in the same proximity zone as the sender
			// then it should not be sent to that player
			if (player.ProximityLocation.DistanceSquared(sender.ProximityLocation) &gt; proximityDistance * proximityDistance)
			{
				// if update frequency is 0, it shouldn&#39;t ever get updated while too far
				if (proximityModeUpdateFrequency == 0)
					return false;

				return updateCountCheck(sender, player, proximityModeUpdateFrequency);
			}
			return true;
		}

		private bool proximityGridCheck(NetworkingPlayer sender, NetworkingPlayer player, float proximityDistance, float proximityModeUpdateFrequency)
		{
			// If the target player is not in the same proximity grid zone as the sender
			// then it should not be sent to that player
			if (!sender.gridPosition.IsSameOrNeighbourCell(player.gridPosition))
			{
				// if update frequency is 0, it shouldn&#39;t ever get updated while too far
				if (proximityModeUpdateFrequency == 0)
					return false;

				return updateCountCheck(sender, player, proximityModeUpdateFrequency);

			}
			return true;
		}

		private bool updateCountCheck(NetworkingPlayer sender, NetworkingPlayer player, float proximityModeUpdateFrequency)
		{
			// if player update counts are stored, increment or update and reset them, if not, store them starting with 0
			string key = player.Ip + player.NetworkId.ToString();
			if (sender.PlayersProximityUpdateCounters.ContainsKey(key))
			{
				if (sender.PlayersProximityUpdateCounters[key] &lt; proximityModeUpdateFrequency)
				{
					// increment update counter until it reaches the limit
					sender.PlayersProximityUpdateCounters[key]++;
					return false;
				}
				else
					sender.PlayersProximityUpdateCounters[key] = 0;
			}
			else
				sender.PlayersProximityUpdateCounters.Add(key, 0);

			return true;
		}

		/// &lt;summary&gt;
		/// Checks all of the clients to see if any of them are timed out
		/// &lt;/summary&gt;
		public void CheckClientTimeout(Action&lt;NetworkingPlayer&gt; timeoutDisconnect)
		{
			List&lt;NetworkingPlayer&gt; timedoutPlayers = new List&lt;NetworkingPlayer&gt;();
			while (server.IsBound)
			{
				server.IteratePlayers((player) =&gt;
				{
					// Don&#39;t process the server during this check
					if (player == server.Me)
						return;

					if (player.TimedOut())
					{
						timedoutPlayers.Add(player);
					}
				});

				if (timedoutPlayers.Count &gt; 0)
				{
					foreach (NetworkingPlayer player in timedoutPlayers)
						timeoutDisconnect(player);

					timedoutPlayers.Clear();
				}

				// Wait a second before checking again
				Thread.Sleep(1000);
			}
		}

		/// &lt;summary&gt;
		/// Disconnects a client
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;client&quot;&gt;The target client to be disconnected&lt;/param&gt;
		public void Disconnect(NetworkingPlayer player, bool forced,
			List&lt;NetworkingPlayer&gt; DisconnectingPlayers, List&lt;NetworkingPlayer&gt; ForcedDisconnectingPlayers)
		{
			if (player.IsDisconnecting || DisconnectingPlayers.Contains(player) || ForcedDisconnectingPlayers.Contains(player))
				return;

			if (!forced)
				DisconnectingPlayers.Add(player);
			else
				ForcedDisconnectingPlayers.Add(player);
		}
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[12,3,12,45,0],[13,3,13,4,0],[14,4,14,25,0],[15,3,15,4,0],[18,3,18,4,0],[20,4,20,78,0],[21,5,21,18,0],[23,4,23,31,0],[24,4,24,5,0],[26,5,26,192,0],[27,6,27,19,0],[28,4,28,5,0],[31,4,31,29,0],[32,4,32,5,0],[33,5,33,115,0],[35,4,35,16,0],[36,3,36,4,0],[39,3,39,4,0],[41,4,41,23,0],[42,4,42,5,0],[43,5,43,101,0],[44,5,44,6,0],[45,6,45,101,0],[47,10,47,113,0],[48,5,48,6,0],[49,6,49,97,0],[51,4,51,5,0],[52,4,52,16,0],[53,3,53,4,0],[56,3,56,4,0],[59,4,59,115,0],[60,4,60,5,0],[62,5,62,43,0],[63,6,63,19,0],[65,5,65,75,0],[67,4,67,16,0],[68,3,68,4,0],[71,3,71,4,0],[74,4,74,72,0],[75,4,75,5,0],[77,5,77,43,0],[78,6,78,19,0],[80,5,80,75,0],[83,4,83,16,0],[84,3,84,4,0],[87,3,87,4,0],[89,4,89,57,0],[90,4,90,63,0],[91,4,91,5,0],[92,5,92,83,0],[93,5,93,6,0],[95,6,95,51,0],[96,6,96,19,0],[99,6,99,53,0],[100,4,100,5,0],[102,5,102,55,0],[104,4,104,16,0],[105,3,105,4,0],[111,3,111,4,0],[112,4,112,74,0],[113,4,113,26,0],[114,4,114,5,0],[115,5,116,5,0],[116,5,116,6,0],[116,6,118,6,0],[118,6,118,30,0],[118,30,119,7,0],[119,7,119,14,0],[119,14,121,6,0],[121,6,121,28,0],[121,28,122,6,0],[122,6,122,7,0],[122,7,123,7,0],[123,7,123,35,0],[123,35,124,6,0],[124,6,124,7,0],[124,7,125,5,0],[125,5,125,6,0],[125,6,125,8,0],[115,5,125,8,0],[127,5,127,35,0],[128,5,128,6,0],[129,6,129,13,0],[129,15,129,38,0],[129,39,129,41,0],[129,42,129,57,0],[130,7,130,33,0],[132,6,132,30,0],[133,5,133,6,0],[136,5,136,24,0],[137,4,137,5,0],[138,3,138,4,0],[146,3,146,4,0],[147,4,147,119,0],[148,5,148,12,0],[150,4,150,16,0],[151,5,151,38,0],[153,5,153,44,0],[154,3,154,4,0]]);
    </script>
  </body>
</html>