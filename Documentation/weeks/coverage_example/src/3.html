<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>p:\stuff\projects\minigamesproject\minigamesproject\assets\_assets\tests\pathfindingdfstest.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections;
using System.Collections.Generic;
using NUnit.Framework;
using UnityEngine;
using UnityEngine.TestTools;

namespace Tests {

    public class PathfindingDFSTest {

        private byte[,] level;
        private TankMazeGenerator generator;
        private TankAIPathfinding pf;

        [SetUp]
        public void Setup() {

            TankSettings.LevelWidth = 10;
            TankSettings.LevelHeight = 10;

            generator = new TankMazeGenerator();

            List&lt;TankLevelGenerator.Step&gt; steps;

            generator.GenerateMaze(out steps, out level);

            pf = new TankDFSPath(level);
        }

        [Test]
        public void RouteToEndIsStraight() {

            ClearLevel();

            IntCoords start = new IntCoords();

            // Right
            IntCoords end = new IntCoords(9, 0);

            Vector[] route = pf.FindPath(start, end);

            TestRoute(start, end, route);

            for (int i = 0; i &lt; 10; i++) {
                TestCoords(new IntCoords(i, 0), route[i], &quot;Route to right was not straight&quot;);
            }

            // Up
            end = new IntCoords(0, 9);

            route = pf.FindPath(start, end);

            TestRoute(start, end, route);

            for (int i = 0; i &lt; 10; i++) {
                TestCoords(new IntCoords(0, i), route[i], &quot;Route to up was not straight&quot;);
            }

            // Up-Right
            end = new IntCoords(9, 9);

            route = pf.FindPath(start, end);

            TestRoute(start, end, route);

            for (int i = 0; i &lt; 10; i++) {
                TestCoords(new IntCoords(i, i), route[i], &quot;Route to up-right was not straight&quot;);
            }
        }

        [Test]
        public void RouteIsFoundToEveryCell() {

            IntCoords start = new IntCoords();

            void To(int x, int y) {

                IntCoords end = new IntCoords(x, y);

                Vector[] route = pf.FindPath(start, end);

                TestRoute(start, end, route);
            }

            IterateLevel(To);
        }
        [Test]
        public void RouteIsFoundFromEveryCell() {
       
            IntCoords end = new IntCoords(0, 0);

            void From(int x, int y) {

                IntCoords start = new IntCoords(x, y);

                Vector[] route = pf.FindPath(start, end);

                TestRoute(start, end, route);
            }

            IterateLevel(From);
        }
        [Test]
        public void RouteIsFoundToEveryCellFromEveryCell() {  

            void From(int x, int y) {

                IntCoords start = new IntCoords(x, y);

                void To(int x2, int y2) {

                    IntCoords end = new IntCoords(x2, y2);

                    Vector[] route = pf.FindPath(start, end);

                    TestRoute(start, end, route);
                }

                IterateLevel(To);
            }

            IterateLevel(From);
        }

        #region TestHelpers
        private void ClearLevel() {

            void InitLevel(int x, int y) {
                level[x, y] = 255;         
            }

            IterateLevel(InitLevel);
        }

        private void TestRoute(IntCoords start, IntCoords end, Vector[] route) {
            Assert.AreNotEqual(null, route, &quot;Route was null&quot;);
            TestCoords(start, route[0], &quot;Start coordinates were not equal&quot;);
            TestCoords(end, route[route.Length - 1], &quot;Route to &quot; + end + &quot; was not found&quot;);
        }

        private void TestCoords(IntCoords coords, Vector pos, string message) {
            Assert.AreEqual(coords, Vector.PositionToCoords(pos), message);
        }

        private delegate void LevelIterateFunc(int x, int y);
        private void IterateLevel(LevelIterateFunc f) {
            for (int x = 0; x &lt; 10; x++) {
                for (int y = 0; y &lt; 10; y++) {
                    f(x, y);
                }
            }
        }
        #endregion
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[17,29,17,30,1],[19,13,19,42,1],[20,13,20,43,1],[22,13,22,49,1],[26,13,26,58,1],[28,13,28,41,1],[29,9,29,10,1],[32,44,32,45,1],[34,13,34,26,1],[36,13,36,47,1],[39,13,39,49,1],[41,13,41,54,1],[43,13,43,42,0],[45,18,45,27,0],[45,29,45,35,0],[45,37,45,40,0],[45,42,45,43,0],[46,17,46,94,0],[47,13,47,14,0],[50,13,50,39,0],[52,13,52,45,0],[54,13,54,42,0],[56,18,56,27,0],[56,29,56,35,0],[56,37,56,40,0],[56,42,56,43,0],[57,17,57,91,0],[58,13,58,14,0],[61,13,61,39,0],[63,13,63,45,0],[65,13,65,42,0],[67,18,67,27,0],[67,29,67,35,0],[67,37,67,40,0],[67,42,67,43,0],[68,17,68,97,0],[69,13,69,14,0],[70,9,70,10,0],[73,47,73,48,1],[75,13,75,47,1],[77,35,77,36,1],[79,17,79,53,1],[81,17,81,58,1],[83,17,83,46,1],[84,13,84,14,1],[86,13,86,30,1],[87,9,87,10,0],[89,49,89,50,1],[91,13,91,49,1],[93,37,93,38,1],[95,17,95,55,1],[97,17,97,58,1],[99,17,99,46,1],[100,13,100,14,1],[102,13,102,32,1],[103,9,103,10,0],[105,60,105,61,1],[107,37,107,38,1],[109,17,109,55,1],[111,41,111,42,1],[113,21,113,59,1],[115,21,115,62,1],[117,21,117,50,1],[118,17,118,18,1],[120,17,120,34,1],[121,13,121,14,0],[123,13,123,32,1],[124,9,124,10,0],[127,35,127,36,1],[129,42,129,43,1],[130,17,130,35,1],[131,13,131,14,1],[133,13,133,37,1],[134,9,134,10,1],[136,80,136,81,1],[137,13,137,63,1],[138,13,138,77,1],[139,13,139,92,1],[140,9,140,10,1],[142,79,142,80,1],[143,13,143,76,1],[144,9,144,10,1],[147,55,147,56,1],[148,18,148,27,1],[148,29,148,35,1],[148,37,148,40,1],[148,42,148,43,1],[149,22,149,31,1],[149,33,149,39,1],[149,41,149,44,1],[149,46,149,47,1],[150,21,150,29,1],[151,17,151,18,1],[152,13,152,14,1],[153,9,153,10,1]]);
    </script>
  </body>
</html>