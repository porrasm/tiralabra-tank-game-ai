<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>p:\stuff\projects\minigamesproject\minigamesproject\assets\_assets\testsplay\testest.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections;
using System.Collections.Generic;
using NUnit.Framework;
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityEngine.TestTools;

namespace Tests {

    public class Testest {

        private byte[,] level;
        private TankMazeGenerator generator;
        private TankAIPathfinding pf;

        [SetUp]
        public void Setup() {

            TankSettings.LevelWidth = 10;
            TankSettings.LevelHeight = 10;

            generator = new TankMazeGenerator();

            List&lt;TankLevelGenerator.Step&gt; steps;

            generator.GenerateMaze(out steps, out level);

            pf = new TankDFSPath(level);
        }

        [UnityTest]
        public IEnumerator RouteToEndIsStraight() {

            SceneManager.LoadScene(&quot;TankPathTesting&quot;);

            yield return new WaitForSeconds(2);

            ClearLevel();

            TankPathVisualizer vi = GameObject.FindObjectOfType&lt;TankPathVisualizer&gt;();
            

            IntCoords start = new IntCoords();

            // Right
            IntCoords end = new IntCoords(9, 0);

            Vector[] route = pf.FindPath(start, end);

            vi.level = level;
            TankPathVisualizer.DrawRoute(route);
            
            TestRoute(start, end, route);

            for (int i = 0; i &lt; 10; i++) {
                TestCoords(new IntCoords(i, 0), route[i], &quot;Route to right was not straight&quot;);
            }

            yield return new WaitForSeconds(2000);

            // Up
            end = new IntCoords(0, 9);

            route = pf.FindPath(start, end);

            vi.level = level;
            TankPathVisualizer.DrawRoute(route);

            yield return new WaitForSeconds(2);
            TestRoute(start, end, route);

            for (int i = 0; i &lt; 10; i++) {
                TestCoords(new IntCoords(0, i), route[i], &quot;Route to up was not straight&quot;);
            }

            // Up-Right
            end = new IntCoords(9, 9);

            route = pf.FindPath(start, end);

            vi.level = level;
            TankPathVisualizer.DrawRoute(route);

            yield return new WaitForSeconds(2);
            TestRoute(start, end, route);

            for (int i = 0; i &lt; 10; i++) {
                TestCoords(new IntCoords(i, i), route[i], &quot;Route to up-right was not straight&quot;);
            }


        }


        #region TestHelpers
        private void ClearLevel() {

            List&lt;TankLevelGenerator.Step&gt; steps = new List&lt;TankLevelGenerator.Step&gt;();

            void InitLevel(int x, int y) {
                TankLevelGenerator.Step step = new TankLevelGenerator.Step();
                step.Coords = new IntCoords(x, y);
                step.Wall = TankCell.CellWall.Both;
                steps.Add(step);
            }

            IterateLevel(InitLevel);

            Debug.Log(&quot;Created test level: &quot; + steps.Count);


            generator.LevelFromSteps(out level, steps);

        }

        private void TestRoute(IntCoords start, IntCoords end, Vector[] route) {
            if (route.Length == 0) {
                Debug.Log(&quot;ROUTE WAS 0&quot;);
                return;
            }
            Assert.AreNotEqual(null, route, &quot;Route was null&quot;);
            TestCoords(start, route[0], &quot;Start coordinates were not equal&quot;);
            TestCoords(end, route[route.Length - 1], &quot;Route to &quot; + end + &quot; was not found&quot;);
        }

        private void TestCoords(IntCoords coords, Vector pos, string message) {
            Assert.AreEqual(coords, Vector.PositionToCoords(pos), message);
        }

        private delegate void LevelIterateFunc(int x, int y);
        private void IterateLevel(LevelIterateFunc f) {
            for (int x = 0; x &lt; 10; x++) {
                for (int y = 0; y &lt; 10; y++) {
                    f(x, y);
                }
            }
        }
        #endregion
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[18,29,18,30,0],[20,13,20,42,0],[21,13,21,43,0],[23,13,23,49,0],[27,13,27,58,0],[29,13,29,41,0],[30,9,30,10,0],[33,51,33,52,0],[35,13,35,55,0],[37,13,37,48,0],[39,13,39,26,0],[41,13,41,87,0],[44,13,44,47,0],[47,13,47,49,0],[49,13,49,54,0],[51,13,51,30,0],[52,13,52,49,0],[54,13,54,42,0],[56,18,56,27,0],[56,29,56,35,0],[56,37,56,40,0],[56,42,56,43,0],[57,17,57,94,0],[58,13,58,14,0],[60,13,60,51,0],[63,13,63,39,0],[65,13,65,45,0],[67,13,67,30,0],[68,13,68,49,0],[70,13,70,48,0],[71,13,71,42,0],[73,18,73,27,0],[73,29,73,35,0],[73,37,73,40,0],[73,42,73,43,0],[74,17,74,91,0],[75,13,75,14,0],[78,13,78,39,0],[80,13,80,45,0],[82,13,82,30,0],[83,13,83,49,0],[85,13,85,48,0],[86,13,86,42,0],[88,18,88,27,0],[88,29,88,35,0],[88,37,88,40,0],[88,42,88,43,0],[89,17,89,97,0],[90,13,90,14,0],[93,9,93,10,0],[97,35,97,36,0],[99,13,99,87,0],[101,42,101,43,0],[102,17,102,78,0],[103,17,103,51,0],[104,17,104,52,0],[105,17,105,33,0],[106,13,106,14,0],[108,13,108,37,0],[110,13,110,61,0],[113,13,113,56,0],[115,9,115,10,0],[117,80,117,81,0],[118,13,118,35,0],[118,36,118,37,0],[119,17,119,42,0],[120,17,120,24,0],[122,13,122,63,0],[123,13,123,77,0],[124,13,124,92,0],[125,9,125,10,0],[127,79,127,80,0],[128,13,128,76,0],[129,9,129,10,0],[132,55,132,56,0],[133,18,133,27,0],[133,29,133,35,0],[133,37,133,40,0],[133,42,133,43,0],[134,22,134,31,0],[134,33,134,39,0],[134,41,134,44,0],[134,46,134,47,0],[135,21,135,29,0],[136,17,136,18,0],[137,13,137,14,0],[138,9,138,10,0]]);
    </script>
  </body>
</html>