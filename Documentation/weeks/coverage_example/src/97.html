<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>p:\stuff\projects\minigamesproject\minigamesproject\assets\_assets\scripts\bearded man studios\scripts\networking\forge\networking\objects\rewind.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
/*-----------------------------+-------------------------------\
|                                                              |
|                         !!!NOTICE!!!                         |
|                                                              |
|  These libraries are under heavy development so they are     |
|  subject to make many changes as development continues.      |
|  For this reason, the libraries may not be well commented.   |
|  THANK YOU for supporting forge with all your feedback       |
|  suggestions, bug reports and comments!                      |
|                                                              |
|                              - The Forge Team                |
|                                Bearded Man Studios, Inc.     |
|                                                              |
|  This source code, project files, and associated files are   |
|  copyrighted by Bearded Man Studios, Inc. (2012-2017) and    |
|  may not be redistributed without written permission.        |
|                                                              |
\------------------------------+------------------------------*/

using System.Collections.Generic;
using System.Linq;

namespace BeardedManStudios.Forge.Networking
{
    public class Rewind&lt;T&gt;
    {
        public ulong RewindTime { get; set; }
        private Dictionary&lt;ulong, T&gt; rewinds = null;
        private List&lt;ulong&gt; keys = new List&lt;ulong&gt;();

        public Rewind(ulong length)
        {
            RewindTime = length;
            rewinds = new Dictionary&lt;ulong, T&gt;();
        }

        public void Register(T value, ulong timestep = 0)
        {
            lock (rewinds)
            {
                if (keys.Contains(timestep))
                {
                    rewinds[timestep] = value;
                    return;
                }

                if (rewinds.Count &gt; 0)
                {
                    for (int i = 0; i &lt; keys.Count; i++)
                    {
                        if (keys[i] &lt; timestep - RewindTime &amp;&amp; RewindTime &lt; timestep)
                        {
                            rewinds.Remove(keys[i]);
                            keys.RemoveAt(i--);
                        }
                        else
                            break;
                    }
                }

                rewinds.Add(timestep, value);
                keys.Add(timestep);
            }
        }

        /// &lt;summary&gt;
        /// Used to get the value of a variable based on a given time step
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;timestep&quot;&gt;The time step that a value should be pulled for&lt;/param&gt;
        /// &lt;returns&gt;The value of the tracked variable at the given time stamp or default() if no history is available&lt;/returns&gt;
        public T Get(ulong timestep)
        {
            lock (rewinds)
            {
                if (rewinds.Count == 0)
                    return default(T);

                T result;
                if (rewinds.TryGetValue(timestep, out result))
                    return result;

                ulong key = 0;
                foreach (ulong k in keys)
                {
                    if (timestep &lt; k)
                    {
                        if (timestep - key &gt; k - timestep)
                            key = k;

                        break;
                    }

                    key = k;
                }

                return rewinds[key];
            }
        }

        /// &lt;summary&gt;
        /// Used to get the value of a variable based on a given time step but also
        /// will out the lower and upper if found to allow for getting median
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;timestep&quot;&gt;The time step that a value should be pulled for&lt;/param&gt;
        /// &lt;param name=&quot;lower&quot;&gt;The lower value relative to the timestep&lt;/param&gt;
        /// &lt;param name=&quot;upper&quot;&gt;The upper value relative to the timestep&lt;/param&gt;
        /// &lt;returns&gt;The value of the tracked variable at the given time stamp or default() if no history is available&lt;/returns&gt;
        public T Get(ulong timestep, out T lower, out T upper)
        {
            lock (rewinds)
            {
                lower = default(T);
                upper = lower;

                if (rewinds.Count == 0)
                    return lower;

                if (rewinds.ContainsKey(timestep))
                    return rewinds[timestep];

                ulong key = 0, lowerKey = 0, upperKey = 0;

                if (keys.Last() &lt; timestep)
                {
                    // TODO:  The supplied time does not exist, throw exception?
                    return default(T);
                }

                foreach (ulong k in keys)
                {
                    if (timestep &lt; k)
                    {
                        lowerKey = key;
                        upperKey = k;
                        if (timestep - key &gt; k - timestep)
                            key = k;

                        break;
                    }

                    key = k;
                }

                lower = rewinds[lowerKey];
                upper = rewinds[upperKey];
                return rewinds[key];
            }
        }

        /// &lt;summary&gt;
        /// Gets a range of values leading up to a given time step
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;timestep&quot;&gt;The time step that a value should be pulled for&lt;/param&gt;
        /// &lt;param name=&quot;count&quot;&gt;The number of elements to get before the time step&lt;/param&gt;
        /// &lt;returns&gt;The list of found elements leading up to the timestep (including time step value if found&lt;/returns&gt;
        public List&lt;T&gt; GetRange(ulong timestep, int count)
        {
            lock (rewinds)
            {
                List&lt;T&gt; found = new List&lt;T&gt;();

                if (rewinds.Count == 0)
                    return found;

                var keys = rewinds.Keys.ToArray().Reverse();
                ulong lastKey = 0;

                if (keys.First() &lt; timestep)
                {
                    // TODO:  The supplied time does not exist, throw exception?
                    return found;
                }

                foreach (ulong k in keys)
                {
                    if (timestep &lt;= k)
                    {
                        if (timestep != k &amp;&amp; lastKey != 0)
                        {
                            found.Add(rewinds[lastKey]);
                            lastKey = 0;
                        }

                        found.Insert(0, rewinds[k]);

                        if (found.Count == count)
                            break;
                    }
                    else
                        lastKey = k;
                }

                return found;
            }
        }

        /// &lt;summary&gt;
        /// Gets a range of values between the two timesteps (inclusive)
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;timestepMin&quot;&gt;The minimum inclusive timestep that a value should be pulled for&lt;/param&gt;
        /// &lt;param name=&quot;timestepMax&quot;&gt;The maximum inclusive timestep that a value should be pulled for&lt;/param&gt;
        /// &lt;returns&gt;The list of found elements between the two timesteps inclusively &lt;/returns&gt;
        public List&lt;T&gt; GetRange(ulong timestepMin, ulong timestepMax)
        {
            lock (rewinds)
            {
                List&lt;T&gt; found = new List&lt;T&gt;();

                if (rewinds.Count == 0)
                    return found;

                var keys = rewinds.Keys.ToArray().Reverse();

                if (keys.First() &lt; timestepMin)
                {
                    // TODO:  The supplied time does not exist, throw exception?
                    return found;
                }

                foreach (ulong k in keys)
                {
                    if (timestepMin &lt;= k &amp;&amp; timestepMax &gt;= k)
                        found.Insert(0, rewinds[k]);
                }

                return found;
            }
        }
    }
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[27,35,27,39,0],[27,40,27,44,0],[28,9,28,53,0],[29,9,29,54,0],[31,9,31,36,0],[32,9,32,10,0],[33,13,33,33,0],[34,13,34,50,0],[35,9,35,10,0],[38,9,38,10,0],[39,13,39,27,0],[40,13,40,14,0],[41,17,41,45,0],[42,17,42,18,0],[43,21,43,47,0],[44,21,44,28,0],[47,17,47,39,0],[48,17,48,18,0],[49,26,49,35,0],[49,37,49,51,0],[49,53,49,56,0],[50,21,50,22,0],[51,25,51,86,0],[52,25,52,26,0],[53,29,53,53,0],[54,29,54,48,0],[55,25,55,26,0],[57,29,57,35,0],[58,21,58,22,0],[59,17,59,18,0],[61,17,61,46,0],[62,17,62,36,0],[63,13,63,14,0],[64,9,64,10,0],[72,9,72,10,0],[73,13,73,27,0],[74,13,74,14,0],[75,17,75,40,0],[76,21,76,39,0],[79,17,79,63,0],[80,21,80,35,0],[82,17,82,31,0],[83,17,83,24,0],[83,26,83,33,0],[83,34,83,36,0],[83,37,83,41,0],[84,17,84,18,0],[85,21,85,38,0],[86,21,86,22,0],[87,25,87,59,0],[88,29,88,37,0],[90,25,90,31,0],[93,21,93,29,0],[94,17,94,18,0],[96,17,96,37,0],[98,9,98,10,0],[109,9,109,10,0],[110,13,110,27,0],[111,13,111,14,0],[112,17,112,36,0],[113,17,113,31,0],[115,17,115,40,0],[116,21,116,34,0],[118,17,118,51,0],[119,21,119,46,0],[121,17,121,30,0],[121,32,121,44,0],[121,46,121,58,0],[123,17,123,44,0],[124,17,124,18,0],[126,21,126,39,0],[129,17,129,24,0],[129,26,129,33,0],[129,34,129,36,0],[129,37,129,41,0],[130,17,130,18,0],[131,21,131,38,0],[132,21,132,22,0],[133,25,133,40,0],[134,25,134,38,0],[135,25,135,59,0],[136,29,136,37,0],[138,25,138,31,0],[141,21,141,29,0],[142,17,142,18,0],[144,17,144,43,0],[145,17,145,43,0],[146,17,146,37,0],[148,9,148,10,0],[157,9,157,10,0],[158,13,158,27,0],[159,13,159,14,0],[160,17,160,47,0],[162,17,162,40,0],[163,21,163,34,0],[165,17,165,61,0],[166,17,166,35,0],[168,17,168,45,0],[169,17,169,18,0],[171,21,171,34,0],[174,17,174,24,0],[174,26,174,33,0],[174,34,174,36,0],[174,37,174,41,0],[175,17,175,18,0],[176,21,176,39,0],[177,21,177,22,0],[178,25,178,59,0],[179,25,179,26,0],[180,29,180,57,0],[181,29,181,41,0],[182,25,182,26,0],[184,25,184,53,0],[186,25,186,50,0],[187,29,187,35,0],[188,21,188,22,0],[190,25,190,37,0],[191,17,191,18,0],[193,17,193,30,0],[195,9,195,10,0],[204,9,204,10,0],[205,13,205,27,0],[206,13,206,14,0],[207,17,207,47,0],[209,17,209,40,0],[210,21,210,34,0],[212,17,212,61,0],[214,17,214,48,0],[215,17,215,18,0],[217,21,217,34,0],[220,17,220,24,0],[220,26,220,33,0],[220,34,220,36,0],[220,37,220,41,0],[221,17,221,18,0],[222,21,222,62,0],[223,25,223,53,0],[224,17,224,18,0],[226,17,226,30,0],[228,9,228,10,0]]);
    </script>
  </body>
</html>