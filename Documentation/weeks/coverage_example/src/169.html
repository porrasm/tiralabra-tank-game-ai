<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>p:\stuff\projects\minigamesproject\minigamesproject\assets\_assets\scripts\bearded man studios\scripts\mainthreadmanager.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
/*-----------------------------+------------------------------\
|                                                             |
|                        !!!NOTICE!!!                         |
|                                                             |
|  These libraries are under heavy development so they are    |
|  subject to make many changes as development continues.     |
|  For this reason, the libraries may not be well commented.  |
|  THANK YOU for supporting forge with all your feedback      |
|  suggestions, bug reports and comments!                     |
|                                                             |
|                               - The Forge Team              |
|                                 Bearded Man Studios, Inc.   |
|                                                             |
|  This source code, project files, and associated files are  |
|  copyrighted by Bearded Man Studios, Inc. (2012-2015) and   |
|  may not be redistributed without written permission.       |
|                                                             |
\------------------------------+-----------------------------*/

using BeardedManStudios.Source.Threading;
using BeardedManStudios.Threading;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace BeardedManStudios.Forge.Networking.Unity
{
	public class MainThreadManager : MonoBehaviour, IThreadRunner
	{
		public enum UpdateType
		{
			FixedUpdate,
			Update,
			LateUpdate,
		}

		public delegate void UpdateEvent();
		public static UpdateEvent unityFixedUpdate = null;
		public static UpdateEvent unityUpdate = null;
		public static UpdateEvent unityLateUpdate = null;

		/// &lt;summary&gt;
		/// The singleton instance of the Main Thread Manager
		/// &lt;/summary&gt;
		private static MainThreadManager _instance;
		public static MainThreadManager Instance
		{
			get
			{
				if (_instance == null)
					Create();

				return _instance;
			}
		}

		/// &lt;summary&gt;
		/// This will create a main thread manager if one is not already created
		/// &lt;/summary&gt;
		public static void Create()
		{
			if (_instance != null)
				return;

			ThreadManagement.Initialize();

			if (!ReferenceEquals(_instance, null))
				return;

			new GameObject(&quot;Main Thread Manager&quot;).AddComponent&lt;MainThreadManager&gt;();
		}

		/// &lt;summary&gt;
		/// A dictionary of action queues for different updates.
		/// &lt;/summary&gt;
		private static Dictionary&lt;UpdateType, Queue&lt;Action&gt;&gt; actionQueueDict = new Dictionary&lt;UpdateType, Queue&lt;Action&gt;&gt;();
		private static Dictionary&lt;UpdateType, Queue&lt;Action&gt;&gt; actionRunnerDict = new Dictionary&lt;UpdateType, Queue&lt;Action&gt;&gt;();

		// Setup the singleton in the Awake
		private void Awake()
		{
			// If an instance already exists then delete this copy
			if (_instance != null)
			{
				Destroy(gameObject);
				return;
			}

			// Assign the static reference to this object
			_instance = this;

			// This object should move through scenes
			DontDestroyOnLoad(gameObject);
		}

		public void Execute(Action action)
		{
			Run(action);
		}

		/// &lt;summary&gt;
		/// Add a function to the list of functions to call on the main thread via the Update function
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;action&quot;&gt;The method that is to be run on the main thread&lt;/param&gt;
		public static void Run(Action action, UpdateType updateType = UpdateType.FixedUpdate)
		{
			// Only create this object on the main thread
#if UNITY_WEBGL
			if (ReferenceEquals(Instance, null))
#else
			if (ReferenceEquals(Instance, null) &amp;&amp; ThreadManagement.IsMainThread)
#endif
			{
				Create();
			}

			// Allocate new action queue by update type if there&#39;s no one exists.
			if (!actionQueueDict.ContainsKey(updateType))
			{
				actionQueueDict.Add(updateType, new Queue&lt;Action&gt;());

				// Since an action runner depends on the action queue, allocate new one here.
				actionRunnerDict.Add(updateType, new Queue&lt;Action&gt;());
			}

			Queue&lt;Action&gt; mainThreadActions = actionQueueDict[updateType];

			// Make sure to lock the mutex so that we don&#39;t override
			// other threads actions
			lock (mainThreadActions)
			{
				mainThreadActions.Enqueue(action);
			}
		}

		private void HandleActions(UpdateType updateType)
		{
			// Allocate new action queue by update type if there&#39;s no one exists.
			if (!actionQueueDict.ContainsKey(updateType))
			{
				actionQueueDict.Add(updateType, new Queue&lt;Action&gt;());

				// Since an action runner depends on the action queue, allocate new one here.
				actionRunnerDict.Add(updateType, new Queue&lt;Action&gt;());

			}
			Queue&lt;Action&gt; mainThreadActions = actionQueueDict[updateType];
			Queue&lt;Action&gt; mainThreadActionsRunner = actionRunnerDict[updateType];

			lock (mainThreadActions)
			{
				// Flush the list to unlock the thread as fast as possible
				if (mainThreadActions.Count &gt; 0)
				{
					while (mainThreadActions.Count &gt; 0)
						mainThreadActionsRunner.Enqueue(mainThreadActions.Dequeue());
				}
			}

			// If there are any functions in the list, then run
			// them all and then clear the list
			if (mainThreadActionsRunner.Count &gt; 0)
			{
				while (mainThreadActionsRunner.Count &gt; 0)
					mainThreadActionsRunner.Dequeue()();
			}
		}

		private void FixedUpdate()
		{
			HandleActions(UpdateType.FixedUpdate);

			if (unityFixedUpdate != null)
				unityFixedUpdate();
		}

		private void Update()
		{
			HandleActions(UpdateType.Update);

			if (unityUpdate != null)
				unityUpdate();
		}

		private void LateUpdate()
		{
			HandleActions(UpdateType.LateUpdate);

			if (unityLateUpdate != null)
				unityLateUpdate();
		}

#if WINDOWS_UWP
		public static async void ThreadSleep(int length)
#else
		public static void ThreadSleep(int length)
#endif
		{
#if WINDOWS_UWP
			await System.Threading.Tasks.Task.Delay(System.TimeSpan.FromSeconds(length));
#else
			System.Threading.Thread.Sleep(length);
#endif
		}
	}
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[38,3,38,53,0],[39,3,39,48,0],[40,3,40,52,0],[49,4,49,5,0],[50,5,50,27,0],[51,6,51,15,0],[53,5,53,22,0],[54,4,54,5,0],[61,3,61,4,0],[62,4,62,26,0],[63,5,63,12,0],[65,4,65,34,0],[67,4,67,42,0],[68,5,68,12,0],[70,4,70,76,0],[71,3,71,4,0],[76,3,76,118,0],[77,3,77,119,0],[81,3,81,4,0],[83,4,83,26,0],[84,4,84,5,0],[85,5,85,25,0],[86,5,86,12,0],[90,4,90,21,0],[93,4,93,34,0],[94,3,94,4,0],[97,3,97,4,0],[98,4,98,16,0],[99,3,99,4,0],[106,3,106,4,0],[111,4,111,73,0],[113,4,113,5,0],[114,5,114,14,0],[115,4,115,5,0],[118,4,118,49,0],[119,4,119,5,0],[120,5,120,58,0],[123,5,123,59,0],[124,4,124,5,0],[126,4,126,66,0],[130,4,130,28,0],[131,4,131,5,0],[132,5,132,39,0],[133,4,133,5,0],[134,3,134,4,0],[137,3,137,4,0],[139,4,139,49,0],[140,4,140,5,0],[141,5,141,58,0],[144,5,144,59,0],[146,4,146,5,0],[147,4,147,66,0],[148,4,148,73,0],[150,4,150,28,0],[151,4,151,5,0],[153,5,153,37,0],[154,5,154,6,0],[155,6,155,41,0],[156,7,156,68,0],[157,5,157,6,0],[158,4,158,5,0],[162,4,162,42,0],[163,4,163,5,0],[164,5,164,46,0],[165,6,165,42,0],[166,4,166,5,0],[167,3,167,4,0],[170,3,170,4,0],[171,4,171,42,0],[173,4,173,33,0],[174,5,174,24,0],[175,3,175,4,0],[178,3,178,4,0],[179,4,179,37,0],[181,4,181,28,0],[182,5,182,19,0],[183,3,183,4,0],[186,3,186,4,0],[187,4,187,41,0],[189,4,189,32,0],[190,5,190,23,0],[191,3,191,4,0],[198,3,198,4,0],[202,4,202,42,0],[204,3,204,4,0]]);
    </script>
  </body>
</html>