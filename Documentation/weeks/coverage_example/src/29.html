<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>p:\stuff\projects\minigamesproject\minigamesproject\assets\_assets\scripts\bearded man studios\scripts\networking\forge\networking\udpserver.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
/*-----------------------------+-------------------------------\
|                                                              |
|                         !!!NOTICE!!!                         |
|                                                              |
|  These libraries are under heavy development so they are     |
|  subject to make many changes as development continues.      |
|  For this reason, the libraries may not be well commented.   |
|  THANK YOU for supporting forge with all your feedback       |
|  suggestions, bug reports and comments!                      |
|                                                              |
|                              - The Forge Team                |
|                                Bearded Man Studios, Inc.     |
|                                                              |
|  This source code, project files, and associated files are   |
|  copyrighted by Bearded Man Studios, Inc. (2012-2017) and    |
|  may not be redistributed without written permission.        |
|                                                              |
\------------------------------+------------------------------*/

using BeardedManStudios.Forge.Networking.Frame;
using BeardedManStudios.Forge.Networking.Nat;
using BeardedManStudios.Threading;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Threading;

namespace BeardedManStudios.Forge.Networking
{
	public class UDPServer : BaseUDP, IServer
	{
		private CommonServerLogic commonServerLogic;

		public Dictionary&lt;string, UDPNetworkingPlayer&gt; udpPlayers = new Dictionary&lt;string, UDPNetworkingPlayer&gt;();

		private UDPNetworkingPlayer currentReadingPlayer = null;

		public UDPServer(int maxConnections) : base(maxConnections)
		{
			AcceptingConnections = true;
			BannedAddresses = new List&lt;string&gt;();
			commonServerLogic = new CommonServerLogic(this);
		}

		public NatHolePunch nat = new NatHolePunch();

		protected List&lt;FrameStream&gt; bufferedMessages = new List&lt;FrameStream&gt;();

		public List&lt;string&gt; BannedAddresses { get; set; }

		/// &lt;summary&gt;
		/// Used to determine if this server is currently accepting connections
		/// &lt;/summary&gt;
		public bool AcceptingConnections { get; private set; }

		public void Send(NetworkingPlayer player, FrameStream frame, bool reliable = false)
		{
			UDPPacketComposer composer = new UDPPacketComposer(this, player, frame, reliable);

			// If this message is reliable then make sure to keep a reference to the composer
			// so that there are not any run-away threads
			if (reliable)
			{
				lock (pendingComposers)
				{
					// Use the completed event to clean up the object from memory
					composer.completed += ComposerCompleted;
					pendingComposers.Add(composer);
				}
			}
		}

		public override void Send(FrameStream frame, bool reliable = false)
		{
			Send(frame, reliable, null);
		}

		public void Send(FrameStream frame, bool reliable = false, NetworkingPlayer skipPlayer = null)
		{
			if (frame.Receivers == Receivers.AllBuffered || frame.Receivers == Receivers.OthersBuffered)
				bufferedMessages.Add(frame);

			lock (Players)
			{
				foreach (NetworkingPlayer player in Players)
				{

					if (!commonServerLogic.PlayerIsReceiver(player, frame, ProximityDistance, skipPlayer, ProximityModeUpdateFrequency))
						continue;

					try
					{
						Send(player, frame, reliable);
					}
					catch
					{
						Disconnect(player, true);
					}
				}
			}
		}


		// overload for ncw field distance check case
		public void Send(FrameStream frame, NetworkingPlayer sender, bool reliable = false, NetworkingPlayer skipPlayer = null)
		{
			if (frame.Receivers == Receivers.AllBuffered || frame.Receivers == Receivers.OthersBuffered)
				bufferedMessages.Add(frame);

			lock (Players)
			{
				foreach (NetworkingPlayer player in Players)
				{
					// check for distance here so the owner doesn&#39;t need to be sent in stream, used for NCW field proximity check
					if (!commonServerLogic.PlayerIsDistanceReceiver(sender, player, frame, ProximityDistance, ProximityModeUpdateFrequency))
						continue;

					if (!commonServerLogic.PlayerIsReceiver(player, frame, ProximityDistance, skipPlayer, ProximityModeUpdateFrequency))
						continue;

					try
					{
						Send(player, frame, reliable);
					}
					catch
					{
						Disconnect(player, true);
					}
				}
			}
		}

		/// &lt;summary&gt;
		/// Sends binary message to the specified receiver(s)
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;receivers&quot;&gt;The client to receive the message&lt;/param&gt;
		/// &lt;param name=&quot;messageGroupId&quot;&gt;The Binary.GroupId of the massage, use MessageGroupIds.START_OF_GENERIC_IDS + desired_id&lt;/param&gt;
		/// &lt;param name=&quot;reliable&quot;&gt;True if message must be delivered&lt;/param&gt;
		/// &lt;param name=&quot;objectsToSend&quot;&gt;Array of vars to be sent, read them with Binary.StreamData.GetBasicType&lt;typeOfObject&gt;()&lt;/param&gt;
		public virtual void Send(NetworkingPlayer player, int messageGroupId = MessageGroupIds.START_OF_GENERIC_IDS, bool reliable = false, params object[] objectsToSend)
		{
			BMSByte data = ObjectMapper.BMSByte(objectsToSend);
			Binary sendFrame = new Binary(Time.Timestep, false, data, Receivers.Target, messageGroupId, false);
			Send(player, sendFrame, reliable);
		}

		/// &lt;summary&gt;
		/// Sends binary message to all clients ignoring the specific one
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;receivers&quot;&gt;The clients / server to receive the message&lt;/param&gt;
		/// &lt;param name=&quot;playerToIgnore&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;messageGroupId&quot;&gt;The Binary.GroupId of the massage, use MessageGroupIds.START_OF_GENERIC_IDS + desired_id&lt;/param&gt;
		/// &lt;param name=&quot;reliable&quot;&gt;True if message must be delivered&lt;/param&gt;
		/// &lt;param name=&quot;objectsToSend&quot;&gt;Array of vars to be sent, read them with Binary.StreamData.GetBasicType&lt;typeOfObject&gt;()&lt;/param&gt;
		public virtual void Send(Receivers receivers = Receivers.Target, NetworkingPlayer playerToIgnore = null, int messageGroupId = MessageGroupIds.START_OF_GENERIC_IDS, bool reliable = false, params object[] objectsToSend)
		{
			BMSByte data = ObjectMapper.BMSByte(objectsToSend);
			Binary sendFrame = new Binary(Time.Timestep, false, data, receivers, messageGroupId, false);
			Send(sendFrame, reliable, playerToIgnore);
		}

		public void Connect(string host = &quot;0.0.0.0&quot;, ushort port = DEFAULT_PORT, string natHost = &quot;&quot;, ushort natPort = NatHolePunch.DEFAULT_NAT_SERVER_PORT)
		{
			if (Disposed)
				throw new ObjectDisposedException(&quot;UDPServer&quot;, &quot;This object has been disposed and can not be used to connect, please use a new UDPServer&quot;);

			try
			{
				Client = new CachedUdpClient(port);
				Client.EnableBroadcast = true;
				Me = new NetworkingPlayer(ServerPlayerCounter++, host, true, ResolveHost(host, port), this);
				Me.InstanceGuid = InstanceGuid.ToString();

				// Do any generic initialization in result of the successful bind
				OnBindSuccessful();

				// Create the thread that will be listening for new data from connected clients and start its execution
				Task.Queue(ReadClients);

				// Create the thread that will check for player timeouts
				Task.Queue(() =&gt;
				{
					commonServerLogic.CheckClientTimeout((player) =&gt;
					{
						Disconnect(player, true);
						OnPlayerTimeout(player);
						CleanupDisconnections();
					});
				});

				//Let myself know I connected successfully
				OnPlayerConnected(Me);
				// Set myself as a connected client
				Me.Connected = true;

				//Set the port
				SetPort((ushort)((IPEndPoint)Client.Client.LocalEndPoint).Port);

				if (!string.IsNullOrEmpty(natHost))
				{
					nat.Register((ushort)Me.IPEndPointHandle.Port, natHost, natPort);
					nat.clientConnectAttempt += NatClientConnectAttempt;
				}
			}
			catch (Exception e)
			{
				Logging.BMSLog.LogException(e);
				// Do any generic initialization in result of the binding failure
				OnBindFailure();

				throw new FailedBindingException(&quot;Failed to bind to host/port, see inner exception&quot;, e);
			}
		}

		/// &lt;summary&gt;
		/// Disconnects this server and all of it&#39;s clients
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;forced&quot;&gt;Used to tell if this disconnect was intentional &lt;c&gt;false&lt;/c&gt; or caused by an exception &lt;c&gt;true&lt;/c&gt;&lt;/param&gt;
		public override void Disconnect(bool forced)
		{
			nat.Disconnect();

			// Since we are disconnecting we need to stop the read thread
			readThreadCancel = true;

			lock (Players)
			{
				// Go through all of the players and disconnect them
				foreach (NetworkingPlayer player in Players)
				{
					if (player != Me)
						Disconnect(player, forced);
				}

				CleanupDisconnections();

				int counter = 0;
				for (; ; counter++)
				{
					if (counter &gt;= 10 || Players.Count == 1)
						break;

					Thread.Sleep(100);
				}

				// Send signals to the methods registered to the disconnect events
				if (!forced)
					OnDisconnected();
				else
					OnForcedDisconnect();

				// Stop listening for new connections
				Client.Close();
			}
		}

		/// &lt;summary&gt;
		/// Disconnects a client
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;client&quot;&gt;The target client to be disconnected&lt;/param&gt;
		public void Disconnect(NetworkingPlayer player, bool forced)
		{
			commonServerLogic.Disconnect(player, forced, DisconnectingPlayers, ForcedDisconnectingPlayers);
		}

		/// &lt;summary&gt;
		/// Call the base disconnect pending method to remove all pending disconnecting clients
		/// &lt;/summary&gt;
		private void CleanupDisconnections() { DisconnectPending(RemovePlayer); }

		/// &lt;summary&gt;
		/// Commit the disconnects
		/// &lt;/summary&gt;
		public void CommitDisconnects() { CleanupDisconnections(); }

		/// &lt;summary&gt;
		/// Fully remove the player from the network
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;player&quot;&gt;The target player&lt;/param&gt;
		/// &lt;param name=&quot;forced&quot;&gt;If the player is being forcibly removed from an exception&lt;/param&gt;
		private void RemovePlayer(NetworkingPlayer player, bool forced)
		{
			lock (Players)
			{
				if (player.IsDisconnecting)
					return;

				player.IsDisconnecting = true;
			}

			// Tell the player that they are getting disconnected
			Send(player, new ConnectionClose(Time.Timestep, false, Receivers.Target, MessageGroupIds.DISCONNECT, false), !forced);

			if (!forced)
			{
				Task.Queue(() =&gt;
				{
					FinalizeRemovePlayer(player, forced);
				}, 1000);
			}
			else
				FinalizeRemovePlayer(player, forced);
		}

		private void FinalizeRemovePlayer(NetworkingPlayer player, bool forced)
		{
			udpPlayers.Remove(player.Ip + &quot;+&quot; + player.Port);
			OnPlayerDisconnected(player);

			if (forced)
				ForcedDisconnectingPlayers.Remove(player);
			else
				DisconnectingPlayers.Remove(player);
		}

		/// &lt;summary&gt;
		/// Infinite loop listening for new data from all connected clients on a separate thread.
		/// This loop breaks when readThreadCancel is set to true
		/// &lt;/summary&gt;
		private void ReadClients()
		{
			IPEndPoint groupEP = new IPEndPoint(IPAddress.Any, 0);
			string incomingEndpoint = string.Empty;

			BMSByte packet = null;

			// Intentional infinite loop
			while (IsBound)
			{
				// If the read has been flagged to be canceled then break from this loop
				if (readThreadCancel)
					return;

				try
				{
					// Read a packet from the network
					packet = Client.Receive(ref groupEP, ref incomingEndpoint);

					if (PacketLossSimulation &gt; 0.0f &amp;&amp; new Random().NextDouble() &lt;= PacketLossSimulation)
					{
						// Skip this message
						continue;
					}

					BandwidthIn += (ulong)packet.Size;
				}
				catch
				{
					UDPNetworkingPlayer player;
					if (udpPlayers.TryGetValue(incomingEndpoint, out player))
					{
						FinalizeRemovePlayer(player, true);
					}

					continue;
				}

				// Check to make sure a message was received
				if (packet == null || packet.Size &lt;= 0)
					continue;

				if (!udpPlayers.ContainsKey(incomingEndpoint))
				{
					SetupClient(packet, incomingEndpoint, groupEP);
					continue;
				}
				else
				{
					currentReadingPlayer = udpPlayers[incomingEndpoint];

					if (!currentReadingPlayer.Accepted &amp;&amp; !currentReadingPlayer.PendingAccepted)
					{
						// It is possible that the response validation was dropped so
						// check if the client is resending for a response
						byte[] response = Websockets.ValidateConnectionHeader(packet.CompressBytes());

						// The client has sent the connection request again
						if (response != null)
						{
							Client.Send(response, response.Length, groupEP);
							continue;
						}
						else
						{
							currentReadingPlayer.PendingAccepted = true;
							ReadPacket(packet);
						}
					}
					else
					{
						currentReadingPlayer.Ping();
						ReadPacket(packet);
					}
				}
			}
		}

		private void SetupClient(BMSByte packet, string incomingEndpoint, IPEndPoint groupEP)
		{
			// Check for a local listing request
			if (packet.Size.Between(2, 4) &amp;&amp; packet[0] == BROADCAST_LISTING_REQUEST_1 &amp;&amp; packet[1] == BROADCAST_LISTING_REQUEST_2 &amp;&amp; packet[2] == BROADCAST_LISTING_REQUEST_3)
			{
				// Don&#39;t reply if the server is not currently accepting connections
				if (!AcceptingConnections)
					return;

				// This may be a local listing request so respond with the server flag byte
				Client.Send(new byte[] { SERVER_BROADCAST_CODE }, 1, groupEP);
				return;
			}

			if (Players.Count == MaxConnections)
			{
				// Tell the client why they are being disconnected
				var frame = Error.CreateErrorMessage(Time.Timestep, &quot;Max Players Reached On Server&quot;, false, MessageGroupIds.MAX_CONNECTIONS, false);
				var playerToDisconnect = new UDPNetworkingPlayer(ServerPlayerCounter++, incomingEndpoint, false, groupEP, this);
				new UDPPacketComposer(this, playerToDisconnect, frame, false);

				// Send the close connection frame to the client
				new UDPPacketComposer(this, playerToDisconnect, new ConnectionClose(Time.Timestep, false, Receivers.Target, MessageGroupIds.DISCONNECT, false), false);

				return;
			}
			else if (!AcceptingConnections)
			{
				// Tell the client why they are being disconnected
				var frame = Error.CreateErrorMessage(Time.Timestep, &quot;The server is busy and not accepting connections&quot;, false, MessageGroupIds.NOT_ACCEPT_CONNECTIONS, false);
				var playerToDisconnect = new UDPNetworkingPlayer(ServerPlayerCounter++, incomingEndpoint, false, groupEP, this);
				new UDPPacketComposer(this, playerToDisconnect, frame, false);

				// Send the close connection frame to the client
				new UDPPacketComposer(this, playerToDisconnect, new ConnectionClose(Time.Timestep, false, Receivers.Target, MessageGroupIds.DISCONNECT, false), false);

				return;
			}

			// Validate that the connection headers are properly formatted
			byte[] response = Websockets.ValidateConnectionHeader(packet.CompressBytes());

			// The response will be null if the header sent is invalid, if so then disconnect client as they are sending invalid headers
			if (response == null)
				return;

			UDPNetworkingPlayer player = new UDPNetworkingPlayer(ServerPlayerCounter++, incomingEndpoint, false, groupEP, this);

			// If all is in order then send the validated response to the client
			Client.Send(response, response.Length, groupEP);

			OnPlayerConnected(player);
			udpPlayers.Add(incomingEndpoint, player);

			// The player has successfully connected
			player.Connected = true;
		}

		private void ReadPacket(BMSByte packet)
		{
			if (packet.Size &lt; 17)
				return;

			try
			{
				// Format the byte data into a UDPPacket struct
				UDPPacket formattedPacket = TranscodePacket(currentReadingPlayer, packet);

				if (formattedPacket.endPacket &amp;&amp; !formattedPacket.isConfirmation)
				{
					// Due to the Forge Networking protocol, the only time that packet 1
					// will be 71 and the second packet be 69 is a forced disconnect reconnect
					if (packet[0] == 71 &amp;&amp; packet[1] == 69)
					{
						udpPlayers.Remove(currentReadingPlayer.Ip + &quot;+&quot; + currentReadingPlayer.Port);
						FinalizeRemovePlayer(currentReadingPlayer, true);
						return;
					}
				}

				// Check to see if this is a confirmation packet, which is just
				// a packet to say that the reliable packet has been read
				if (formattedPacket.isConfirmation)
				{
					// Called once the player has confirmed that it has been accepted
					if (formattedPacket.groupId == MessageGroupIds.NETWORK_ID_REQUEST &amp;&amp; !currentReadingPlayer.Accepted &amp;&amp; currentReadingPlayer.Authenticated)
					{
						System.Diagnostics.Debug.WriteLine(string.Format(&quot;[{0}] REQUESTED ID RECEIVED&quot;, DateTime.Now.Millisecond));
						// The player has been accepted
						OnPlayerAccepted(currentReadingPlayer);
					}

					OnMessageConfirmed(currentReadingPlayer, formattedPacket);
					return;
				}

				// Add the packet to the manager so that it can be tracked and executed on complete
				currentReadingPlayer.PacketManager.AddPacket(formattedPacket, PacketSequenceComplete, this);
			}
			catch (Exception ex)
			{
				Logging.BMSLog.LogException(ex);

				// The player is sending invalid data so disconnect them
				Disconnect(currentReadingPlayer, true);
			}
		}

		private void PacketSequenceComplete(BMSByte data, int groupId, byte receivers, bool isReliable)
		{
			// Pull the frame from the sent message
			FrameStream frame = Factory.DecodeMessage(data.CompressBytes(), false, groupId, currentReadingPlayer, receivers);

			if (isReliable)
			{
				frame.ExtractReliableId();

				// TODO:  If the current reliable index for this player is not at
				// the specified index, then it needs to wait for the correct ordering
				currentReadingPlayer.WaitReliable(frame);
			}
			else
				FireRead(frame, currentReadingPlayer);
		}

		public override void FireRead(FrameStream frame, NetworkingPlayer currentPlayer)
		{
			// Check for default messages
			if (frame is Text)
			{
				// This packet is sent if the player did not receive it&#39;s network id
				if (frame.GroupId == MessageGroupIds.NETWORK_ID_REQUEST)
				{
					currentPlayer.InstanceGuid = frame.ToString();

					bool rejected;
					OnPlayerGuidAssigned(currentPlayer, out rejected);

					// If the player was rejected during the handling of the playerGuidAssigned event, don&#39;t accept them.
					if (rejected)
						return;

                    // If so, check if there&#39;s a user authenticator
                    if (authenticator != null)
                    {
                        authenticator.IssueChallenge(this, currentPlayer, IssueChallenge, AuthUser);
                    } else
                    {
                        AuthUser(currentPlayer);
                    }
					return;
				} 
			} else if (frame is Binary)
            {
                if (frame.GroupId == MessageGroupIds.AUTHENTICATION_RESPONSE)
                {
                    // Authenticate user response
                    if (currentPlayer.Authenticated || authenticator == null)
                        return;

                    authenticator.VerifyResponse(this, currentPlayer, frame.StreamData, AuthUser, RejectUser);
                    return;
                }
            }

			if (frame is ConnectionClose)
			{
				//Send(currentReadingPlayer, new ConnectionClose(Time.Timestep, false, Receivers.Server, MessageGroupIds.DISCONNECT, false), false);

				Disconnect(currentReadingPlayer, true);
				CleanupDisconnections();
				return;
			}

			// Send an event off that a packet has been read
			OnMessageReceived(currentReadingPlayer, frame);
		}

        /// &lt;summary&gt;
        /// Callback for user auth. Sends an auth challenge to the user.
        /// &lt;/summary&gt;
        private void IssueChallenge(NetworkingPlayer player, BMSByte buffer)
        {
            Send(player, new Binary(Time.Timestep, false, buffer, Receivers.Target, MessageGroupIds.AUTHENTICATION_CHALLENGE, false), true);
        }

        /// &lt;summary&gt;
        /// Callback for user auth. Authenticates the user and sends the user their network id for acceptance.
        /// &lt;/summary&gt;
        private void AuthUser(NetworkingPlayer player)
        {
            OnPlayerAuthenticated(player);

            // If authenticated, send the player their network id and accept them
            var buffer = new BMSByte();
            buffer.Append(BitConverter.GetBytes(player.NetworkId));
            Send(player, new Binary(Time.Timestep, false, buffer, Receivers.Target, MessageGroupIds.NETWORK_ID_REQUEST, false), true);
            SendBuffer(player);
        }

        /// &lt;summary&gt;
        /// Callback for user auth. Sends an authentication failure message to the user and then disconnects them.
        /// &lt;/summary&gt;
        private void RejectUser(NetworkingPlayer player)
        {
            OnPlayerRejected(player);
            Send(player, Error.CreateErrorMessage(Time.Timestep, &quot;Authentication Failed&quot;, false, MessageGroupIds.AUTHENTICATION_FAILURE, false), false);
            SendBuffer(player);
            Disconnect(player, true);
            CommitDisconnects();
        }

        /// &lt;summary&gt;
        /// A callback from the NatHolePunch object saying that a client is trying to connect
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;host&quot;&gt;The host address of the client trying to connect&lt;/param&gt;
        /// &lt;param name=&quot;port&quot;&gt;The port number to communicate with the client on&lt;/param&gt;
        private void NatClientConnectAttempt(string host, ushort port)
		{
			IPEndPoint clientIPEndPoint;

			Logging.BMSLog.LogFormat(&quot;ATTEMPTING CONNECT ON {0} AND PORT IS {1}&quot;, host, port);

			try
			{
				clientIPEndPoint = ResolveHost(host, port);
			}
			catch (ArgumentException)
			{
				Logging.BMSLog.LogExceptionFormat(&quot;Unable to resolve client host {0}&quot;, host);
				// Do nothing as the client&#39;s host cannot be resolved.
				return;
			}

			Logging.BMSLog.LogFormat(&quot;RESOLVED IS {0} AND {1}&quot;, clientIPEndPoint.Address.ToString(), clientIPEndPoint.Port);

			// Punch a hole in the nat for this client
			Client.Send(new byte[1] { 0 }, 1, clientIPEndPoint);
		}

		private void SendBuffer(NetworkingPlayer player)
		{
			foreach (FrameStream frame in bufferedMessages)
				Send(player, frame, true);
		}

		public override void Ping()
		{
			// I am the server, so 0 ms...
			OnPingRecieved(0, Me);
		}

		/// &lt;summary&gt;
		/// Pong back to the client
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;playerRequesting&quot;&gt;&lt;/param&gt;
		protected override void Pong(NetworkingPlayer playerRequesting, DateTime time)
		{
			Send(playerRequesting, GeneratePong(time));
		}

		public void StopAcceptingConnections()
		{
			AcceptingConnections = false;
		}

		public void StartAcceptingConnections()
		{
			AcceptingConnections = true;
		}

		public void BanPlayer(ulong networkId, int minutes)
		{
			NetworkingPlayer player = Players.FirstOrDefault(p =&gt; p.NetworkId == networkId);

			if (player == null)
				return;

			BannedAddresses.Add(player.Ip);
			Disconnect(player, true);
			CommitDisconnects();
		}
	}
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[35,3,35,109,0],[37,3,37,59,0],[39,42,39,62,0],[40,3,40,4,0],[41,4,41,32,0],[42,4,42,41,0],[43,4,43,52,0],[44,3,44,4,0],[46,3,46,48,0],[48,3,48,74,0],[50,41,50,45,0],[50,46,50,50,0],[55,38,55,42,0],[55,43,55,55,0],[58,3,58,4,0],[59,4,59,86,0],[63,4,63,17,0],[64,4,64,5,0],[65,5,65,28,0],[66,5,66,6,0],[68,6,68,46,0],[69,6,69,37,0],[70,5,70,6,0],[71,4,71,5,0],[72,3,72,4,0],[75,3,75,4,0],[76,4,76,32,0],[77,3,77,4,0],[80,3,80,4,0],[81,4,81,96,0],[82,5,82,33,0],[84,4,84,18,0],[85,4,85,5,0],[86,5,86,12,0],[86,14,86,37,0],[86,38,86,40,0],[86,41,86,48,0],[87,5,87,6,0],[89,6,89,122,0],[90,7,90,16,0],[93,6,93,7,0],[94,7,94,37,0],[95,6,95,7,0],[96,6,96,11,0],[97,6,97,7,0],[98,7,98,32,0],[99,6,99,7,0],[100,5,100,6,0],[101,4,101,5,0],[102,3,102,4,0],[107,3,107,4,0],[108,4,108,96,0],[109,5,109,33,0],[111,4,111,18,0],[112,4,112,5,0],[113,5,113,12,0],[113,14,113,37,0],[113,38,113,40,0],[113,41,113,48,0],[114,5,114,6,0],[116,6,116,126,0],[117,7,117,16,0],[119,6,119,122,0],[120,7,120,16,0],[123,6,123,7,0],[124,7,124,37,0],[125,6,125,7,0],[126,6,126,11,0],[127,6,127,7,0],[128,7,128,32,0],[129,6,129,7,0],[130,5,130,6,0],[131,4,131,5,0],[132,3,132,4,0],[142,3,142,4,0],[143,4,143,55,0],[144,4,144,103,0],[145,4,145,38,0],[146,3,146,4,0],[157,3,157,4,0],[158,4,158,55,0],[159,4,159,96,0],[160,4,160,46,0],[161,3,161,4,0],[164,3,164,4,0],[165,4,165,17,0],[166,5,166,144,0],[169,4,169,5,0],[170,5,170,40,0],[171,5,171,35,0],[172,5,172,97,0],[173,5,173,47,0],[176,5,176,24,0],[179,5,179,29,0],[182,5,183,5,0],[183,5,183,6,0],[183,6,184,6,0],[184,6,185,6,0],[185,6,185,7,0],[185,7,186,7,0],[186,7,186,32,0],[186,32,187,7,0],[187,7,187,31,0],[187,31,188,7,0],[188,7,188,31,0],[188,31,189,6,0],[189,6,189,7,0],[189,7,189,9,0],[184,6,189,9,0],[189,9,190,5,0],[190,5,190,6,0],[190,6,190,8,0],[182,5,190,8,0],[193,5,193,27,0],[195,5,195,25,0],[198,5,198,69,0],[200,5,200,40,0],[201,5,201,6,0],[202,6,202,71,0],[203,6,203,58,0],[204,5,204,6,0],[205,4,205,5,0],[206,4,206,23,0],[207,4,207,5,0],[208,5,208,36,0],[210,5,210,21,0],[212,5,212,93,0],[214,3,214,4,0],[221,3,221,4,0],[222,4,222,21,0],[225,4,225,28,0],[227,4,227,18,0],[228,4,228,5,0],[230,5,230,12,0],[230,14,230,37,0],[230,38,230,40,0],[230,41,230,48,0],[231,5,231,6,0],[232,6,232,23,0],[233,7,233,34,0],[234,5,234,6,0],[236,5,236,29,0],[238,5,238,21,0],[239,14,239,23,0],[240,5,240,6,0],[241,6,241,46,0],[242,7,242,13,0],[244,6,244,24,0],[245,5,245,6,0],[248,5,248,17,0],[249,6,249,23,0],[251,6,251,27,0],[254,5,254,20,0],[255,4,255,5,0],[256,3,256,4,0],[263,3,263,4,0],[264,4,264,99,0],[265,3,265,4,0],[270,40,270,41,0],[270,42,270,74,0],[270,75,270,76,0],[275,35,275,36,0],[275,37,275,61,0],[275,62,275,63,0],[283,3,283,4,0],[284,4,284,18,0],[285,4,285,5,0],[286,5,286,32,0],[287,6,287,13,0],[289,5,289,35,0],[290,4,290,5,0],[293,4,293,122,0],[295,4,295,16,0],[296,4,296,5,0],[297,5,298,5,0],[298,5,298,6,0],[298,6,299,6,0],[299,6,299,43,0],[299,43,300,5,0],[300,5,300,6,0],[300,6,300,14,0],[297,5,300,14,0],[301,4,301,5,0],[303,5,303,42,0],[304,3,304,4,0],[307,3,307,4,0],[308,4,308,53,0],[309,4,309,33,0],[311,4,311,15,0],[312,5,312,47,0],[314,5,314,41,0],[315,3,315,4,0],[322,3,322,4,0],[323,4,323,58,0],[324,4,324,43,0],[326,4,326,26,0],[329,4,329,19,0],[330,4,330,5,0],[332,5,332,26,0],[333,6,333,13,0],[336,5,336,6,0],[338,6,338,65,0],[340,6,340,91,0],[341,6,341,7,0],[343,7,343,16,0],[346,6,346,40,0],[347,5,347,6,0],[348,5,348,10,0],[349,5,349,6,0],[351,6,351,63,0],[352,6,352,7,0],[353,7,353,42,0],[354,6,354,7,0],[356,6,356,15,0],[360,5,360,44,0],[361,6,361,15,0],[363,5,363,51,0],[364,5,364,6,0],[365,6,365,53,0],[366,6,366,15,0],[369,5,369,6,0],[370,6,370,58,0],[372,6,372,82,0],[373,6,373,7,0],[376,7,376,85,0],[379,7,379,28,0],[380,7,380,8,0],[381,8,381,56,0],[382,8,382,17,0],[385,7,385,8,0],[386,8,386,52,0],[387,8,387,27,0],[388,7,388,8,0],[389,6,389,7,0],[391,6,391,7,0],[392,7,392,35,0],[393,7,393,26,0],[394,6,394,7,0],[395,5,395,6,0],[396,4,396,5,0],[397,3,397,4,0],[400,3,400,4,0],[402,4,402,166,0],[403,4,403,5,0],[405,5,405,31,0],[406,6,406,13,0],[409,5,409,67,0],[410,5,410,12,0],[413,4,413,40,0],[414,4,414,5,0],[416,5,416,137,0],[417,5,417,117,0],[418,5,418,67,0],[421,5,421,156,0],[423,5,423,12,0],[425,9,425,35,0],[426,4,426,5,0],[428,5,428,163,0],[429,5,429,117,0],[430,5,430,67,0],[433,5,433,156,0],[435,5,435,12,0],[439,4,439,82,0],[442,4,442,25,0],[443,5,443,12,0],[445,4,445,120,0],[448,4,448,52,0],[450,4,450,30,0],[451,4,451,45,0],[454,4,454,28,0],[455,3,455,4,0],[458,3,458,4,0],[459,4,459,25,0],[460,5,460,12,0],[463,4,463,5,0],[465,5,465,79,0],[467,5,467,70,0],[468,5,468,6,0],[471,6,471,45,0],[472,6,472,7,0],[473,7,473,84,0],[474,7,474,56,0],[475,7,475,14,0],[477,5,477,6,0],[481,5,481,40,0],[482,5,482,6,0],[484,6,484,144,0],[485,6,485,7,0],[486,7,486,114,0],[488,7,488,46,0],[489,6,489,7,0],[491,6,491,64,0],[492,6,492,13,0],[496,5,496,97,0],[497,4,497,5,0],[498,4,498,24,0],[499,4,499,5,0],[500,5,500,37,0],[503,5,503,44,0],[504,4,504,5,0],[505,3,505,4,0],[508,3,508,4,0],[510,4,510,117,0],[512,4,512,19,0],[513,4,513,5,0],[514,5,514,31,0],[518,5,518,46,0],[519,4,519,5,0],[521,5,521,43,0],[522,3,522,4,0],[525,3,525,4,0],[527,4,527,22,0],[528,4,528,5,0],[530,5,530,61,0],[531,5,531,6,0],[532,6,532,52,0],[535,6,535,56,0],[538,6,538,19,0],[539,7,539,14,0],[542,21,542,47,0],[543,21,543,22,0],[544,25,544,101,0],[545,21,545,22,0],[546,21,546,22,0],[547,25,547,49,0],[548,21,548,22,0],[549,6,549,13,0],[551,4,551,5,0],[551,11,551,31,0],[552,13,552,14,0],[553,17,553,78,0],[554,17,554,18,0],[556,21,556,78,0],[557,25,557,32,0],[559,21,559,111,0],[560,21,560,28,0],[562,13,562,14,0],[564,4,564,33,0],[565,4,565,5,0],[568,5,568,44,0],[569,5,569,29,0],[570,5,570,12,0],[574,4,574,51,0],[575,3,575,4,0],[581,9,581,10,0],[582,13,582,141,0],[583,9,583,10,0],[589,9,589,10,0],[590,13,590,43,0],[593,13,593,40,0],[594,13,594,68,0],[595,13,595,135,0],[596,13,596,32,0],[597,9,597,10,0],[603,9,603,10,0],[604,13,604,38,0],[605,13,605,153,0],[606,13,606,32,0],[607,13,607,38,0],[608,13,608,33,0],[609,9,609,10,0],[617,3,617,4,0],[620,4,620,86,0],[623,4,623,5,0],[624,5,624,48,0],[625,4,625,5,0],[626,4,626,29,0],[627,4,627,5,0],[628,5,628,82,0],[630,5,630,12,0],[633,4,633,116,0],[636,4,636,56,0],[637,3,637,4,0],[640,3,640,4,0],[641,4,641,11,0],[641,13,641,30,0],[641,31,641,33,0],[641,34,641,50,0],[642,5,642,31,0],[643,3,643,4,0],[646,3,646,4,0],[648,4,648,26,0],[649,3,649,4,0],[656,3,656,4,0],[657,4,657,47,0],[658,3,658,4,0],[661,3,661,4,0],[662,4,662,33,0],[663,3,663,4,0],[666,3,666,4,0],[667,4,667,32,0],[668,3,668,4,0],[671,3,671,4,0],[672,4,672,58,0],[672,58,672,82,0],[672,82,672,84,0],[672,4,672,84,0],[674,4,674,23,0],[675,5,675,12,0],[677,4,677,35,0],[678,4,678,29,0],[679,4,679,24,0],[680,3,680,4,0]]);
    </script>
  </body>
</html>