<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>p:\stuff\projects\minigamesproject\minigamesproject\assets\_assets\scripts\games\tankgame\tankai\components\tankaimovement.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.Linq;

public class TankAIMovement : TankAIComponent {

    #region fields
    private Vector[] path;
    private TankControls controls;

    private bool stuck;
    private float stuckTime;
    private Vector stuckPos;
    #endregion

    public TankAIMovement(TankAI ai) : base(ai) {
        controls = ai.GetComponent&lt;TankControls&gt;();
    }

    public override void Update() {

    }

    #region Traversal
    public void TraversePath(Vector[] path) {

        TankPathVisualizer.DrawRoute(path);

        ai.StopCoroutine(TraversePathCoroutine());
        ai.StopCoroutine(RemoveStuck());

        this.path = path;
        ai.StartCoroutine(TraversePathCoroutine());
    }

    private IEnumerator TraversePathCoroutine() {

        int index = 0;

        while (index &lt; path.Length) {

            ResetStuck();

            Vector targetPos = path[index];

            while (!InCoords(index)) {

                StuckCheck();

                if (stuck) {
                    controls.ProcessControl(TankControls.Control.Movement, -1);
                } else {
                    MoveTowards(targetPos);
                }
                
                yield return null;
            }

            index++;
        }
    }

    private void StuckCheck() {

        if (stuck) {
            return;
        }

        if (Vector.Distance(stuckPos, Vector.FromVector3(ai.transform.position)) &lt; AISettings.StuckTresholdDistance) {
            stuckTime += Time.deltaTime;

            if (stuckTime &gt; AISettings.StuckTresholdTime) {
                stuck = true;
                ai.StartCoroutine(RemoveStuck());
            }
        } else {
            ResetStuck();
        }
    }
    private IEnumerator RemoveStuck() {

        float time = AISettings.StuckCooldown;

        while (time &gt; 0) {
            time -= Time.deltaTime;
            yield return null;
        }

        ResetStuck();
    }
    private void ResetStuck() {
        stuck = false;
        stuckTime = 0;
        stuckPos = Vector.FromVector3(ai.transform.position);
    }

    private bool InCoords(int i) {

        Vector target = path[i];
        Vector current = Vector.FromVector3(ai.transform.position);

        return Vector.Distance(target, current) &lt; AISettings.DistanceLimit;
    }

    private void MoveTowards(Vector position) {

        TurnToPosition(position);

        Vector3 currentRotation = ai.transform.eulerAngles;
        Vector3 targetRotation = Quaternion.LookRotation(Vector.ToVector3(position) - ai.transform.position, Vector3.up).eulerAngles;

        if (Vector3.Angle(currentRotation, targetRotation) &lt; AISettings.MovementAngle) {
            controls.ProcessControl(TankControls.Control.Movement, 1);
        }
    }
    private void TurnToPosition(Vector position) {

        // Replace Quaternion.LookRotation
        Vector currentRotation = Vector.FromVector3(ai.transform.eulerAngles);
        Vector targetRotation = Vector.FromVector3(Quaternion.LookRotation(Vector.ToVector3(position) - ai.transform.position, Vector3.up).eulerAngles);

        float rotation = TurnDirection(currentRotation, targetRotation);
        controls.ProcessControl(TankControls.Control.Rotation, rotation);
    }
    private float TurnDirection(Vector current, Vector target) {


        // wtf does this do, found from internet
        int rotateDirection = (((target.y - current.y) + 360f) % 360f) &gt; 180.0f ? -1 : 1;

        float angleDif = (((target.y - current.y) + 360f) % 360f);

        float min = Maths.Min(Maths.Abs(angleDif), Maths.Abs(angleDif - 360));

        if (min &lt; AISettings.TurnAngleLimit) {

            float factor = min / AISettings.TurnAngleLimit;
            return factor * rotateDirection;
        } else {
            return rotateDirection;
        }
    }
    #endregion
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[17,40,17,48,0],[17,49,17,50,0],[18,9,18,52,0],[19,5,19,6,0],[21,35,21,36,0],[23,5,23,6,0],[26,45,26,46,0],[28,9,28,44,0],[30,9,30,51,0],[31,9,31,41,0],[33,9,33,26,0],[34,9,34,52,0],[35,5,35,6,0],[37,49,37,50,0],[39,9,39,23,0],[41,9,41,36,0],[41,37,41,38,0],[43,13,43,26,0],[45,13,45,44,0],[47,13,47,37,0],[47,38,47,39,0],[49,17,49,30,0],[51,17,51,27,0],[51,28,51,29,0],[52,21,52,80,0],[53,17,53,18,0],[53,24,53,25,0],[54,21,54,44,0],[55,17,55,18,0],[57,17,57,35,0],[58,13,58,14,0],[60,13,60,21,0],[61,9,61,10,0],[62,5,62,6,0],[64,31,64,32,0],[66,9,66,19,0],[66,20,66,21,0],[67,13,67,20,0],[70,9,70,117,0],[70,118,70,119,0],[71,13,71,41,0],[73,13,73,58,0],[73,59,73,60,0],[74,17,74,30,0],[75,17,75,50,0],[76,13,76,14,0],[77,9,77,10,0],[77,16,77,17,0],[78,13,78,26,0],[79,9,79,10,0],[80,5,80,6,0],[81,39,81,40,0],[83,9,83,47,0],[85,9,85,25,0],[85,26,85,27,0],[86,13,86,36,0],[87,13,87,31,0],[88,9,88,10,0],[90,9,90,22,0],[91,5,91,6,0],[92,31,92,32,0],[93,9,93,23,0],[94,9,94,23,0],[95,9,95,62,0],[96,5,96,6,0],[98,34,98,35,0],[100,9,100,33,0],[101,9,101,68,0],[103,9,103,76,0],[104,5,104,6,0],[106,47,106,48,0],[108,9,108,34,0],[110,9,110,60,0],[111,9,111,134,0],[113,9,113,87,0],[113,88,113,89,0],[114,13,114,71,0],[115,9,115,10,0],[116,5,116,6,0],[117,50,117,51,0],[120,9,120,79,0],[121,9,121,153,0],[123,9,123,73,0],[124,9,124,74,0],[125,5,125,6,0],[126,64,126,65,0],[130,9,130,90,0],[132,9,132,67,0],[134,9,134,79,0],[136,9,136,45,0],[136,46,136,47,0],[138,13,138,60,0],[139,13,139,45,0],[140,16,140,17,0],[141,13,141,36,0],[143,5,143,6,0]]);
    </script>
  </body>
</html>