<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>p:\stuff\projects\minigamesproject\minigamesproject\assets\_assets\scripts\bearded man studios\scripts\templatesystem.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
/*-----------------------------+-------------------------------\
|                                                              |
|                         !!!NOTICE!!!                         |
|                                                              |
|  These libraries are under heavy development so they are     |
|  subject to make many changes as development continues.      |
|  For this reason, the libraries may not be well commented.   |
|  THANK YOU for supporting forge with all your feedback       |
|  suggestions, bug reports and comments!                      |
|                                                              |
|                              - The Forge Team                |
|                                Bearded Man Studios, Inc.     |
|                                                              |
|  This source code, project files, and associated files are   |
|  copyrighted by Bearded Man Studios, Inc. (2012-2017) and    |
|  may not be redistributed without written permission.        |
|                                                              |
\------------------------------+------------------------------*/

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;

namespace BeardedManStudios.Templating
{
	public sealed class TemplateSystem
	{
		private string targetTemplate = string.Empty;
		private Dictionary&lt;string, object&gt; replaces = new Dictionary&lt;string, object&gt;();
		private enum State
		{
			None = 0x0,
			ForEach = 0x1,
			ForEvery = 0x2
		}
		private State state = State.None;
		private object[] iteratee;
		private int currentIterateeIndex = 0;
		private int loopStart = -1;
		private bool emptyArray = false;

		public TemplateSystem(string text)
		{
			targetTemplate = text;
		}

		public void AddVariable(string key, object val)
		{
			replaces.Add(key, val);
		}

		public string Parse()
		{
			List&lt;string&gt; lines = new List&lt;string&gt;(targetTemplate.Replace(&quot;\r\n&quot;, &quot;\n&quot;).Split(&#39;\n&#39;));

			List&lt;string&gt; finalLines = new List&lt;string&gt;(lines.Count);

			int offset = 0;
			bool parsed = false;
			bool skipLine = false;
			State foundState = State.None;
			StringBuilder sb;
			for (int i = 0; i &lt; lines.Count; i++)
			{
				parsed = false;
				skipLine = false;
				sb = new StringBuilder(lines[i]);

				while (true)
				{
					string current = sb.ToString();
					int parseStart = current.IndexOf(&quot;&gt;:&quot;, offset);
					if (parseStart &lt; 0)
						break;

					parseStart += 2;
					int parseEnd = current.IndexOf(&quot;:&lt;&quot;, offset + parseStart);

					if (parseEnd &lt; 0)
						throw new Exception(&quot;There was a parse start but no end on line &quot; + (i + 1));

					string contents = current.Substring(parseStart, parseEnd - parseStart);

					sb.Remove(parseStart - 2, parseEnd - parseStart + 4);

					if (CheckState(contents, ref foundState))
					{
						skipLine = true;

						// If we have left the loop
						if (foundState == State.None)
						{
							if (loopStart == -1)
								continue;

							if (++currentIterateeIndex &gt;= iteratee.Length)
							{
								state &amp;= ~(State.ForEach | State.ForEvery);
								iteratee = null;
								loopStart = -1;
								emptyArray = false;
							}
							else
							{
								i = loopStart - 1;
								break;
							}
						}
						else if (foundState == State.ForEach || foundState == State.ForEvery)
							loopStart = i + 1;

						continue;
					}

					if (!emptyArray)
						sb.Insert(parseStart - 2, ParseLine(contents));

					parsed = true;
				}

				string built = sb.ToString();

				if (parsed &amp;&amp; built.Trim().Length == 0)
					lines.RemoveAt(i--);
				else if (!skipLine &amp;&amp; !emptyArray)
					finalLines.Add(built);
			}

			return string.Join(Environment.NewLine, finalLines.ToArray());
		}

		private bool CheckState(string contents, ref State foundState)
		{
			if (contents.StartsWith(&quot;ENDFOREACH&quot;))
			{
				if ((state &amp; State.ForEach) == 0)
					throw new Exception(&quot;A foreach has ended before the start of the loop&quot;);

				foundState = State.None;
				return true;
			}
			if (contents.StartsWith(&quot;ENDFOREVERY&quot;))
			{
				if ((state &amp; State.ForEvery) == 0)
					throw new Exception(&quot;A foreach has ended before the start of the loop&quot;);

				foundState = State.None;
				return true;
			}
			else if (contents.StartsWith(&quot;FOREACH&quot;))
			{
				if ((state &amp; State.ForEach) != 0 || (state &amp; State.ForEvery) != 0)
					throw new Exception(&quot;A loop is already in execution and in this version nested foreach loops are not allowed&quot;);

				state |= State.ForEach;

				string iterateeName = contents.TrimStart(&quot;FOREACH &quot;.ToCharArray());

				if (!replaces.ContainsKey(iterateeName))
					throw new Exception(&quot;No variable with the name &quot; + iterateeName + &quot; could be located&quot;);

				iteratee = (object[])replaces[iterateeName];

				if (iteratee.Length == 0)
					emptyArray = true;

				currentIterateeIndex = 0;
				foundState = State.ForEach;
				return true;
			}
			else if (contents.StartsWith(&quot;FOREVERY&quot;))
			{
				if ((state &amp; State.ForEach) != 0 || (state &amp; State.ForEvery) != 0)
					throw new Exception(&quot;A loop is already in execution and in this version nested foreach loops are not allowed&quot;);

				state |= State.ForEvery;

				string iterateeName = contents.TrimStart(&quot;FOREVERY &quot;.ToCharArray());

				if (!replaces.ContainsKey(iterateeName))
					throw new Exception(&quot;No variable with the name &quot; + iterateeName + &quot; could be located&quot;);

				iteratee = (object[])replaces[iterateeName];

				if (iteratee.Length == 0 || ((object[])iteratee[0]).Length == 0)
					emptyArray = true;

				currentIterateeIndex = 0;
				foundState = State.ForEvery;
				return true;
			}

			return false;
		}

		private string ParseLine(string contents)
		{
			if (contents.StartsWith(&quot;[&quot;) &amp;&amp; contents.EndsWith(&quot;]&quot;))
			{
				if (contents == &quot;[i]&quot; &amp;&amp; iteratee != null)
					return FormatReturn(iteratee[currentIterateeIndex]);
				else if (contents == &quot;[idx]&quot; &amp;&amp; iteratee != null)
					return FormatReturn(currentIterateeIndex);
				else
				{
					var idxStr = contents.TrimStart(&#39;[&#39;).TrimEnd(&#39;]&#39;);
					int idx = -1;
					if (int.TryParse(idxStr, out idx))
						return FormatReturn(((object[])iteratee[currentIterateeIndex])[idx]);
					else
						throw new Exception(&quot;The index &quot; + idxStr + &quot; is not an integer&quot;);
				}
			}
			else if (contents == &quot;ELSEIF&quot;)
			{
				if (currentIterateeIndex == 0)
					return &quot;if&quot;;
				else
					return &quot;else if&quot;;
			}

			if (replaces.ContainsKey(contents))
				return FormatReturn(replaces[contents]);

			return string.Empty;
		}

		private string FormatReturn(object data)
		{
			if (data is bool)
				return data.ToString().ToLower();
			else if (data is float)
			{
				float fData = (float) data;
				return fData.ToString(CultureInfo.InvariantCulture) + &quot;f&quot;;
			}
			return data.ToString();
		}
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[29,3,29,48,0],[30,3,30,82,0],[37,3,37,36,0],[39,3,39,40,0],[40,3,40,30,0],[41,3,41,35,0],[43,3,43,37,0],[44,3,44,4,0],[45,4,45,26,0],[46,3,46,4,0],[49,3,49,4,0],[50,4,50,27,0],[51,3,51,4,0],[54,3,54,4,0],[55,4,55,92,0],[57,4,57,60,0],[59,4,59,19,0],[60,4,60,24,0],[61,4,61,26,0],[62,4,62,34,0],[64,9,64,18,0],[64,20,64,35,0],[64,37,64,40,0],[65,4,65,5,0],[66,5,66,20,0],[67,5,67,22,0],[68,5,68,38,0],[70,5,70,17,0],[71,5,71,6,0],[72,6,72,37,0],[73,6,73,53,0],[74,6,74,25,0],[75,7,75,13,0],[77,6,77,22,0],[78,6,78,64,0],[80,6,80,23,0],[81,7,81,84,0],[83,6,83,77,0],[85,6,85,59,0],[87,6,87,47,0],[88,6,88,7,0],[89,7,89,23,0],[92,7,92,36,0],[93,7,93,8,0],[94,8,94,28,0],[95,9,95,18,0],[97,8,97,54,0],[98,8,98,9,0],[99,9,99,52,0],[100,9,100,25,0],[101,9,101,24,0],[102,9,102,28,0],[103,8,103,9,0],[105,8,105,9,0],[106,9,106,27,0],[107,9,107,15,0],[109,7,109,8,0],[110,12,110,76,0],[111,8,111,26,0],[113,7,113,16,0],[116,6,116,22,0],[117,7,117,54,0],[119,6,119,20,0],[120,5,120,6,0],[122,5,122,34,0],[124,5,124,44,0],[125,6,125,26,0],[126,10,126,39,0],[127,6,127,28,0],[128,4,128,5,0],[130,4,130,66,0],[131,3,131,4,0],[134,3,134,4,0],[135,4,135,42,0],[136,4,136,5,0],[137,5,137,38,0],[138,6,138,78,0],[140,5,140,29,0],[141,5,141,17,0],[143,4,143,43,0],[144,4,144,5,0],[145,5,145,39,0],[146,6,146,78,0],[148,5,148,29,0],[149,5,149,17,0],[151,9,151,44,0],[152,4,152,5,0],[153,5,153,71,0],[154,6,154,117,0],[156,5,156,28,0],[158,5,158,72,0],[160,5,160,45,0],[161,6,161,93,0],[163,5,163,49,0],[165,5,165,30,0],[166,6,166,24,0],[168,5,168,30,0],[169,5,169,32,0],[170,5,170,17,0],[172,9,172,45,0],[173,4,173,5,0],[174,5,174,71,0],[175,6,175,117,0],[177,5,177,29,0],[179,5,179,73,0],[181,5,181,45,0],[182,6,182,93,0],[184,5,184,49,0],[186,5,186,69,0],[187,6,187,24,0],[189,5,189,30,0],[190,5,190,33,0],[191,5,191,17,0],[194,4,194,17,0],[195,3,195,4,0],[198,3,198,4,0],[199,4,199,59,0],[200,4,200,5,0],[201,5,201,47,0],[202,6,202,58,0],[203,10,203,54,0],[204,6,204,48,0],[206,5,206,6,0],[207,6,207,56,0],[208,6,208,19,0],[209,6,209,40,0],[210,7,210,76,0],[212,7,212,73,0],[215,9,215,34,0],[216,4,216,5,0],[217,5,217,35,0],[218,6,218,18,0],[220,6,220,23,0],[223,4,223,39,0],[224,5,224,45,0],[226,4,226,24,0],[227,3,227,4,0],[230,3,230,4,0],[231,4,231,21,0],[232,5,232,38,0],[233,9,233,27,0],[234,4,234,5,0],[235,5,235,32,0],[236,5,236,63,0],[238,4,238,27,0],[239,3,239,4,0]]);
    </script>
  </body>
</html>