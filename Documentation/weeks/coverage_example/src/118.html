<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>p:\stuff\projects\minigamesproject\minigamesproject\assets\_assets\scripts\bearded man studios\scripts\networking\forge\networking\tcpclientbase.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;

#if WINDOWS_UWP
using Windows.Networking.Sockets;
using Windows.Networking;
using System.IO;
#else
using System.Net.Sockets;
#endif

using BeardedManStudios.Forge.Networking.Frame;
using BeardedManStudios.Threading;

namespace BeardedManStudios.Forge.Networking
{
    // new TCPClientBase as of September 2018
    public abstract class TCPClientBase : BaseTCP, IClient
    {
#if WINDOWS_UWP
		private StreamSocket client
#else
        private TcpClient client;
#endif
        /// &lt;summary&gt;
        /// The hash that is / was validated by the server
        /// &lt;/summary&gt;
        private string headerHash;

        /// &lt;summary&gt;
        /// Used to determine if the client has requested to be accepted by the server
        /// &lt;/summary&gt;
        private bool headerExchanged = false;

		/// &lt;summary&gt;
		/// Whether we are disconnected or not
		/// &lt;/summary&gt;
		//private bool disconnectedSelf = false;

		[Obsolete(&quot;This event is obsolete. Use connectAttemptFailed instead.&quot;)]
	    public event BaseNetworkEvent ConnectAttemptFailed;
	    public event BaseNetworkEvent connectAttemptFailed;
        byte[] buffer = new byte[8192];

        /// &lt;summary&gt;
		/// The identity of the server as a networking player
		/// &lt;/summary&gt;
        protected NetworkingPlayer server = null;
        public NetworkingPlayer Server { get { return server; } }

        public virtual void Connect(string host, ushort port = DEFAULT_PORT)
        {
            if (Disposed)
                throw new ObjectDisposedException(&quot;TCPClient&quot;, &quot;This object has been disposed and can not be used to connect, please use a new TCPClient&quot;);
            try
            {
                client = new TcpClient(host, port); // constructor runs connect
            }
            catch
            {
#pragma warning disable 0618
                if (ConnectAttemptFailed != null)
				{
                    ConnectAttemptFailed(this);
                }
#pragma warning restore 0618

				if (connectAttemptFailed != null)
                {
                    connectAttemptFailed(this);
                }
                return;
            }
            // If we got this far then the bind was successful
            OnBindSuccessful();
            Initialize(host, port);
        }
        protected virtual void Initialize(string host, ushort port, bool pendCreates = true)
        {

            // By default pending creates should be true and flushed when ready
            if(pendCreates)
                PendCreates = true;

            // Get a random hash key that needs to be used for validating that the server was connected to
            headerHash = Websockets.HeaderHashKey();

            // This is a typical Websockets accept header to be validated
            byte[] connectionHeader = Websockets.ConnectionHeader(headerHash, port);

            // Register the server as a NetworkingPlayer
            server = new NetworkingPlayer(0, host, true, client, this);
            // Send the upgrade request to the server
            RawWrite(connectionHeader);

            //Let myself know I connected successfully
            OnPlayerConnected(server);
            // Set myself as a connected client
            server.Connected = true;

            ReceiveToken token = new ReceiveToken
            {
                internalBuffer = new ArraySegment&lt;byte&gt;(buffer, 0, buffer.Length),
                player = server,
                bytesReceived = 0,
                dataHolder = null,
                maxAllowedBytes = 8192
            };

            // Read from the server async
            SocketAsyncEventArgs e = new SocketAsyncEventArgs();
            e.Completed += new EventHandler&lt;SocketAsyncEventArgs&gt;(ReceiveAsync_Completed);
            e.UserToken = token;
            e.SetBuffer(token.internalBuffer.Array, token.internalBuffer.Offset, token.internalBuffer.Count);

            if (!client.Client.ReceiveAsync(e))
                Task.Queue(() =&gt; ReceiveAsync_Completed(this, e));
        }

        private void DoRead(SocketAsyncEventArgs e)
        {
            if (!client.Connected)
            {
                Disconnect(true);
                return;
            }
            if (!IsBound)
                return;
            if (!client.Client.ReceiveAsync(e))
                ReceiveAsync_Completed(this, e);
        }

        // Should validate the handshake response from the server
        private void ReceiveAsync_Completed(object sender, SocketAsyncEventArgs e)
        {
            if (e.BytesTransferred &gt; 0 &amp;&amp; e.SocketError == SocketError.Success)
            {
                int bytesAlreadyProcessed = 0; // Count of the total freshly transferred bytes processed so far
                ReceiveToken token = (ReceiveToken)e.UserToken;
                if (!headerExchanged)
                {
                    byte[] header = HandleHttpHeader(e, ref bytesAlreadyProcessed);
                    token = (ReceiveToken)e.UserToken;
                    if (header == null)
                    {
                        DoRead(e);
                        return;
                    }
                    else if (Websockets.ValidateResponseHeader(headerHash, header))
                    {
                        headerExchanged = true;
                        token.maxAllowedBytes = int.MaxValue;
                        e.UserToken = token;

                        // Ping the server to finalize the player&#39;s connection
                        Send(Text.CreateFromString(Time.Timestep, InstanceGuid.ToString(), true, Receivers.Server, MessageGroupIds.NETWORK_ID_REQUEST, true));
                    }
                    else
                    {
                        // Improper header, so a disconnect is required
                        Disconnect(true);
                        return;
                    }
                }

                while (bytesAlreadyProcessed &lt; e.BytesTransferred)
                {
                    byte[] data = HandleData(e, true, ref bytesAlreadyProcessed);
                    if (data == null)
                    {
                        break;
                    }
                    FrameStream frame = Factory.DecodeMessage(data, false, MessageGroupIds.TCP_FIND_GROUP_ID, Server);

                    FireRead(frame, Server);

                }
                DoRead(e);
            }
            else
            {
                Disconnect(true);
            }
        }
        private void RawWrite(byte[] data)
        {
#if WINDOWS_UWP
			//Write data to the echo server.
			Stream streamOut = client.OutputStream.AsStreamForWrite();
			StreamWriter writer = new StreamWriter(streamOut);
			writer.Write(data);
			writer.Flush();
#else
            client.GetStream().Write(data, 0, data.Length);
#endif
        }

        /// &lt;summary&gt;
        /// The direct byte send method to the specified client
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;client&quot;&gt;The target client that will receive the frame&lt;/param&gt;
        /// &lt;param name=&quot;frame&quot;&gt;The frame that is to be sent to the specified client&lt;/param&gt;
        public virtual void Send(FrameStream frame)
        {
            // Make sure that we don&#39;t have any race conditions with writing to the same client
            lock (client)
            {
                // Get the raw bytes from the frame and send them
                byte[] data = frame.GetData();
                RawWrite(data);
            }
        }

        /// &lt;summary&gt;
        /// Sends binary message to the specific receiver(s)
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;receivers&quot;&gt;The clients / server to receive the message&lt;/param&gt;
        /// &lt;param name=&quot;messageGroupId&quot;&gt;The Binary.GroupId of the massage, use MessageGroupIds.START_OF_GENERIC_IDS + desired_id&lt;/param&gt;
        /// &lt;param name=&quot;objectsToSend&quot;&gt;Array of vars to be sent, read them with Binary.StreamData.GetBasicType&lt;typeOfObject&gt;()&lt;/param&gt;
        public virtual void Send(Receivers receivers, int messageGroupId, params object[] objectsToSend)
        {
            BMSByte data = ObjectMapper.BMSByte(objectsToSend);
            Binary sendFrame = new Binary(Time.Timestep, true, data, receivers, messageGroupId, true);
            Send(sendFrame);
        }

        /// &lt;summary&gt;
        /// Disconnect this client from the server
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;forced&quot;&gt;Used to tell if this disconnect was intentional &lt;c&gt;false&lt;/c&gt; or caused by an exception &lt;c&gt;true&lt;/c&gt;&lt;/param&gt;
        public override void Disconnect(bool forced)
        {
            if (client != null)
            {
                lock (client)
                {
                    //disconnectedSelf = true;

                    // Close our TcpClient so that it can no longer be used
                    if (forced)
                        client.Close();
                    else if (client.Connected)
                        Send(new ConnectionClose(Time.Timestep, true, Receivers.Server, MessageGroupIds.DISCONNECT, true));

                    // Send signals to the methods registered to the disconnec events
                    if (!forced)
                        OnDisconnected();
                    else
                        OnForcedDisconnect();

                    for (int i = 0; i &lt; Players.Count; ++i)
                        OnPlayerDisconnected(Players[i]);
                }
            }
        }

        public override void FireRead(FrameStream frame, NetworkingPlayer currentPlayer)
        {
            if (frame.GroupId == MessageGroupIds.AUTHENTICATION_CHALLENGE)
            {
                if ((Me != null &amp;&amp; Me.Connected) || authenticator == null)
                    return;

                authenticator.AcceptChallenge(this, frame.StreamData, AuthServer, RejectServer);
                return;
            }

            if (frame.GroupId == MessageGroupIds.AUTHENTICATION_FAILURE)
            {
                Logging.BMSLog.LogWarning(&quot;The server rejected the authentication attempt&quot;);
                // Wait for the second message (Disconnect)
                return;
            }

            // A message has been successfully read from the network so relay that
            // to all methods registered to the event
            OnMessageReceived(currentPlayer, frame);
        }

        /// &lt;summary&gt;
        /// Request the ping from the server (pingReceived will be triggered if it receives it)
        /// &lt;/summary&gt;
        public override void Ping()
        {
            Send(GeneratePing());
        }

        /// &lt;summary&gt;
        /// A ping was receieved from the server so we need to respond with the pong
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;playerRequesting&quot;&gt;The server&lt;/param&gt;
        /// &lt;param name=&quot;time&quot;&gt;The time that the ping was received for&lt;/param&gt;
        protected override void Pong(NetworkingPlayer playerRequesting, DateTime time)
        {
            Send(GeneratePong(time));
        }

        /// &lt;summary&gt;
        /// Callback for user auth. Sends an authentication response to the server.
        /// &lt;/summary&gt;
        private void AuthServer(BMSByte buffer)
        {
            Send(new Binary(Time.Timestep, true, buffer, Receivers.Server, MessageGroupIds.AUTHENTICATION_RESPONSE, true));
        }

        /// &lt;summary&gt;
        /// Callback for user auth. Disconnects the user from an invalid server.
        /// &lt;/summary&gt;
        private void RejectServer()
        {
            Disconnect(true);
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[32,9,32,46,0],[42,9,42,40,0],[47,9,47,50,0],[48,46,48,47,0],[48,48,48,62,0],[48,63,48,64,0],[51,9,51,10,0],[52,13,52,26,0],[53,17,53,156,0],[55,13,55,14,0],[56,17,56,52,0],[57,13,57,14,0],[58,13,58,18,0],[59,13,59,14,0],[61,17,61,50,0],[62,5,62,6,0],[63,21,63,48,0],[64,17,64,18,0],[67,5,67,38,0],[68,17,68,18,0],[69,21,69,48,0],[70,17,70,18,0],[71,17,71,24,0],[74,13,74,32,0],[75,13,75,36,0],[76,9,76,10,0],[78,9,78,10,0],[81,13,81,28,0],[82,17,82,36,0],[85,13,85,53,0],[88,13,88,85,0],[91,13,91,72,0],[93,13,93,40,0],[96,13,96,39,0],[98,13,98,37,0],[100,13,107,15,0],[110,13,110,65,0],[111,13,111,91,0],[112,13,112,33,0],[113,13,113,110,0],[115,13,115,48,0],[116,17,116,34,0],[116,34,116,65,0],[116,65,116,67,0],[116,17,116,67,0],[117,9,117,10,0],[120,9,120,10,0],[121,13,121,35,0],[122,13,122,14,0],[123,17,123,34,0],[124,17,124,24,0],[126,13,126,26,0],[127,17,127,24,0],[128,13,128,48,0],[129,17,129,49,0],[130,9,130,10,0],[134,9,134,10,0],[135,13,135,80,0],[136,13,136,14,0],[137,17,137,47,0],[138,17,138,64,0],[139,17,139,38,0],[140,17,140,18,0],[141,21,141,84,0],[142,21,142,55,0],[143,21,143,40,0],[144,21,144,22,0],[145,25,145,35,0],[146,25,146,32,0],[148,26,148,84,0],[149,21,149,22,0],[150,25,150,48,0],[151,25,151,62,0],[152,25,152,45,0],[155,25,155,159,0],[156,21,156,22,0],[158,21,158,22,0],[160,25,160,42,0],[161,25,161,32,0],[163,17,163,18,0],[165,17,165,67,0],[166,17,166,18,0],[167,21,167,82,0],[168,21,168,38,0],[169,21,169,22,0],[170,25,170,31,0],[172,21,172,119,0],[174,21,174,45,0],[176,17,176,18,0],[177,17,177,27,0],[178,13,178,14,0],[180,13,180,14,0],[181,17,181,34,0],[182,13,182,14,0],[183,9,183,10,0],[185,9,185,10,0],[193,13,193,60,0],[195,9,195,10,0],[203,9,203,10,0],[205,13,205,26,0],[206,13,206,14,0],[208,17,208,47,0],[209,17,209,32,0],[210,13,210,14,0],[211,9,211,10,0],[220,9,220,10,0],[221,13,221,64,0],[222,13,222,103,0],[223,13,223,29,0],[224,9,224,10,0],[231,9,231,10,0],[232,13,232,32,0],[233,13,233,14,0],[234,17,234,30,0],[235,17,235,18,0],[239,21,239,32,0],[240,25,240,40,0],[241,26,241,47,0],[242,25,242,124,0],[245,21,245,33,0],[246,25,246,42,0],[248,25,248,46,0],[250,26,250,35,0],[250,37,250,54,0],[250,56,250,59,0],[251,25,251,58,0],[252,17,252,18,0],[253,13,253,14,0],[254,9,254,10,0],[257,9,257,10,0],[258,13,258,75,0],[259,13,259,14,0],[260,17,260,75,0],[261,21,261,28,0],[263,17,263,97,0],[264,17,264,24,0],[267,13,267,73,0],[268,13,268,14,0],[269,17,269,93,0],[271,17,271,24,0],[276,13,276,53,0],[277,9,277,10,0],[283,9,283,10,0],[284,13,284,34,0],[285,9,285,10,0],[293,9,293,10,0],[294,13,294,38,0],[295,9,295,10,0],[301,9,301,10,0],[302,13,302,124,0],[303,9,303,10,0],[309,9,309,10,0],[310,13,310,30,0],[311,9,311,10,0]]);
    </script>
  </body>
</html>