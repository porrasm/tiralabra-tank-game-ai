<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>p:\stuff\projects\minigamesproject\minigamesproject\assets\bearded man studios inc\editor\forgeclassobject.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
//#define FORGE_EDITOR_DEBUGGING

using BeardedManStudios.Forge.Networking.Generated;
using SimpleJSONEditor;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.Serialization;
using UnityEngine;
using BeardedManStudios.Forge.Networking.UnityEditor.Serializer;

namespace BeardedManStudios.Forge.Networking.UnityEditor
{
	/// &lt;summary&gt;
	/// This is the forge class object we generate from a file
	/// &lt;/summary&gt;
	[Serializable]
	public class ForgeClassObject
	{
		public string FileLocation;
		public string Filename;
		public string ExactFilename;

		public int IdentityValue = -1;

		[NonSerialized]
		public static int IDENTITIES = 0;

		public bool IsNetworkBehavior { get { return ExactFilename.EndsWith(&quot;Behavior&quot;); } }
		public bool IsNetworkObject { get { return ExactFilename.EndsWith(&quot;NetworkObject&quot;); } }

		public string StrippedSearchName
		{
			get
			{
				return IsNetworkBehavior ? ExactFilename.Substring(0, ExactFilename.IndexOf(&quot;Behavior&quot;)) :
					IsNetworkObject ? ExactFilename.Substring(0, ExactFilename.IndexOf(&quot;NetworkObject&quot;)) :
					ExactFilename;
			}
		}

		public ForgeBaseClassType ObjectClassType;
		public List&lt;ForgeClassFieldValue&gt; Fields = new List&lt;ForgeClassFieldValue&gt;();
		public List&lt;ForgeClassRPCValue&gt; RPCS = new List&lt;ForgeClassRPCValue&gt;();
		public List&lt;ForgeClassRewindValue&gt; Rewinds = new List&lt;ForgeClassRewindValue&gt;();

		public ForgeClassObject(string location)
		{
			this.FileLocation = location;
			this.Filename = Path.GetFileName(FileLocation);
			this.ExactFilename = Path.GetFileNameWithoutExtension(FileLocation);

			if (ExactFilename == &quot;NetworkManager&quot;)
				return;

			List&lt;float&gt; _interpolationValues = new List&lt;float&gt;();
			JSONNode typeData = null;
			JSONNode typeHelperData = null;
			JSONNode interpolData = null;
			Type currentType = GetType(&quot;BeardedManStudios.Forge.Networking.Generated.&quot; + this.ExactFilename);
			GeneratedRPCAttribute aRPC = (GeneratedRPCAttribute)Attribute.GetCustomAttribute(currentType, typeof(GeneratedRPCAttribute));
			GeneratedRPCVariableNamesAttribute aNames = (GeneratedRPCVariableNamesAttribute)Attribute.GetCustomAttribute(currentType, typeof(GeneratedRPCVariableNamesAttribute));
			GeneratedInterpolAttribute aInterpol = (GeneratedInterpolAttribute)Attribute.GetCustomAttribute(currentType, typeof(GeneratedInterpolAttribute));

			if (aRPC != null &amp;&amp; !string.IsNullOrEmpty(aRPC.JsonData))
				typeData = JSON.Parse(aRPC.JsonData);
			else
				typeData = new JSONClass();

			if (aNames != null &amp;&amp; !string.IsNullOrEmpty(aNames.JsonData))
				typeHelperData = JSON.Parse(aNames.JsonData);
			else
				typeHelperData = new JSONClass();

			if (aInterpol != null &amp;&amp; !string.IsNullOrEmpty(aInterpol.JsonData))
				interpolData = JSON.Parse(aInterpol.JsonData);
			else
				interpolData = new JSONClass();

#if FORGE_EDITOR_DEBUGGING
			string forgeClassDebug = &quot;Loaded - &quot; + this.ExactFilename + System.Environment.NewLine;
#endif

			List&lt;MethodInfo&gt; uniqueMethods = new List&lt;MethodInfo&gt;();
			List&lt;PropertyInfo&gt; uniqueProperties = new List&lt;PropertyInfo&gt;();
			List&lt;FieldInfo&gt; uniqueFields = new List&lt;FieldInfo&gt;();

			if (currentType == null)
				throw new NullReferenceException(&quot;CANNOT PUT SOURCE CODE IN GENERATED FOLDER! PLEASE REMOVE NON GENERATED CODE!&quot;);

			MethodInfo[] methods = currentType.GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.FlattenHierarchy)
				.Where(m =&gt; m.GetParameters().Length == 1 &amp;&amp; m.GetParameters()[0].ParameterType.FullName == &quot;BeardedManStudios.Forge.Networking.RpcArgs&quot;).ToArray();
			PropertyInfo[] properties = currentType.GetProperties(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.FlattenHierarchy);
			FieldInfo[] fields = currentType.GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.FlattenHierarchy)
				.Where(attr =&gt; attr.IsDefined(typeof(ForgeGeneratedFieldAttribute), false)).ToArray();

			uniqueMethods.AddRange(methods);
			uniqueProperties.AddRange(properties);
			uniqueFields.AddRange(fields);

			//If we don&#39;t find any fields containing the attribute, the class is either empty, or using the old format. Try parsing old format
			if (fields.Length == 0)
			{
				FieldInfo[] legacyFields = currentType.GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.FlattenHierarchy);
				uniqueFields.AddRange(legacyFields);

				for (int i = 0; i &lt; uniqueFields.Count; ++i)
				{
					switch (uniqueFields[i].Name)
					{
						case &quot;IDENTITY&quot;:
						case &quot;networkObject&quot;:
						case &quot;fieldAltered&quot;:
						case &quot;_dirtyFields&quot;:
						case &quot;dirtyFields&quot;:
							uniqueFields.RemoveAt(i--);
							//TODO: Store the types for re-use
							continue;
					}

					if (uniqueFields[i].Name.EndsWith(&quot;Changed&quot;))
					{
						uniqueFields.RemoveAt(i--);
						continue;
					}

					if (uniqueFields[i].Name.EndsWith(&quot;Interpolation&quot;))
					{
						uniqueFields.RemoveAt(i--);

						//TODO: Store the types for re-use
						continue;
					}
				}
			}

			if (currentType.BaseType != null)
			{
				Type baseType = currentType.BaseType;
				Type networkBehavior = currentType.GetInterface(&quot;INetworkBehavior&quot;);
				Type factoryInterface = currentType.GetInterface(&quot;INetworkObjectFactory&quot;);
				bool isMonobehavior = currentType.IsSubclassOf(typeof(MonoBehaviour));

				if (baseType.FullName == &quot;BeardedManStudios.Forge.Networking.NetworkObject&quot;)
				{
					ObjectClassType = ForgeBaseClassType.NetworkObject;
					IdentityValue = ++IDENTITIES;
				}
				else if (networkBehavior != null &amp;&amp; !isMonobehavior)
					ObjectClassType = ForgeBaseClassType.NetworkBehavior;
				else if (baseType == typeof(MonoBehaviour) || isMonobehavior)
					ObjectClassType = ForgeBaseClassType.MonoBehavior;
				else if (factoryInterface != null)
					ObjectClassType = ForgeBaseClassType.ObjectFactory;
				else if (baseType == typeof(Enum))
					ObjectClassType = ForgeBaseClassType.Enums;
				else
					ObjectClassType = ForgeBaseClassType.Custom;

				MethodInfo[] baseMethods = baseType.GetMethods(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.FlattenHierarchy);
				PropertyInfo[] baseProperties = baseType.GetProperties(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.FlattenHierarchy);
				FieldInfo[] baseFields = baseType.GetFields(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.FlattenHierarchy);

				for (int i = 0; i &lt; baseMethods.Length; ++i)
				{
					for (int x = 0; x &lt; uniqueMethods.Count; ++x)
					{
						if (uniqueMethods[x].Name == baseMethods[i].Name
						&amp;&amp; uniqueMethods[x].GetParameters().Length == baseMethods[i].GetParameters().Length)
						{
							var argsA = uniqueMethods[x].GetParameters();
							var argsB = baseMethods[i].GetParameters();
							bool same = true;

							for (int j = 0; j &lt; argsA.Length; j++)
							{
								if (!argsA[j].Equals(argsB[j]))
								{
									same = false;
									break;
								}
							}

							if (same)
								uniqueMethods.RemoveAt(x);

							break;
						}
					}
				}

				for (int i = 0; i &lt; baseProperties.Length; ++i)
				{
					for (int x = 0; x &lt; uniqueProperties.Count; ++x)
					{
						if (uniqueProperties[x].Name == baseProperties[i].Name)
						{
							uniqueProperties.RemoveAt(x);
							break;
						}
					}
				}

				for (int i = 0; i &lt; baseFields.Length; ++i)
				{
					for (int x = 0; x &lt; uniqueFields.Count; ++x)
					{
						if (uniqueFields[x].Name == baseFields[i].Name)
						{
							uniqueFields.RemoveAt(x);
							break;
						}
					}
				}
			}

#if FORGE_EDITOR_DEBUGGING
			forgeClassDebug += &quot;Properties:\n&quot;;
			foreach (PropertyInfo a in uniqueProperties)
			{
				forgeClassDebug += a.Name + &quot; (&quot; + a.PropertyType + &quot;)&quot; + System.Environment.NewLine;
			}
			forgeClassDebug += System.Environment.NewLine;

			forgeClassDebug += &quot;Fields:\n&quot;;
#endif
			if (ObjectClassType != ForgeBaseClassType.Enums)
			{
				if (interpolData != null)
				{
					JSONArray currentInterpolationVariables = interpolData[&quot;inter&quot;].AsArray;
					if (currentInterpolationVariables != null)
					{
						for (int i = 0; i &lt; currentInterpolationVariables.Count; ++i)
						{
							float interPolVal = currentInterpolationVariables[i].AsFloat;
							_interpolationValues.Add(interPolVal);
						}
					}
				}
				else
				{
					for (int i = 0; i &lt; uniqueFields.Count; ++i)
						_interpolationValues.Add(ForgeNetworkingEditor.DEFAULT_INTERPOLATE_TIME);
				}

				for (int i = 0; i &lt; uniqueFields.Count; ++i)
				{
					if (_interpolationValues.Count == 0)
						break;

					ForgeClassFieldValue val = ForgeClassFieldValue.GetClassField(uniqueFields[i], currentType, _interpolationValues[i] &gt; 0, _interpolationValues[i]);
					Fields.Add(val);
#if FORGE_EDITOR_DEBUGGING
					Debug.Log(val);
					forgeClassDebug += uniqueFields[i].Name + &quot; (&quot; + uniqueFields[i].FieldType + &quot;)&quot; + System.Environment.NewLine;
#endif
				}
			}
#if FORGE_EDITOR_DEBUGGING
			forgeClassDebug += System.Environment.NewLine;

			forgeClassDebug += &quot;Methods:\n&quot;;
#endif
			List&lt;List&lt;ForgeAcceptableRPCTypes&gt;&gt; rpcSupportedTypes = new List&lt;List&lt;ForgeAcceptableRPCTypes&gt;&gt;();
			if (typeData != null)
			{
				JSONArray currentRPCVariables = typeData[&quot;types&quot;].AsArray;
				if (currentRPCVariables != null)
				{
					for (int i = 0; i &lt; currentRPCVariables.Count; ++i)
					{
						JSONArray singularArray = currentRPCVariables[i].AsArray;
						if (singularArray != null)
						{
							List&lt;ForgeAcceptableRPCTypes&gt; singularSupportedTypes = new List&lt;ForgeAcceptableRPCTypes&gt;();
							for (int x = 0; x &lt; singularArray.Count; ++x)
							{
								ForgeAcceptableRPCTypes singularType = ForgeClassFieldRPCValue.GetTypeFromAcceptable(singularArray[x].Value);
								singularSupportedTypes.Add(singularType);
							}
							rpcSupportedTypes.Add(singularSupportedTypes);
						}
					}
				}
			}
			else
			{
				for (int i = 0; i &lt; uniqueMethods.Count; ++i)
					rpcSupportedTypes.Add(new List&lt;ForgeAcceptableRPCTypes&gt;());
			}

			List&lt;List&lt;string&gt;&gt; typeHelpers = new List&lt;List&lt;string&gt;&gt;();
			if (typeHelperData != null)
			{
				JSONArray currentHelperRPCTypes = typeHelperData[&quot;types&quot;].AsArray;
				if (currentHelperRPCTypes != null)
				{
					for (int i = 0; i &lt; currentHelperRPCTypes.Count; ++i)
					{
						JSONArray singularHelperArray = currentHelperRPCTypes[i].AsArray;
						if (singularHelperArray != null)
						{
							List&lt;string&gt; singularSupportedTypes = new List&lt;string&gt;(new string[Mathf.Max(singularHelperArray.Count, rpcSupportedTypes.Count)]);
							for (int x = 0; x &lt; singularHelperArray.Count; ++x)
							{
								string singularHelperType = singularHelperArray[x].Value.Replace(&quot; &quot;, string.Empty);
								singularSupportedTypes[x] = singularHelperType;
							}
							typeHelpers.Add(singularSupportedTypes);
						}
					}
				}
			}
			else
			{
				//This is missing the type helper data
				for (int i = 0; i &lt; rpcSupportedTypes.Count; ++i)
				{
					typeHelpers.Add(new List&lt;string&gt;(new string[rpcSupportedTypes[i].Count]));
				}
			}

			for (int i = 0; i &lt; uniqueMethods.Count; ++i)
			{
				RPCS.Add(new ForgeClassRPCValue(uniqueMethods[i], rpcSupportedTypes[i], typeHelpers[i]));
#if FORGE_EDITOR_DEBUGGING
				ParameterInfo[] paramsInfo = a.GetParameters();
				string parameters = &quot;&quot;;
				foreach (ParameterInfo info in paramsInfo)
					parameters += info.ParameterType + &quot;, &quot;;

				forgeClassDebug += a.Name + &quot; (&quot; + parameters + &quot;)&quot; + System.Environment.NewLine;
#endif
			}

#if FORGE_EDITOR_DEBUGGING
			forgeClassDebug += &quot;Class Type: &quot; + ObjectClassType;
			forgeClassDebug += &quot;\nSearchName: &quot; + StrippedSearchName;
			forgeClassDebug += &quot;\nIsNetworkedObject: &quot; + IsNetworkObject;
			forgeClassDebug += &quot;\nIsNetworkBehavior: &quot; + IsNetworkBehavior;
			forgeClassDebug += System.Environment.NewLine;

			Debug.Log(forgeClassDebug);
#endif
		}

		public static bool HasFilename(List&lt;ForgeClassObject&gt; collection, string filename)
		{
			bool returnValue = false;

			foreach (ForgeClassObject fo in collection)
			{
				if (fo.Filename.ToLower() == filename.ToLower())
				{
					returnValue = true;
					break;
				}
			}

			return returnValue;
		}

		public static bool HasExactFilename(List&lt;ForgeClassObject&gt; collection, string filename)
		{
			bool returnValue = false;
			
			foreach (ForgeClassObject fo in collection)
			{
				if (fo.ExactFilename.ToLower() == filename.ToLower())
				{
					returnValue = true;
					break;
				}
			}
			
			return returnValue;
		}

		public static ForgeClassObject GetClassObjectFromFilename(List&lt;ForgeClassObject&gt; collection, string filename)
		{
			ForgeClassObject returnValue = null;

			foreach (ForgeClassObject fo in collection)
			{
				if (fo.Filename.ToLower() == filename.ToLower())
				{
					returnValue = fo;
					break;
				}
			}

			return returnValue;
		}

		public static ForgeClassObject GetClassObjectFromExactFilename(List&lt;ForgeClassObject&gt; collection, string filename)
		{
			ForgeClassObject returnValue = null;

			foreach (ForgeClassObject fo in collection)
			{
				if (fo.ExactFilename.ToLower() == filename.ToLower())
				{
					returnValue = fo;
					break;
				}
			}

			return returnValue;
		}

		public static Type GetType(string typeName)
		{
			var type = Type.GetType(typeName);
			if (type != null) return type;
			foreach (var a in AppDomain.CurrentDomain.GetAssemblies())
			{
				type = a.GetType(typeName);
				if (type != null)
					return type;
			}
			return null;
		}
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[26,3,26,33,0],[29,3,29,36,0],[31,39,31,40,0],[31,41,31,83,0],[31,84,31,85,0],[32,37,32,38,0],[32,39,32,86,0],[32,87,32,88,0],[37,4,37,5,0],[38,5,40,20,0],[41,4,41,5,0],[45,3,45,79,0],[46,3,46,73,0],[47,3,47,82,0],[49,3,49,43,0],[50,3,50,4,0],[51,4,51,33,0],[52,4,52,51,0],[53,4,53,72,0],[55,4,55,42,0],[56,5,56,12,0],[58,4,58,57,0],[59,4,59,29,0],[60,4,60,35,0],[61,4,61,33,0],[62,4,62,101,0],[63,4,63,129,0],[64,4,64,170,0],[65,4,65,149,0],[67,4,67,61,0],[68,5,68,42,0],[70,5,70,32,0],[72,4,72,65,0],[73,5,73,50,0],[75,5,75,38,0],[77,4,77,71,0],[78,5,78,51,0],[80,5,80,36,0],[86,4,86,60,0],[87,4,87,67,0],[88,4,88,57,0],[90,4,90,28,0],[91,5,91,119,0],[93,4,94,17,0],[94,17,94,141,0],[94,141,94,153,0],[93,4,94,153,0],[95,4,95,160,0],[96,4,97,20,0],[97,20,97,79,0],[97,79,97,91,0],[96,4,97,91,0],[99,4,99,36,0],[100,4,100,42,0],[101,4,101,34,0],[104,4,104,27,0],[105,4,105,5,0],[106,5,106,156,0],[107,5,107,41,0],[109,10,109,19,0],[109,21,109,43,0],[109,45,109,48,0],[110,5,110,6,0],[111,6,111,35,0],[118,8,118,35,0],[120,8,120,17,0],[123,6,123,51,0],[124,6,124,7,0],[125,7,125,34,0],[126,7,126,16,0],[129,6,129,57,0],[130,6,130,7,0],[131,7,131,34,0],[134,7,134,16,0],[136,5,136,6,0],[137,4,137,5,0],[139,4,139,37,0],[140,4,140,5,0],[141,5,141,42,0],[142,5,142,73,0],[143,5,143,79,0],[144,5,144,75,0],[146,5,146,81,0],[147,5,147,6,0],[148,6,148,57,0],[149,6,149,35,0],[150,5,150,6,0],[151,10,151,57,0],[152,6,152,59,0],[153,10,153,66,0],[154,6,154,56,0],[155,10,155,39,0],[156,6,156,57,0],[157,10,157,39,0],[158,6,158,49,0],[160,6,160,50,0],[162,5,162,154,0],[163,5,163,162,0],[164,5,164,151,0],[166,10,166,19,0],[166,21,166,43,0],[166,45,166,48,0],[167,5,167,6,0],[168,11,168,20,0],[168,22,168,45,0],[168,47,168,50,0],[169,6,169,7,0],[170,7,171,91,0],[172,7,172,8,0],[173,8,173,53,0],[174,8,174,51,0],[175,8,175,25,0],[177,13,177,22,0],[177,24,177,40,0],[177,42,177,45,0],[178,8,178,9,0],[179,9,179,40,0],[180,9,180,10,0],[181,10,181,23,0],[182,10,182,16,0],[184,8,184,9,0],[186,8,186,17,0],[187,9,187,35,0],[189,8,189,14,0],[191,6,191,7,0],[192,5,192,6,0],[194,10,194,19,0],[194,21,194,46,0],[194,48,194,51,0],[195,5,195,6,0],[196,11,196,20,0],[196,22,196,48,0],[196,50,196,53,0],[197,6,197,7,0],[198,7,198,62,0],[199,7,199,8,0],[200,8,200,37,0],[201,8,201,14,0],[203,6,203,7,0],[204,5,204,6,0],[206,10,206,19,0],[206,21,206,42,0],[206,44,206,47,0],[207,5,207,6,0],[208,11,208,20,0],[208,22,208,44,0],[208,46,208,49,0],[209,6,209,7,0],[210,7,210,54,0],[211,7,211,8,0],[212,8,212,33,0],[213,8,213,14,0],[215,6,215,7,0],[216,5,216,6,0],[217,4,217,5,0],[229,4,229,52,0],[230,4,230,5,0],[231,5,231,30,0],[232,5,232,6,0],[233,6,233,78,0],[234,6,234,48,0],[235,6,235,7,0],[236,12,236,21,0],[236,23,236,62,0],[236,64,236,67,0],[237,7,237,8,0],[238,8,238,69,0],[239,8,239,46,0],[240,7,240,8,0],[241,6,241,7,0],[242,5,242,6,0],[244,5,244,6,0],[245,11,245,20,0],[245,22,245,44,0],[245,46,245,49,0],[246,7,246,80,0],[247,5,247,6,0],[249,10,249,19,0],[249,21,249,43,0],[249,45,249,48,0],[250,5,250,6,0],[251,6,251,42,0],[252,7,252,13,0],[254,6,254,152,0],[255,6,255,22,0],[260,5,260,6,0],[261,4,261,5,0],[267,4,267,102,0],[268,4,268,25,0],[269,4,269,5,0],[270,5,270,63,0],[271,5,271,37,0],[272,5,272,6,0],[273,11,273,20,0],[273,22,273,51,0],[273,53,273,56,0],[274,6,274,7,0],[275,7,275,64,0],[276,7,276,33,0],[277,7,277,8,0],[278,8,278,99,0],[279,13,279,22,0],[279,24,279,47,0],[279,49,279,52,0],[280,8,280,9,0],[281,9,281,118,0],[282,9,282,50,0],[283,8,283,9,0],[284,8,284,54,0],[285,7,285,8,0],[286,6,286,7,0],[287,5,287,6,0],[288,4,288,5,0],[290,4,290,5,0],[291,10,291,19,0],[291,21,291,44,0],[291,46,291,49,0],[292,6,292,65,0],[293,4,293,5,0],[295,4,295,62,0],[296,4,296,31,0],[297,4,297,5,0],[298,5,298,71,0],[299,5,299,39,0],[300,5,300,6,0],[301,11,301,20,0],[301,22,301,53,0],[301,55,301,58,0],[302,6,302,7,0],[303,7,303,72,0],[304,7,304,39,0],[305,7,305,8,0],[306,8,306,138,0],[307,13,307,22,0],[307,24,307,53,0],[307,55,307,58,0],[308,8,308,9,0],[309,9,309,93,0],[310,9,310,56,0],[311,8,311,9,0],[312,8,312,48,0],[313,7,313,8,0],[314,6,314,7,0],[315,5,315,6,0],[316,4,316,5,0],[318,4,318,5,0],[320,10,320,19,0],[320,21,320,48,0],[320,50,320,53,0],[321,5,321,6,0],[322,6,322,80,0],[323,5,323,6,0],[324,4,324,5,0],[326,9,326,18,0],[326,20,326,43,0],[326,45,326,48,0],[327,4,327,5,0],[328,5,328,94,0],[337,4,337,5,0],[348,3,348,4,0],[351,3,351,4,0],[352,4,352,29,0],[354,4,354,11,0],[354,13,354,32,0],[354,33,354,35,0],[354,36,354,46,0],[355,4,355,5,0],[356,5,356,53,0],[357,5,357,6,0],[358,6,358,25,0],[359,6,359,12,0],[361,4,361,5,0],[363,4,363,23,0],[364,3,364,4,0],[367,3,367,4,0],[368,4,368,29,0],[370,4,370,11,0],[370,13,370,32,0],[370,33,370,35,0],[370,36,370,46,0],[371,4,371,5,0],[372,5,372,58,0],[373,5,373,6,0],[374,6,374,25,0],[375,6,375,12,0],[377,4,377,5,0],[379,4,379,23,0],[380,3,380,4,0],[383,3,383,4,0],[384,4,384,40,0],[386,4,386,11,0],[386,13,386,32,0],[386,33,386,35,0],[386,36,386,46,0],[387,4,387,5,0],[388,5,388,53,0],[389,5,389,6,0],[390,6,390,23,0],[391,6,391,12,0],[393,4,393,5,0],[395,4,395,23,0],[396,3,396,4,0],[399,3,399,4,0],[400,4,400,40,0],[402,4,402,11,0],[402,13,402,32,0],[402,33,402,35,0],[402,36,402,46,0],[403,4,403,5,0],[404,5,404,58,0],[405,5,405,6,0],[406,6,406,23,0],[407,6,407,12,0],[409,4,409,5,0],[411,4,411,23,0],[412,3,412,4,0],[415,3,415,4,0],[416,4,416,38,0],[417,4,417,21,0],[417,22,417,34,0],[418,4,418,11,0],[418,13,418,18,0],[418,19,418,21,0],[418,22,418,61,0],[419,4,419,5,0],[420,5,420,32,0],[421,5,421,22,0],[422,6,422,18,0],[423,4,423,5,0],[424,4,424,16,0],[425,3,425,4,0]]);
    </script>
  </body>
</html>