<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>p:\stuff\projects\minigamesproject\minigamesproject\assets\_assets\scripts\bearded man studios\scripts\networking\simplejson.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
//#define USE_SharpZipLib

/* * * * *
 * A simple JSON Parser / builder
 * ------------------------------
 * 
 * It mainly has been written as a simple JSON parser. It can build a JSON string
 * from the node-tree, or generate a node tree from any valid JSON string.
 * 
 * If you want to use compression when saving to file / stream / B64 you have to include
 * SharpZipLib ( http://www.icsharpcode.net/opensource/sharpziplib/ ) in your project and
 * define &quot;USE_SharpZipLib&quot; at the top of the file
 * 
 * Written by Bunny83 
 * 2012-06-09
 * 
 * Modified by oPless, 2014-09-21 to round-trip properly
 *
 * Features / attributes:
 * - provides strongly typed node classes and lists / dictionaries
 * - provides easy access to class members / array items / data values
 * - the parser ignores data types. Each value is a string.
 * - only double quotes (&quot;) are used for quoting strings.
 * - values and names are not restricted to quoted strings. They simply add up and are trimmed.
 * - There are only 3 types: arrays(JSONArray), objects(JSONClass) and values(JSONData)
 * - provides &quot;casting&quot; properties to easily convert to / from those types:
 *   int / float / double / bool
 * - provides a common interface for each node so no explicit casting is required.
 * - the parser try to avoid errors, but if malformed JSON is parsed the result is undefined
 * 
 * 
 * 2012-12-17 Update:
 * - Added internal JSONLazyCreator class which simplifies the construction of a JSON tree
 *   Now you can simple reference any item that doesn&#39;t exist yet and it will return a JSONLazyCreator
 *   The class determines the required type by it&#39;s further use, creates the type and removes itself.
 * - Added binary serialization / deserialization.
 * - Added support for BZip2 zipped binary format. Requires the SharpZipLib ( http://www.icsharpcode.net/opensource/sharpziplib/ )
 *   The usage of the SharpZipLib library can be disabled by removing or commenting out the USE_SharpZipLib define at the top
 * - The serializer uses different types when it comes to store the values. Since my data values
 *   are all of type string, the serializer will &quot;try&quot; which format fits best. The order is: int, float, double, bool, string.
 *   It&#39;s not the most efficient way but for a moderate amount of data it should work on all platforms.
 * 
 * * * * */
using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;


namespace BeardedManStudios.SimpleJSON
{
	public enum JSONBinaryTag
	{
		Array = 1,
		Class = 2,
		Value = 3,
		IntValue = 4,
		DoubleValue = 5,
		BoolValue = 6,
		FloatValue = 7,
		UIntValue = 8,
		UShortValue = 9,
		ShortValue = 10,
		ByteValue = 11
	}

	public abstract class JSONNode
	{
		#region common interface

		public virtual void Add(string aKey, JSONNode aItem)
		{
		}

		public virtual JSONNode this[int aIndex] { get { return null; } set { } }

		public virtual JSONNode this[string aKey] { get { return null; } set { } }

		public virtual string Value { get { return &quot;&quot;; } set { } }

		public virtual int Count { get { return 0; } }

		public virtual void Add(JSONNode aItem)
		{
			Add(&quot;&quot;, aItem);
		}

		public virtual JSONNode Remove(string aKey)
		{
			return null;
		}

		public virtual JSONNode Remove(int aIndex)
		{
			return null;
		}

		public virtual JSONNode Remove(JSONNode aNode)
		{
			return aNode;
		}

		public virtual IEnumerable&lt;JSONNode&gt; Children
		{
			get
			{
				yield break;
			}
		}

		public IEnumerable&lt;JSONNode&gt; DeepChildren
		{
			get
			{
				foreach (var C in Children)
					foreach (var D in C.DeepChildren)
						yield return D;
			}
		}

		public override string ToString()
		{
			return &quot;JSONNode&quot;;
		}

		public virtual string ToString(string aPrefix)
		{
			return &quot;JSONNode&quot;;
		}

		public abstract string ToJSON(int prefix);

		#endregion common interface

		#region typecasting properties

		public virtual JSONBinaryTag Tag { get; set; }

		public virtual byte AsByte
		{
			get
			{
				byte v = 0;
				if (byte.TryParse(Value, out v))
					return v;
				return 0;
			}
			set
			{
				Value = value.ToString();
				Tag = JSONBinaryTag.ByteValue;
			}
		}

		public virtual int AsInt
		{
			get
			{
				int v = 0;
				if (int.TryParse(Value, out v))
					return v;
				return 0;
			}
			set
			{
				Value = value.ToString();
				Tag = JSONBinaryTag.IntValue;
			}
		}

		public virtual float AsFloat
		{
			get
			{
				float v = 0.0f;
				if (float.TryParse(Value, NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out v))
					return v;
				return 0.0f;
			}
			set
			{
				Value = value.ToString(CultureInfo.InvariantCulture);
				Tag = JSONBinaryTag.FloatValue;
			}
		}

		public virtual double AsDouble
		{
			get
			{
				double v = 0.0;
				if (double.TryParse(Value, NumberStyles.AllowDecimalPoint | NumberStyles.AllowLeadingSign, CultureInfo.InvariantCulture, out v))
					return v;
				return 0.0;
			}
			set
			{
				Value = value.ToString(CultureInfo.InvariantCulture);
				Tag = JSONBinaryTag.DoubleValue;

			}
		}

		public virtual uint AsUInt
		{
			get
			{
				uint v = 0;
				if (uint.TryParse(Value, out v))
					return v;
				return 0;
			}
			set
			{
				Value = value.ToString();
				Tag = JSONBinaryTag.UIntValue;
			}
		}

		public virtual short AsShort
		{
			get
			{
				short v = 0;
				if (short.TryParse(Value, out v))
					return v;
				return 0;
			}
			set
			{
				Value = value.ToString();
				Tag = JSONBinaryTag.ShortValue;
			}
		}

		public virtual ushort AsUShort
		{
			get
			{
				ushort v = 0;
				if (ushort.TryParse(Value, out v))
					return v;
				return 0;
			}
			set
			{
				Value = value.ToString();
				Tag = JSONBinaryTag.UShortValue;
			}
		}

		public virtual bool AsBool
		{
			get
			{
				bool v = false;
				if (bool.TryParse(Value, out v))
					return v;
				return !string.IsNullOrEmpty(Value);
			}
			set
			{
				Value = (value) ? &quot;true&quot; : &quot;false&quot;;
				Tag = JSONBinaryTag.BoolValue;

			}
		}

		public virtual JSONArray AsArray
		{
			get
			{
				return this as JSONArray;
			}
		}

		public virtual JSONClass AsObject
		{
			get
			{
				return this as JSONClass;
			}
		}


		#endregion typecasting properties

		#region operators

		public static implicit operator JSONNode(string s)
		{
			return new JSONData(s);
		}

		public static implicit operator string(JSONNode d)
		{
			return (d == null) ? null : d.Value;
		}

		public static bool operator ==(JSONNode a, object b)
		{
			if (b == null &amp;&amp; a is JSONLazyCreator)
				return true;
			return System.Object.ReferenceEquals(a, b);
		}

		public static bool operator !=(JSONNode a, object b)
		{
			return !(a == b);
		}

		public override bool Equals(object obj)
		{
			return System.Object.ReferenceEquals(this, obj);
		}

		public override int GetHashCode()
		{
			return base.GetHashCode();
		}


		#endregion operators

		internal static string Escape(string aText)
		{
			string result = &quot;&quot;;
			foreach (char c in aText)
			{
				switch (c)
				{
					case &#39;\\&#39;:
						result += &quot;\\\\&quot;;
						break;
					case &#39;\&quot;&#39;:
						result += &quot;\\\&quot;&quot;;
						break;
					case &#39;\n&#39;:
						result += &quot;\\n&quot;;
						break;
					case &#39;\r&#39;:
						result += &quot;\\r&quot;;
						break;
					case &#39;\t&#39;:
						result += &quot;\\t&quot;;
						break;
					case &#39;\b&#39;:
						result += &quot;\\b&quot;;
						break;
					case &#39;\f&#39;:
						result += &quot;\\f&quot;;
						break;
					default:
						result += c;
						break;
				}
			}
			return result;
		}

		static JSONData Numberize(string token)
		{
			bool flag = false;
			int integer = 0;
			double real = 0;

			if (int.TryParse(token, out integer))
			{
				return new JSONData(integer);
			}

			if (double.TryParse(token, out real))
			{
				return new JSONData(real);
			}

			if (bool.TryParse(token, out flag))
			{
				return new JSONData(flag);
			}

			throw new NotImplementedException(token);
		}

		static void AddElement(JSONNode ctx, string token, string tokenName, bool tokenIsString)
		{
			if (tokenIsString)
			{
				if (ctx is JSONArray)
					ctx.Add(token);
				else
					ctx.Add(tokenName, token); // assume dictionary/object
			}
			else
			{
				JSONData number = Numberize(token);
				if (ctx is JSONArray)
					ctx.Add(number);
				else
					ctx.Add(tokenName, number);

			}
		}

		public static JSONNode Parse(string aJSON)
		{
			Stack&lt;JSONNode&gt; stack = new Stack&lt;JSONNode&gt;();
			JSONNode ctx = null;
			int i = 0;
			string Token = &quot;&quot;;
			string TokenName = &quot;&quot;;
			bool QuoteMode = false;
			bool TokenIsString = false;
			while (i &lt; aJSON.Length)
			{
				switch (aJSON[i])
				{
					case &#39;{&#39;:
						if (QuoteMode)
						{
							Token += aJSON[i];
							break;
						}
						stack.Push(new JSONClass());
						if (ctx != null)
						{
							TokenName = TokenName.Trim();
							if (ctx is JSONArray)
								ctx.Add(stack.Peek());
							else if (TokenName != &quot;&quot;)
								ctx.Add(TokenName, stack.Peek());
						}
						TokenName = &quot;&quot;;
						Token = &quot;&quot;;
						ctx = stack.Peek();
						break;

					case &#39;[&#39;:
						if (QuoteMode)
						{
							Token += aJSON[i];
							break;
						}

						stack.Push(new JSONArray());
						if (ctx != null)
						{
							TokenName = TokenName.Trim();

							if (ctx is JSONArray)
								ctx.Add(stack.Peek());
							else if (TokenName != &quot;&quot;)
								ctx.Add(TokenName, stack.Peek());
						}
						TokenName = &quot;&quot;;
						Token = &quot;&quot;;
						ctx = stack.Peek();
						break;

					case &#39;}&#39;:
					case &#39;]&#39;:
						if (QuoteMode)
						{
							Token += aJSON[i];
							break;
						}
						if (stack.Count == 0)
							throw new Exception(&quot;JSON Parse: Too many closing brackets&quot;);

						stack.Pop();
						if (Token != &quot;&quot;)
						{
							TokenName = TokenName.Trim();
							/*
							if (ctx is JSONArray)
								ctx.Add (Token);
							else if (TokenName != &quot;&quot;)
								ctx.Add (TokenName, Token);
								*/
							AddElement(ctx, Token, TokenName, TokenIsString);
							TokenIsString = false;
						}
						TokenName = &quot;&quot;;
						Token = &quot;&quot;;
						if (stack.Count &gt; 0)
							ctx = stack.Peek();
						break;

					case &#39;:&#39;:
						if (QuoteMode)
						{
							Token += aJSON[i];
							break;
						}
						TokenName = Token;
						Token = &quot;&quot;;
						TokenIsString = false;
						break;

					case &#39;&quot;&#39;:
						QuoteMode ^= true;
						TokenIsString = QuoteMode == true ? true : TokenIsString;
						break;

					case &#39;,&#39;:
						if (QuoteMode)
						{
							Token += aJSON[i];
							break;
						}
						if (Token != &quot;&quot;)
						{
							/*
							if (ctx is JSONArray) {
								ctx.Add (Token);
							} else if (TokenName != &quot;&quot;) {
								ctx.Add (TokenName, Token);
							}
							*/
							AddElement(ctx, Token, TokenName, TokenIsString);
							TokenIsString = false;

						}
						TokenName = &quot;&quot;;
						Token = &quot;&quot;;
						TokenIsString = false;
						break;

					case &#39;\r&#39;:
					case &#39;\n&#39;:
						break;

					case &#39; &#39;:
					case &#39;\t&#39;:
						if (QuoteMode)
							Token += aJSON[i];
						break;

					case &#39;\\&#39;:
						++i;
						if (QuoteMode)
						{
							char C = aJSON[i];
							switch (C)
							{
								case &#39;t&#39;:
									Token += &#39;\t&#39;;
									break;
								case &#39;r&#39;:
									Token += &#39;\r&#39;;
									break;
								case &#39;n&#39;:
									Token += &#39;\n&#39;;
									break;
								case &#39;b&#39;:
									Token += &#39;\b&#39;;
									break;
								case &#39;f&#39;:
									Token += &#39;\f&#39;;
									break;
								case &#39;u&#39;:
									{
										string s = aJSON.Substring(i + 1, 4);
										Token += (char)int.Parse(
											s,
											System.Globalization.NumberStyles.AllowHexSpecifier);
										i += 4;
										break;
									}
								default:
									Token += C;
									break;
							}
						}
						break;

					default:
						Token += aJSON[i];
						break;
				}
				++i;
			}
			if (QuoteMode)
			{
				throw new Exception(&quot;JSON Parse: Quotation marks seems to be messed up.&quot;);
			}
			return ctx;
		}

		public virtual void Serialize(System.IO.BinaryWriter aWriter)
		{
		}

		public void SaveToStream(System.IO.Stream aData)
		{
			var W = new System.IO.BinaryWriter(aData);
			Serialize(W);
		}

#if USE_SharpZipLib
		public void SaveToCompressedStream(System.IO.Stream aData)
		{
			using (var gzipOut = new ICSharpCode.SharpZipLib.BZip2.BZip2OutputStream(aData))
			{
				gzipOut.IsStreamOwner = false;
				SaveToStream(gzipOut);
				gzipOut.Close();
			}
		}
 
		public string SaveToCompressedBase64()
		{
			using (var stream = new System.IO.MemoryStream())
			{
				SaveToCompressedStream(stream);
				stream.Position = 0;
				return System.Convert.ToBase64String(stream.ToArray());
			}
		}
 
#else
		public void SaveToCompressedStream(System.IO.Stream aData)
		{
			throw new Exception(&quot;Can&#39;t use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON&quot;);
		}

		public void SaveToCompressedFile(string aFileName)
		{
			throw new Exception(&quot;Can&#39;t use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON&quot;);
		}

		public string SaveToCompressedBase64()
		{
			throw new Exception(&quot;Can&#39;t use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON&quot;);
		}
#endif

		public string SaveToBase64()
		{
			using (var stream = new System.IO.MemoryStream())
			{
				SaveToStream(stream);
				stream.Position = 0;
				return System.Convert.ToBase64String(stream.ToArray());
			}
		}

		public static JSONNode Deserialize(System.IO.BinaryReader aReader)
		{
			JSONBinaryTag type = (JSONBinaryTag)aReader.ReadByte();
			switch (type)
			{
				case JSONBinaryTag.Array:
					{
						int count = aReader.ReadInt32();
						JSONArray tmp = new JSONArray();
						for (int i = 0; i &lt; count; i++)
							tmp.Add(Deserialize(aReader));
						return tmp;
					}
				case JSONBinaryTag.Class:
					{
						int count = aReader.ReadInt32();
						JSONClass tmp = new JSONClass();
						for (int i = 0; i &lt; count; i++)
						{
							string key = aReader.ReadString();
							var val = Deserialize(aReader);
							tmp.Add(key, val);
						}
						return tmp;
					}
				case JSONBinaryTag.Value:
					{
						return new JSONData(aReader.ReadString());
					}
				case JSONBinaryTag.IntValue:
					{
						return new JSONData(aReader.ReadInt32());
					}
				case JSONBinaryTag.DoubleValue:
					{
						return new JSONData(aReader.ReadDouble());
					}
				case JSONBinaryTag.BoolValue:
					{
						return new JSONData(aReader.ReadBoolean());
					}
				case JSONBinaryTag.FloatValue:
					{
						return new JSONData(aReader.ReadSingle());
					}

				default:
					{
						throw new Exception(&quot;Error deserializing JSON. Unknown tag: &quot; + type);
					}
			}
		}

#if USE_SharpZipLib
		public static JSONNode LoadFromCompressedStream(System.IO.Stream aData)
		{
			var zin = new ICSharpCode.SharpZipLib.BZip2.BZip2InputStream(aData);
			return LoadFromStream(zin);
		}

		public static JSONNode LoadFromCompressedBase64(string aBase64)
		{
			var tmp = System.Convert.FromBase64String(aBase64);
			var stream = new System.IO.MemoryStream(tmp);
			stream.Position = 0;
			return LoadFromCompressedStream(stream);
		}
#else
		public static JSONNode LoadFromCompressedFile(string aFileName)
		{
			throw new Exception(&quot;Can&#39;t use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON&quot;);
		}

		public static JSONNode LoadFromCompressedStream(System.IO.Stream aData)
		{
			throw new Exception(&quot;Can&#39;t use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON&quot;);
		}

		public static JSONNode LoadFromCompressedBase64(string aBase64)
		{
			throw new Exception(&quot;Can&#39;t use compressed functions. You need include the SharpZipLib and uncomment the define at the top of SimpleJSON&quot;);
		}
#endif

		public static JSONNode LoadFromStream(System.IO.Stream aData)
		{
			using (var R = new System.IO.BinaryReader(aData))
			{
				return Deserialize(R);
			}
		}

		public static JSONNode LoadFromBase64(string aBase64)
		{
			var tmp = System.Convert.FromBase64String(aBase64);
			var stream = new System.IO.MemoryStream(tmp);
			stream.Position = 0;
			return LoadFromStream(stream);
		}
	}
	// End of JSONNode

	public class JSONArray : JSONNode, IEnumerable
	{
		private List&lt;JSONNode&gt; m_List = new List&lt;JSONNode&gt;();

		public override JSONNode this[int aIndex]
		{
			get
			{
				if (aIndex &lt; 0 || aIndex &gt;= m_List.Count)
					return new JSONLazyCreator(this);
				return m_List[aIndex];
			}
			set
			{
				if (aIndex &lt; 0 || aIndex &gt;= m_List.Count)
					m_List.Add(value);
				else
					m_List[aIndex] = value;
			}
		}

		public override JSONNode this[string aKey]
		{
			get { return new JSONLazyCreator(this); }
			set { m_List.Add(value); }
		}

		public override int Count
		{
			get { return m_List.Count; }
		}

		public override void Add(string aKey, JSONNode aItem)
		{
			m_List.Add(aItem);
		}

		public override JSONNode Remove(int aIndex)
		{
			if (aIndex &lt; 0 || aIndex &gt;= m_List.Count)
				return null;
			JSONNode tmp = m_List[aIndex];
			m_List.RemoveAt(aIndex);
			return tmp;
		}

		public override JSONNode Remove(JSONNode aNode)
		{
			m_List.Remove(aNode);
			return aNode;
		}

		public override IEnumerable&lt;JSONNode&gt; Children
		{
			get
			{
				foreach (JSONNode N in m_List)
					yield return N;
			}
		}

		public IEnumerator GetEnumerator()
		{
			foreach (JSONNode N in m_List)
				yield return N;
		}

		public override string ToString()
		{
			string result = &quot;[&quot;;
			foreach (JSONNode N in m_List)
			{
				if (result.Length &gt; 2)
					result += &quot;,&quot;;

				result += N.ToString();
			}
			result += &quot;]&quot;;
			return result;
		}

		public override string ToString(string aPrefix)
		{
			string result = &quot;[ &quot;;
			foreach (JSONNode N in m_List)
			{
				if (result.Length &gt; 3)
					result += &quot;, &quot;;
				result += &quot;\n&quot; + aPrefix + &quot;   &quot;;
				result += N.ToString(aPrefix + &quot;   &quot;);
			}
			result += &quot;\n&quot; + aPrefix + &quot;]&quot;;
			return result;
		}

		public override string ToJSON(int prefix)
		{
			string s = new string(&#39; &#39;, (prefix + 1) * 2);
			string ret = &quot;[ &quot;;
			foreach (JSONNode n in m_List)
			{
				if (ret.Length &gt; 3)
					ret += &quot;, &quot;;
				ret += &quot;\n&quot; + s;
				ret += n.ToJSON(prefix + 1);

			}
			ret += &quot;\n&quot; + s + &quot;]&quot;;
			return ret;
		}

		public override void Serialize(System.IO.BinaryWriter aWriter)
		{
			aWriter.Write((byte)JSONBinaryTag.Array);
			aWriter.Write(m_List.Count);
			for (int i = 0; i &lt; m_List.Count; i++)
			{
				m_List[i].Serialize(aWriter);
			}
		}
	}
	// End of JSONArray

	public class JSONClass : JSONNode, IEnumerable
	{
		private Dictionary&lt;string, JSONNode&gt; m_Dict = new Dictionary&lt;string, JSONNode&gt;();

		public override JSONNode this[string aKey]
		{
			get
			{
				if (m_Dict.ContainsKey(aKey))
					return m_Dict[aKey];
				else
					return new JSONLazyCreator(this, aKey);
			}
			set
			{
				if (m_Dict.ContainsKey(aKey))
					m_Dict[aKey] = value;
				else
					m_Dict.Add(aKey, value);
			}
		}

		public override JSONNode this[int aIndex]
		{
			get
			{
				if (aIndex &lt; 0 || aIndex &gt;= m_Dict.Count)
					return null;
				return m_Dict.ElementAt(aIndex).Value;
			}
			set
			{
				if (aIndex &lt; 0 || aIndex &gt;= m_Dict.Count)
					return;
				string key = m_Dict.ElementAt(aIndex).Key;
				m_Dict[key] = value;
			}
		}

		public override int Count
		{
			get { return m_Dict.Count; }
		}


		public override void Add(string aKey, JSONNode aItem)
		{
			if (!string.IsNullOrEmpty(aKey))
			{
				if (m_Dict.ContainsKey(aKey))
					m_Dict[aKey] = aItem;
				else
					m_Dict.Add(aKey, aItem);
			}
			else
				m_Dict.Add(Guid.NewGuid().ToString(), aItem);
		}

		public override JSONNode Remove(string aKey)
		{
			if (!m_Dict.ContainsKey(aKey))
				return null;
			JSONNode tmp = m_Dict[aKey];
			m_Dict.Remove(aKey);
			return tmp;
		}

		public override JSONNode Remove(int aIndex)
		{
			if (aIndex &lt; 0 || aIndex &gt;= m_Dict.Count)
				return null;
			var item = m_Dict.ElementAt(aIndex);
			m_Dict.Remove(item.Key);
			return item.Value;
		}

		public override JSONNode Remove(JSONNode aNode)
		{
			try
			{
				var item = m_Dict.Where(k =&gt; k.Value == aNode).First();
				m_Dict.Remove(item.Key);
				return aNode;
			}
			catch
			{
				return null;
			}
		}

		public override IEnumerable&lt;JSONNode&gt; Children
		{
			get
			{
				foreach (KeyValuePair&lt;string, JSONNode&gt; N in m_Dict)
					yield return N.Value;
			}
		}

		public IEnumerator GetEnumerator()
		{
			foreach (KeyValuePair&lt;string, JSONNode&gt; N in m_Dict)
				yield return N;
		}

		public override string ToString()
		{
			string result = &quot;{&quot;;
			foreach (KeyValuePair&lt;string, JSONNode&gt; N in m_Dict)
			{
				if (result.Length &gt; 2)
					result += &quot;, &quot;;
				result += &quot;\&quot;&quot; + Escape(N.Key) + &quot;\&quot;:&quot; + N.Value.ToString();
			}
			result += &quot;}&quot;;
			return result;
		}

		public override string ToString(string aPrefix)
		{
			string result = &quot;{ &quot;;
			foreach (KeyValuePair&lt;string, JSONNode&gt; N in m_Dict)
			{
				if (result.Length &gt; 3)
					result += &quot;, &quot;;
				result += &quot;\n&quot; + aPrefix + &quot;   &quot;;
				result += &quot;\&quot;&quot; + Escape(N.Key) + &quot;\&quot; : &quot; + N.Value.ToString(aPrefix + &quot;   &quot;);
			}
			result += &quot;\n&quot; + aPrefix + &quot;}&quot;;
			return result;
		}

		public override string ToJSON(int prefix)
		{
			string s = string.Empty;
			string ret = &quot;{&quot;;
			foreach (KeyValuePair&lt;string, JSONNode&gt; n in m_Dict)
			{
				if (ret.Length &gt; 3)
					ret += &quot;,&quot;;
				//ret += &quot;\n&quot; + s;
				ret += s;
				ret += string.Format(&quot;\&quot;{0}\&quot;:{1}&quot;, n.Key, n.Value.ToJSON(0));
			}
			//ret += &quot;\n&quot; + s + &quot;}&quot;;
			ret += s + &quot;}&quot;;
			return ret;
		}

		public override void Serialize(System.IO.BinaryWriter aWriter)
		{
			aWriter.Write((byte)JSONBinaryTag.Class);
			aWriter.Write(m_Dict.Count);
			foreach (string K in m_Dict.Keys)
			{
				aWriter.Write(K);
				m_Dict[K].Serialize(aWriter);
			}
		}
	}
	// End of JSONClass

	public class JSONData : JSONNode
	{
		private string m_Data;


		public override string Value
		{
			get { return m_Data; }
			set
			{
				m_Data = value;
				Tag = JSONBinaryTag.Value;
			}
		}

		public JSONData(string aData)
		{
			m_Data = aData;
			Tag = JSONBinaryTag.Value;
		}

		public JSONData(float aData)
		{
			AsFloat = aData;
		}

		public JSONData(double aData)
		{
			AsDouble = aData;
		}

		public JSONData(bool aData)
		{
			AsBool = aData;
		}

		public JSONData(byte aData)
		{
			AsByte = aData;
		}

		public JSONData(int aData)
		{
			AsInt = aData;
		}

		public JSONData(uint aData)
		{
			AsUInt = aData;
		}

		public JSONData(short aData)
		{
			AsShort = aData;
		}

		public JSONData(ushort aData)
		{
			AsUShort = aData;
		}

		public override string ToString()
		{
			string returnString;
			switch (Tag)
			{
				case JSONBinaryTag.DoubleValue:
				case JSONBinaryTag.FloatValue:
				case JSONBinaryTag.IntValue:
				case JSONBinaryTag.UIntValue:
				case JSONBinaryTag.BoolValue:
				case JSONBinaryTag.ByteValue:
				case JSONBinaryTag.UShortValue:
				case JSONBinaryTag.ShortValue:
					returnString = Escape(m_Data);
					break;
				default:
					returnString = &quot;\&quot;&quot; + Escape(m_Data) + &quot;\&quot;&quot;;
					break;

			}
			return returnString;
		}

		public override string ToString(string aPrefix)
		{
			string returnString;
			switch (Tag)
			{
				case JSONBinaryTag.DoubleValue:
				case JSONBinaryTag.FloatValue:
				case JSONBinaryTag.IntValue:
				case JSONBinaryTag.UIntValue:
				case JSONBinaryTag.BoolValue:
				case JSONBinaryTag.ByteValue:
				case JSONBinaryTag.UShortValue:
				case JSONBinaryTag.ShortValue:
					returnString = Escape(m_Data);
					break;
				default:
					returnString = &quot;\&quot;&quot; + Escape(m_Data) + &quot;\&quot;&quot;;
					break;

			}
			return returnString;
		}

		public override string ToJSON(int prefix)
		{
			switch (Tag)
			{
				case JSONBinaryTag.DoubleValue:
				case JSONBinaryTag.FloatValue:
				case JSONBinaryTag.IntValue:
				case JSONBinaryTag.UIntValue:
				case JSONBinaryTag.BoolValue:
				case JSONBinaryTag.ByteValue:
				case JSONBinaryTag.UShortValue:
				case JSONBinaryTag.ShortValue:
					return m_Data;
				case JSONBinaryTag.Value:
					return string.Format(&quot;\&quot;{0}\&quot;&quot;, Escape(m_Data));
				default:
					throw new NotSupportedException(&quot;This shouldn&#39;t be here: &quot; + Tag.ToString());
			}
		}

		public override void Serialize(System.IO.BinaryWriter aWriter)
		{
			var tmp = new JSONData(&quot;&quot;);

			tmp.AsInt = AsInt;
			if (tmp.m_Data == this.m_Data)
			{
				aWriter.Write((byte)JSONBinaryTag.IntValue);
				aWriter.Write(AsInt);
				return;
			}
			tmp.AsFloat = AsFloat;
			if (tmp.m_Data == this.m_Data)
			{
				aWriter.Write((byte)JSONBinaryTag.FloatValue);
				aWriter.Write(AsFloat);
				return;
			}
			tmp.AsDouble = AsDouble;
			if (tmp.m_Data == this.m_Data)
			{
				aWriter.Write((byte)JSONBinaryTag.DoubleValue);
				aWriter.Write(AsDouble);
				return;
			}

			tmp.AsUInt = AsUInt;
			if (tmp.m_Data == this.m_Data)
			{
				aWriter.Write((byte)JSONBinaryTag.UIntValue);
				aWriter.Write(AsUInt);
				return;
			}

			tmp.AsShort = AsShort;
			if (tmp.m_Data == this.m_Data)
			{
				aWriter.Write((byte)JSONBinaryTag.ShortValue);
				aWriter.Write(AsShort);
				return;
			}

			tmp.AsUShort = AsUShort;
			if (tmp.m_Data == this.m_Data)
			{
				aWriter.Write((byte)JSONBinaryTag.UShortValue);
				aWriter.Write(AsUShort);
				return;
			}

			tmp.AsBool = AsBool;
			if (tmp.m_Data == this.m_Data)
			{
				aWriter.Write((byte)JSONBinaryTag.BoolValue);
				aWriter.Write(AsBool);
				return;
			}

			tmp.AsByte = AsByte;
			if (tmp.m_Data == this.m_Data)
			{
				aWriter.Write((byte)JSONBinaryTag.ByteValue);
				aWriter.Write(AsByte);
				return;
			}

			aWriter.Write((byte)JSONBinaryTag.Value);
			aWriter.Write(m_Data);
		}
	}
	// End of JSONData

	internal class JSONLazyCreator : JSONNode
	{
		private JSONNode m_Node = null;
		private string m_Key = null;

		public JSONLazyCreator(JSONNode aNode)
		{
			m_Node = aNode;
			m_Key = null;
		}

		public JSONLazyCreator(JSONNode aNode, string aKey)
		{
			m_Node = aNode;
			m_Key = aKey;
		}

		private void Set(JSONNode aVal)
		{
			if (m_Key == null)
			{
				m_Node.Add(aVal);
			}
			else
			{
				m_Node.Add(m_Key, aVal);
			}
			m_Node = null; // Be GC friendly.
		}

		public override JSONNode this[int aIndex]
		{
			get
			{
				return new JSONLazyCreator(this);
			}
			set
			{
				var tmp = new JSONArray();
				tmp.Add(value);
				Set(tmp);
			}
		}

		public override JSONNode this[string aKey]
		{
			get
			{
				return new JSONLazyCreator(this, aKey);
			}
			set
			{
				var tmp = new JSONClass();
				tmp.Add(aKey, value);
				Set(tmp);
			}
		}

		public override void Add(JSONNode aItem)
		{
			var tmp = new JSONArray();
			tmp.Add(aItem);
			Set(tmp);
		}

		public override void Add(string aKey, JSONNode aItem)
		{
			var tmp = new JSONClass();
			tmp.Add(aKey, aItem);
			Set(tmp);
		}

		public static bool operator ==(JSONLazyCreator a, object b)
		{
			if (b == null)
				return true;
			return System.Object.ReferenceEquals(a, b);
		}

		public static bool operator !=(JSONLazyCreator a, object b)
		{
			return !(a == b);
		}

		public override bool Equals(object obj)
		{
			if (obj == null)
				return true;
			return System.Object.ReferenceEquals(this, obj);
		}

		public override int GetHashCode()
		{
			return base.GetHashCode();
		}

		public override string ToString()
		{
			return &quot;&quot;;
		}

		public override string ToString(string aPrefix)
		{
			return &quot;&quot;;
		}

		public override string ToJSON(int prefix)
		{
			return &quot;&quot;;
		}

		public override int AsInt
		{
			get
			{
				JSONData tmp = new JSONData(0);
				Set(tmp);
				return 0;
			}
			set
			{
				JSONData tmp = new JSONData(value);
				Set(tmp);
			}
		}

		public override float AsFloat
		{
			get
			{
				JSONData tmp = new JSONData(0.0f);
				Set(tmp);
				return 0.0f;
			}
			set
			{
				JSONData tmp = new JSONData(value);
				Set(tmp);
			}
		}

		public override double AsDouble
		{
			get
			{
				JSONData tmp = new JSONData(0.0);
				Set(tmp);
				return 0.0;
			}
			set
			{
				JSONData tmp = new JSONData(value);
				Set(tmp);
			}
		}

		public override uint AsUInt
		{
			get
			{
				JSONData tmp = new JSONData((uint)0);
				Set(tmp);
				return 0;
			}
			set
			{
				JSONData tmp = new JSONData(value);
				Set(tmp);
			}
		}

		public override short AsShort
		{
			get
			{
				JSONData tmp = new JSONData((short)0);
				Set(tmp);
				return 0;
			}
			set
			{
				JSONData tmp = new JSONData(value);
				Set(tmp);
			}
		}

		public override ushort AsUShort
		{
			get
			{
				JSONData tmp = new JSONData((ushort)0);
				Set(tmp);
				return 0;
			}
			set
			{
				JSONData tmp = new JSONData(value);
				Set(tmp);
			}
		}

		public override bool AsBool
		{
			get
			{
				JSONData tmp = new JSONData(false);
				Set(tmp);
				return false;
			}
			set
			{
				JSONData tmp = new JSONData(value);
				Set(tmp);
			}
		}

		public override JSONArray AsArray
		{
			get
			{
				JSONArray tmp = new JSONArray();
				Set(tmp);
				return tmp;
			}
		}

		public override JSONClass AsObject
		{
			get
			{
				JSONClass tmp = new JSONClass();
				Set(tmp);
				return tmp;
			}
		}
	}
	// End of JSONLazyCreator

	public static class JSON
	{
		public static JSONNode Parse(string aJSON)
		{
			return JSONNode.Parse(aJSON);
		}
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[73,3,73,4,0],[74,3,74,4,0],[76,50,76,51,0],[76,52,76,64,0],[76,65,76,66,0],[76,71,76,72,0],[76,73,76,74,0],[78,51,78,52,0],[78,53,78,65,0],[78,66,78,67,0],[78,72,78,73,0],[78,74,78,75,0],[80,37,80,38,0],[80,39,80,49,0],[80,50,80,51,0],[80,56,80,57,0],[80,58,80,59,0],[82,34,82,35,0],[82,36,82,45,0],[82,46,82,47,0],[85,3,85,4,0],[86,4,86,19,0],[87,3,87,4,0],[90,3,90,4,0],[91,4,91,16,0],[92,3,92,4,0],[95,3,95,4,0],[96,4,96,16,0],[97,3,97,4,0],[100,3,100,4,0],[101,4,101,17,0],[102,3,102,4,0],[107,4,107,5,0],[108,5,108,17,0],[115,4,115,5,0],[116,5,116,12,0],[116,14,116,19,0],[116,20,116,22,0],[116,23,116,31,0],[117,6,117,13,0],[117,15,117,20,0],[117,21,117,23,0],[117,24,117,38,0],[118,7,118,22,0],[119,4,119,5,0],[123,3,123,4,0],[124,4,124,22,0],[125,3,125,4,0],[128,3,128,4,0],[129,4,129,22,0],[130,3,130,4,0],[138,38,138,42,0],[138,43,138,47,0],[143,4,143,5,0],[144,5,144,16,0],[145,5,145,37,0],[146,6,146,15,0],[147,5,147,14,0],[148,4,148,5,0],[150,4,150,5,0],[151,5,151,30,0],[152,5,152,35,0],[153,4,153,5,0],[159,4,159,5,0],[160,5,160,15,0],[161,5,161,36,0],[162,6,162,15,0],[163,5,163,14,0],[164,4,164,5,0],[166,4,166,5,0],[167,5,167,30,0],[168,5,168,34,0],[169,4,169,5,0],[175,4,175,5,0],[176,5,176,20,0],[177,5,177,132,0],[178,6,178,15,0],[179,5,179,17,0],[180,4,180,5,0],[182,4,182,5,0],[183,5,183,58,0],[184,5,184,36,0],[185,4,185,5,0],[191,4,191,5,0],[192,5,192,20,0],[193,5,193,133,0],[194,6,194,15,0],[195,5,195,16,0],[196,4,196,5,0],[198,4,198,5,0],[199,5,199,58,0],[200,5,200,37,0],[202,4,202,5,0],[208,4,208,5,0],[209,5,209,16,0],[210,5,210,37,0],[211,6,211,15,0],[212,5,212,14,0],[213,4,213,5,0],[215,4,215,5,0],[216,5,216,30,0],[217,5,217,35,0],[218,4,218,5,0],[224,4,224,5,0],[225,5,225,17,0],[226,5,226,38,0],[227,6,227,15,0],[228,5,228,14,0],[229,4,229,5,0],[231,4,231,5,0],[232,5,232,30,0],[233,5,233,36,0],[234,4,234,5,0],[240,4,240,5,0],[241,5,241,18,0],[242,5,242,39,0],[243,6,243,15,0],[244,5,244,14,0],[245,4,245,5,0],[247,4,247,5,0],[248,5,248,30,0],[249,5,249,37,0],[250,4,250,5,0],[256,4,256,5,0],[257,5,257,20,0],[258,5,258,37,0],[259,6,259,15,0],[260,5,260,41,0],[261,4,261,5,0],[263,4,263,5,0],[264,5,264,40,0],[265,5,265,35,0],[267,4,267,5,0],[273,4,273,5,0],[274,5,274,30,0],[275,4,275,5,0],[281,4,281,5,0],[282,5,282,30,0],[283,4,283,5,0],[292,3,292,4,0],[293,4,293,27,0],[294,3,294,4,0],[297,3,297,4,0],[298,4,298,40,0],[299,3,299,4,0],[302,3,302,4,0],[303,4,303,42,0],[304,5,304,17,0],[305,4,305,47,0],[306,3,306,4,0],[309,3,309,4,0],[310,4,310,21,0],[311,3,311,4,0],[314,3,314,4,0],[315,4,315,52,0],[316,3,316,4,0],[319,3,319,4,0],[320,4,320,30,0],[321,3,321,4,0],[327,3,327,4,0],[328,4,328,23,0],[329,4,329,11,0],[329,13,329,19,0],[329,20,329,22,0],[329,23,329,28,0],[330,4,330,5,0],[331,5,331,15,0],[334,7,334,24,0],[335,7,335,13,0],[337,7,337,24,0],[338,7,338,13,0],[340,7,340,23,0],[341,7,341,13,0],[343,7,343,23,0],[344,7,344,13,0],[346,7,346,23,0],[347,7,347,13,0],[349,7,349,23,0],[350,7,350,13,0],[352,7,352,23,0],[353,7,353,13,0],[355,7,355,19,0],[356,7,356,13,0],[358,4,358,5,0],[359,4,359,18,0],[360,3,360,4,0],[363,3,363,4,0],[364,4,364,22,0],[365,4,365,20,0],[366,4,366,20,0],[368,4,368,41,0],[369,4,369,5,0],[370,5,370,34,0],[373,4,373,41,0],[374,4,374,5,0],[375,5,375,31,0],[378,4,378,39,0],[379,4,379,5,0],[380,5,380,31,0],[383,4,383,45,0],[384,3,384,4,0],[387,3,387,4,0],[388,4,388,22,0],[389,4,389,5,0],[390,5,390,26,0],[391,6,391,21,0],[393,6,393,32,0],[394,4,394,5,0],[396,4,396,5,0],[397,5,397,40,0],[398,5,398,26,0],[399,6,399,22,0],[401,6,401,33,0],[403,4,403,5,0],[404,3,404,4,0],[407,3,407,4,0],[408,4,408,50,0],[409,4,409,24,0],[410,4,410,14,0],[411,4,411,22,0],[412,4,412,26,0],[413,4,413,27,0],[414,4,414,31,0],[415,4,415,28,0],[416,4,416,5,0],[417,5,417,22,0],[420,7,420,21,0],[421,7,421,8,0],[422,8,422,26,0],[423,8,423,14,0],[425,7,425,35,0],[426,7,426,23,0],[427,7,427,8,0],[428,8,428,37,0],[429,8,429,29,0],[430,9,430,31,0],[431,13,431,33,0],[432,9,432,42,0],[433,7,433,8,0],[434,7,434,22,0],[435,7,435,18,0],[436,7,436,26,0],[437,7,437,13,0],[440,7,440,21,0],[441,7,441,8,0],[442,8,442,26,0],[443,8,443,14,0],[446,7,446,35,0],[447,7,447,23,0],[448,7,448,8,0],[449,8,449,37,0],[451,8,451,29,0],[452,9,452,31,0],[453,13,453,33,0],[454,9,454,42,0],[455,7,455,8,0],[456,7,456,22,0],[457,7,457,18,0],[458,7,458,26,0],[459,7,459,13,0],[463,7,463,21,0],[464,7,464,8,0],[465,8,465,26,0],[466,8,466,14,0],[468,7,468,28,0],[469,8,469,69,0],[471,7,471,19,0],[472,7,472,23,0],[473,7,473,8,0],[474,8,474,37,0],[481,8,481,57,0],[482,8,482,30,0],[483,7,483,8,0],[484,7,484,22,0],[485,7,485,18,0],[486,7,486,27,0],[487,8,487,27,0],[488,7,488,13,0],[491,7,491,21,0],[492,7,492,8,0],[493,8,493,26,0],[494,8,494,14,0],[496,7,496,25,0],[497,7,497,18,0],[498,7,498,29,0],[499,7,499,13,0],[502,7,502,25,0],[503,7,503,64,0],[504,7,504,13,0],[507,7,507,21,0],[508,7,508,8,0],[509,8,509,26,0],[510,8,510,14,0],[512,7,512,23,0],[513,7,513,8,0],[521,8,521,57,0],[522,8,522,30,0],[524,7,524,8,0],[525,7,525,22,0],[526,7,526,18,0],[527,7,527,29,0],[528,7,528,13,0],[532,7,532,13,0],[536,7,536,21,0],[537,8,537,26,0],[538,7,538,13,0],[541,7,541,11,0],[542,7,542,21,0],[543,7,543,8,0],[544,8,544,26,0],[545,8,545,18,0],[548,10,548,24,0],[549,10,549,16,0],[551,10,551,24,0],[552,10,552,16,0],[554,10,554,24,0],[555,10,555,16,0],[557,10,557,24,0],[558,10,558,16,0],[560,10,560,24,0],[561,10,561,16,0],[563,10,563,11,0],[564,11,564,48,0],[565,11,567,65,0],[568,11,568,18,0],[569,11,569,17,0],[572,10,572,21,0],[573,10,573,16,0],[575,7,575,8,0],[576,7,576,13,0],[579,7,579,25,0],[580,7,580,13,0],[582,5,582,9,0],[583,4,583,5,0],[584,4,584,18,0],[585,4,585,5,0],[586,5,586,79,0],[588,4,588,15,0],[589,3,589,4,0],[592,3,592,4,0],[593,3,593,4,0],[596,3,596,4,0],[597,4,597,46,0],[598,4,598,17,0],[599,3,599,4,0],[624,3,624,4,0],[625,4,625,142,0],[629,3,629,4,0],[630,4,630,142,0],[634,3,634,4,0],[635,4,635,142,0],[640,3,640,4,0],[641,11,641,52,0],[642,4,642,5,0],[643,5,643,26,0],[644,5,644,25,0],[645,5,645,60,0],[647,3,647,4,0],[650,3,650,4,0],[651,4,651,59,0],[652,4,652,17,0],[655,6,655,7,0],[656,7,656,39,0],[657,7,657,39,0],[658,12,658,21,0],[658,23,658,32,0],[658,34,658,37,0],[659,8,659,38,0],[660,7,660,18,0],[663,6,663,7,0],[664,7,664,39,0],[665,7,665,39,0],[666,12,666,21,0],[666,23,666,32,0],[666,34,666,37,0],[667,7,667,8,0],[668,8,668,42,0],[669,8,669,39,0],[670,8,670,26,0],[671,7,671,8,0],[672,7,672,18,0],[675,6,675,7,0],[676,7,676,49,0],[679,6,679,7,0],[680,7,680,48,0],[683,6,683,7,0],[684,7,684,49,0],[687,6,687,7,0],[688,7,688,50,0],[691,6,691,7,0],[692,7,692,49,0],[696,6,696,7,0],[697,7,697,77,0],[700,3,700,4,0],[718,3,718,4,0],[719,4,719,142,0],[723,3,723,4,0],[724,4,724,142,0],[728,3,728,4,0],[729,4,729,142,0],[734,3,734,4,0],[735,11,735,52,0],[736,4,736,5,0],[737,5,737,27,0],[739,3,739,4,0],[742,3,742,4,0],[743,4,743,55,0],[744,4,744,49,0],[745,4,745,24,0],[746,4,746,34,0],[747,3,747,4,0],[753,3,753,56,0],[758,4,758,5,0],[759,5,759,46,0],[760,6,760,39,0],[761,5,761,27,0],[762,4,762,5,0],[764,4,764,5,0],[765,5,765,46,0],[766,6,766,24,0],[768,6,768,29,0],[769,4,769,5,0],[774,8,774,9,0],[774,10,774,43,0],[774,44,774,45,0],[775,8,775,9,0],[775,10,775,28,0],[775,29,775,30,0],[780,8,780,9,0],[780,10,780,30,0],[780,31,780,32,0],[784,3,784,4,0],[785,4,785,22,0],[786,3,786,4,0],[789,3,789,4,0],[790,4,790,45,0],[791,5,791,17,0],[792,4,792,34,0],[793,4,793,28,0],[794,4,794,15,0],[795,3,795,4,0],[798,3,798,4,0],[799,4,799,25,0],[800,4,800,17,0],[801,3,801,4,0],[806,4,806,5,0],[807,5,807,12,0],[807,14,807,24,0],[807,25,807,27,0],[807,28,807,34,0],[808,6,808,21,0],[809,4,809,5,0],[813,3,813,4,0],[814,4,814,11,0],[814,13,814,23,0],[814,24,814,26,0],[814,27,814,33,0],[815,5,815,20,0],[816,3,816,4,0],[819,3,819,4,0],[820,4,820,24,0],[821,4,821,11,0],[821,13,821,23,0],[821,24,821,26,0],[821,27,821,33,0],[822,4,822,5,0],[823,5,823,27,0],[824,6,824,20,0],[826,5,826,28,0],[827,4,827,5,0],[828,4,828,18,0],[829,4,829,18,0],[830,3,830,4,0],[833,3,833,4,0],[834,4,834,25,0],[835,4,835,11,0],[835,13,835,23,0],[835,24,835,26,0],[835,27,835,33,0],[836,4,836,5,0],[837,5,837,27,0],[838,6,838,21,0],[839,5,839,38,0],[840,5,840,43,0],[841,4,841,5,0],[842,4,842,35,0],[843,4,843,18,0],[844,3,844,4,0],[847,3,847,4,0],[848,4,848,49,0],[849,4,849,22,0],[850,4,850,11,0],[850,13,850,23,0],[850,24,850,26,0],[850,27,850,33,0],[851,4,851,5,0],[852,5,852,24,0],[853,6,853,18,0],[854,5,854,21,0],[855,5,855,33,0],[857,4,857,5,0],[858,4,858,26,0],[859,4,859,15,0],[860,3,860,4,0],[863,3,863,4,0],[864,4,864,45,0],[865,4,865,32,0],[866,9,866,18,0],[866,20,866,36,0],[866,38,866,41,0],[867,4,867,5,0],[868,5,868,34,0],[869,4,869,5,0],[870,3,870,4,0],[876,3,876,84,0],[881,4,881,5,0],[882,5,882,34,0],[883,6,883,26,0],[885,6,885,45,0],[886,4,886,5,0],[888,4,888,5,0],[889,5,889,34,0],[890,6,890,27,0],[892,6,892,30,0],[893,4,893,5,0],[899,4,899,5,0],[900,5,900,46,0],[901,6,901,18,0],[902,5,902,43,0],[903,4,903,5,0],[905,4,905,5,0],[906,5,906,46,0],[907,6,907,13,0],[908,5,908,47,0],[909,5,909,25,0],[910,4,910,5,0],[915,8,915,9,0],[915,10,915,30,0],[915,31,915,32,0],[920,3,920,4,0],[921,4,921,36,0],[922,4,922,5,0],[923,5,923,34,0],[924,6,924,27,0],[926,6,926,30,0],[927,4,927,5,0],[929,5,929,50,0],[930,3,930,4,0],[933,3,933,4,0],[934,4,934,34,0],[935,5,935,17,0],[936,4,936,32,0],[937,4,937,24,0],[938,4,938,15,0],[939,3,939,4,0],[942,3,942,4,0],[943,4,943,45,0],[944,5,944,17,0],[945,4,945,40,0],[946,4,946,28,0],[947,4,947,22,0],[948,3,948,4,0],[951,3,951,4,0],[953,4,953,5,0],[954,5,954,34,0],[954,34,954,50,0],[954,50,954,60,0],[954,5,954,60,0],[955,5,955,29,0],[956,5,956,18,0],[958,4,958,9,0],[959,4,959,5,0],[960,5,960,17,0],[962,3,962,4,0],[967,4,967,5,0],[968,5,968,12,0],[968,14,968,46,0],[968,47,968,49,0],[968,50,968,56,0],[969,6,969,27,0],[970,4,970,5,0],[974,3,974,4,0],[975,4,975,11,0],[975,13,975,45,0],[975,46,975,48,0],[975,49,975,55,0],[976,5,976,20,0],[977,3,977,4,0],[980,3,980,4,0],[981,4,981,24,0],[982,4,982,11,0],[982,13,982,45,0],[982,46,982,48,0],[982,49,982,55,0],[983,4,983,5,0],[984,5,984,27,0],[985,6,985,21,0],[986,5,986,65,0],[987,4,987,5,0],[988,4,988,18,0],[989,4,989,18,0],[990,3,990,4,0],[993,3,993,4,0],[994,4,994,25,0],[995,4,995,11,0],[995,13,995,45,0],[995,46,995,48,0],[995,49,995,55,0],[996,4,996,5,0],[997,5,997,27,0],[998,6,998,21,0],[999,5,999,38,0],[1000,5,1000,82,0],[1001,4,1001,5,0],[1002,4,1002,35,0],[1003,4,1003,18,0],[1004,3,1004,4,0],[1007,3,1007,4,0],[1008,4,1008,28,0],[1009,4,1009,21,0],[1010,4,1010,11,0],[1010,13,1010,45,0],[1010,46,1010,48,0],[1010,49,1010,55,0],[1011,4,1011,5,0],[1012,5,1012,24,0],[1013,6,1013,17,0],[1015,5,1015,14,0],[1016,5,1016,67,0],[1017,4,1017,5,0],[1019,4,1019,19,0],[1020,4,1020,15,0],[1021,3,1021,4,0],[1024,3,1024,4,0],[1025,4,1025,45,0],[1026,4,1026,32,0],[1027,4,1027,11,0],[1027,13,1027,21,0],[1027,22,1027,24,0],[1027,25,1027,36,0],[1028,4,1028,5,0],[1029,5,1029,22,0],[1030,5,1030,34,0],[1031,4,1031,5,0],[1032,3,1032,4,0],[1043,8,1043,9,0],[1043,10,1043,24,0],[1043,25,1043,26,0],[1045,4,1045,5,0],[1046,5,1046,20,0],[1047,5,1047,31,0],[1048,4,1048,5,0],[1051,3,1051,32,0],[1052,3,1052,4,0],[1053,4,1053,19,0],[1054,4,1054,30,0],[1055,3,1055,4,0],[1057,3,1057,31,0],[1058,3,1058,4,0],[1059,4,1059,20,0],[1060,3,1060,4,0],[1062,3,1062,32,0],[1063,3,1063,4,0],[1064,4,1064,21,0],[1065,3,1065,4,0],[1067,3,1067,30,0],[1068,3,1068,4,0],[1069,4,1069,19,0],[1070,3,1070,4,0],[1072,3,1072,30,0],[1073,3,1073,4,0],[1074,4,1074,19,0],[1075,3,1075,4,0],[1077,3,1077,29,0],[1078,3,1078,4,0],[1079,4,1079,18,0],[1080,3,1080,4,0],[1082,3,1082,30,0],[1083,3,1083,4,0],[1084,4,1084,19,0],[1085,3,1085,4,0],[1087,3,1087,31,0],[1088,3,1088,4,0],[1089,4,1089,20,0],[1090,3,1090,4,0],[1092,3,1092,32,0],[1093,3,1093,4,0],[1094,4,1094,21,0],[1095,3,1095,4,0],[1098,3,1098,4,0],[1100,4,1100,16,0],[1110,6,1110,36,0],[1111,6,1111,12,0],[1113,6,1113,50,0],[1114,6,1114,12,0],[1117,4,1117,24,0],[1118,3,1118,4,0],[1121,3,1121,4,0],[1123,4,1123,16,0],[1133,6,1133,36,0],[1134,6,1134,12,0],[1136,6,1136,50,0],[1137,6,1137,12,0],[1140,4,1140,24,0],[1141,3,1141,4,0],[1144,3,1144,4,0],[1145,4,1145,16,0],[1155,6,1155,20,0],[1157,6,1157,54,0],[1159,6,1159,83,0],[1161,3,1161,4,0],[1164,3,1164,4,0],[1165,4,1165,31,0],[1167,4,1167,22,0],[1168,4,1168,34,0],[1169,4,1169,5,0],[1170,5,1170,49,0],[1171,5,1171,26,0],[1172,5,1172,12,0],[1174,4,1174,26,0],[1175,4,1175,34,0],[1176,4,1176,5,0],[1177,5,1177,51,0],[1178,5,1178,28,0],[1179,5,1179,12,0],[1181,4,1181,28,0],[1182,4,1182,34,0],[1183,4,1183,5,0],[1184,5,1184,52,0],[1185,5,1185,29,0],[1186,5,1186,12,0],[1189,4,1189,24,0],[1190,4,1190,34,0],[1191,4,1191,5,0],[1192,5,1192,50,0],[1193,5,1193,27,0],[1194,5,1194,12,0],[1197,4,1197,26,0],[1198,4,1198,34,0],[1199,4,1199,5,0],[1200,5,1200,51,0],[1201,5,1201,28,0],[1202,5,1202,12,0],[1205,4,1205,28,0],[1206,4,1206,34,0],[1207,4,1207,5,0],[1208,5,1208,52,0],[1209,5,1209,29,0],[1210,5,1210,12,0],[1213,4,1213,24,0],[1214,4,1214,34,0],[1215,4,1215,5,0],[1216,5,1216,50,0],[1217,5,1217,27,0],[1218,5,1218,12,0],[1221,4,1221,24,0],[1222,4,1222,34,0],[1223,4,1223,5,0],[1224,5,1224,50,0],[1225,5,1225,27,0],[1226,5,1226,12,0],[1229,4,1229,45,0],[1230,4,1230,26,0],[1231,3,1231,4,0],[1237,3,1237,34,0],[1237,3,1237,34,0],[1238,3,1238,31,0],[1238,3,1238,31,0],[1240,3,1240,41,0],[1241,3,1241,4,0],[1242,4,1242,19,0],[1243,4,1243,17,0],[1244,3,1244,4,0],[1246,3,1246,54,0],[1247,3,1247,4,0],[1248,4,1248,19,0],[1249,4,1249,17,0],[1250,3,1250,4,0],[1253,3,1253,4,0],[1254,4,1254,22,0],[1255,4,1255,5,0],[1256,5,1256,22,0],[1257,4,1257,5,0],[1259,4,1259,5,0],[1260,5,1260,29,0],[1261,4,1261,5,0],[1262,4,1262,18,0],[1263,3,1263,4,0],[1268,4,1268,5,0],[1269,5,1269,38,0],[1270,4,1270,5,0],[1272,4,1272,5,0],[1273,5,1273,31,0],[1274,5,1274,20,0],[1275,5,1275,14,0],[1276,4,1276,5,0],[1282,4,1282,5,0],[1283,5,1283,44,0],[1284,4,1284,5,0],[1286,4,1286,5,0],[1287,5,1287,31,0],[1288,5,1288,26,0],[1289,5,1289,14,0],[1290,4,1290,5,0],[1294,3,1294,4,0],[1295,4,1295,30,0],[1296,4,1296,19,0],[1297,4,1297,13,0],[1298,3,1298,4,0],[1301,3,1301,4,0],[1302,4,1302,30,0],[1303,4,1303,25,0],[1304,4,1304,13,0],[1305,3,1305,4,0],[1308,3,1308,4,0],[1309,4,1309,18,0],[1310,5,1310,17,0],[1311,4,1311,47,0],[1312,3,1312,4,0],[1315,3,1315,4,0],[1316,4,1316,21,0],[1317,3,1317,4,0],[1320,3,1320,4,0],[1321,4,1321,20,0],[1322,5,1322,17,0],[1323,4,1323,52,0],[1324,3,1324,4,0],[1327,3,1327,4,0],[1328,4,1328,30,0],[1329,3,1329,4,0],[1332,3,1332,4,0],[1333,4,1333,14,0],[1334,3,1334,4,0],[1337,3,1337,4,0],[1338,4,1338,14,0],[1339,3,1339,4,0],[1342,3,1342,4,0],[1343,4,1343,14,0],[1344,3,1344,4,0],[1349,4,1349,5,0],[1350,5,1350,36,0],[1351,5,1351,14,0],[1352,5,1352,14,0],[1353,4,1353,5,0],[1355,4,1355,5,0],[1356,5,1356,40,0],[1357,5,1357,14,0],[1358,4,1358,5,0],[1364,4,1364,5,0],[1365,5,1365,39,0],[1366,5,1366,14,0],[1367,5,1367,17,0],[1368,4,1368,5,0],[1370,4,1370,5,0],[1371,5,1371,40,0],[1372,5,1372,14,0],[1373,4,1373,5,0],[1379,4,1379,5,0],[1380,5,1380,38,0],[1381,5,1381,14,0],[1382,5,1382,16,0],[1383,4,1383,5,0],[1385,4,1385,5,0],[1386,5,1386,40,0],[1387,5,1387,14,0],[1388,4,1388,5,0],[1394,4,1394,5,0],[1395,5,1395,42,0],[1396,5,1396,14,0],[1397,5,1397,14,0],[1398,4,1398,5,0],[1400,4,1400,5,0],[1401,5,1401,40,0],[1402,5,1402,14,0],[1403,4,1403,5,0],[1409,4,1409,5,0],[1410,5,1410,43,0],[1411,5,1411,14,0],[1412,5,1412,14,0],[1413,4,1413,5,0],[1415,4,1415,5,0],[1416,5,1416,40,0],[1417,5,1417,14,0],[1418,4,1418,5,0],[1424,4,1424,5,0],[1425,5,1425,44,0],[1426,5,1426,14,0],[1427,5,1427,14,0],[1428,4,1428,5,0],[1430,4,1430,5,0],[1431,5,1431,40,0],[1432,5,1432,14,0],[1433,4,1433,5,0],[1439,4,1439,5,0],[1440,5,1440,40,0],[1441,5,1441,14,0],[1442,5,1442,18,0],[1443,4,1443,5,0],[1445,4,1445,5,0],[1446,5,1446,40,0],[1447,5,1447,14,0],[1448,4,1448,5,0],[1454,4,1454,5,0],[1455,5,1455,37,0],[1456,5,1456,14,0],[1457,5,1457,16,0],[1458,4,1458,5,0],[1464,4,1464,5,0],[1465,5,1465,37,0],[1466,5,1466,14,0],[1467,5,1467,16,0],[1468,4,1468,5,0],[1476,3,1476,4,0],[1477,4,1477,33,0],[1478,3,1478,4,0]]);
    </script>
  </body>
</html>