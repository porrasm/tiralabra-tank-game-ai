<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>p:\stuff\projects\minigamesproject\minigamesproject\assets\_assets\scripts\games\tankgame\tankai\components\tankaimovement.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using System.Linq;

/// &lt;summary&gt;
/// Used to move a tank through a path.
/// &lt;/summary&gt;
public class TankAIMovement : TankAIComponent {

    #region fields
    private Vector[] path;
    private TankControls controls;

    private bool stuck;
    private float stuckTime;
    private Vector stuckPos;
    #endregion

    public TankAIMovement(TankAI ai) : base(ai) {
        controls = ai.GetComponent&lt;TankControls&gt;();
    }

    public override void Update() {

    }

    #region Traversal

    /// &lt;summary&gt;
    /// Starts to move the tank towards the end of the path
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;path&quot;&gt;&lt;/param&gt;
    public void TraversePath(Vector[] path) {

        TankPathVisualizer.DrawRoute(path);

        ai.StopCoroutine(TraversePathCoroutine());
        ai.StopCoroutine(RemoveStuck());

        this.path = path;
        ai.StartCoroutine(TraversePathCoroutine());
    }

    private IEnumerator TraversePathCoroutine() {

        int index = 0;

        while (index &lt; path.Length) {

            ResetStuck();

            Vector targetPos = path[index];

            while (!InCoords(index)) {

                StuckCheck();

                if (stuck) {
                    controls.ProcessControl(TankControls.Control.Movement, -1);
                } else {
                    MoveTowards(targetPos);
                }
                
                yield return null;
            }

            index++;
        }
    }

    /// &lt;summary&gt;
    /// Checks if the tank is stuck against a wall
    /// &lt;/summary&gt;
    private void StuckCheck() {

        if (stuck) {
            return;
        }

        if (Vector.Distance(stuckPos, Vector.FromVector3(ai.transform.position)) &lt; AISettings.StuckTresholdDistance) {
            stuckTime += Time.deltaTime;

            if (stuckTime &gt; AISettings.StuckTresholdTime) {
                stuck = true;
                ai.StartCoroutine(RemoveStuck());
            }
        } else {
            ResetStuck();
        }
    }
    private IEnumerator RemoveStuck() {

        float time = AISettings.StuckCooldown;

        while (time &gt; 0) {
            time -= Time.deltaTime;
            yield return null;
        }

        ResetStuck();
    }
    private void ResetStuck() {
        stuck = false;
        stuckTime = 0;
        stuckPos = Vector.FromVector3(ai.transform.position);
    }

    /// &lt;summary&gt;
    /// Checks if the tank has reached certain coordinates
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;i&quot;&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    private bool InCoords(int i) {

        Vector target = path[i];
        Vector current = Vector.FromVector3(ai.transform.position);

        return Vector.Distance(target, current) &lt; AISettings.DistanceLimit;
    }

    /// &lt;summary&gt;
    /// Moves the tank towards a position
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;position&quot;&gt;&lt;/param&gt;
    private void MoveTowards(Vector position) {

        TurnToPosition(position);

        Vector3 currentRotation = ai.transform.eulerAngles;
        Vector3 targetRotation = Quaternion.LookRotation(Vector.ToVector3(position) - ai.transform.position, Vector3.up).eulerAngles;

        if (Vector3.Angle(currentRotation, targetRotation) &lt; AISettings.MovementAngle) {
            controls.ProcessControl(TankControls.Control.Movement, 1);
        }
    }

    /// &lt;summary&gt;
    /// Turns the tank towards a position
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;position&quot;&gt;&lt;/param&gt;
    private void TurnToPosition(Vector position) {

        // Replace Quaternion.LookRotation
        Vector currentRotation = Vector.FromVector3(ai.transform.eulerAngles);
        Vector targetRotation = Vector.FromVector3(Quaternion.LookRotation(Vector.ToVector3(position) - ai.transform.position, Vector3.up).eulerAngles);

        float rotation = TurnDirection(currentRotation, targetRotation);
        controls.ProcessControl(TankControls.Control.Rotation, rotation);
    }

    /// &lt;summary&gt;
    /// Returns left (negative) or right (positive) based on how big an angle the tank will have to turn towards a certain position.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;current&quot;&gt;&lt;/param&gt;
    /// &lt;param name=&quot;target&quot;&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    private float TurnDirection(Vector current, Vector target) {


        // wtf does this do, found from internet
        int rotateDirection = (((target.y - current.y) + 360f) % 360f) &gt; 180.0f ? -1 : 1;

        float angleDif = (((target.y - current.y) + 360f) % 360f);

        float min = Maths.Min(Maths.Abs(angleDif), Maths.Abs(angleDif - 360));

        if (min &lt; AISettings.TurnAngleLimit) {

            float factor = min / AISettings.TurnAngleLimit;
            return factor * rotateDirection;
        } else {
            return rotateDirection;
        }
    }
    #endregion
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[20,40,20,48,0],[20,49,20,50,0],[21,9,21,52,0],[22,5,22,6,0],[24,35,24,36,0],[26,5,26,6,0],[34,45,34,46,0],[36,9,36,44,0],[38,9,38,51,0],[39,9,39,41,0],[41,9,41,26,0],[42,9,42,52,0],[43,5,43,6,0],[45,49,45,50,0],[47,9,47,23,0],[49,9,49,36,0],[49,37,49,38,0],[51,13,51,26,0],[53,13,53,44,0],[55,13,55,37,0],[55,38,55,39,0],[57,17,57,30,0],[59,17,59,27,0],[59,28,59,29,0],[60,21,60,80,0],[61,17,61,18,0],[61,24,61,25,0],[62,21,62,44,0],[63,17,63,18,0],[65,17,65,35,0],[66,13,66,14,0],[68,13,68,21,0],[69,9,69,10,0],[70,5,70,6,0],[75,31,75,32,0],[77,9,77,19,0],[77,20,77,21,0],[78,13,78,20,0],[81,9,81,117,0],[81,118,81,119,0],[82,13,82,41,0],[84,13,84,58,0],[84,59,84,60,0],[85,17,85,30,0],[86,17,86,50,0],[87,13,87,14,0],[88,9,88,10,0],[88,16,88,17,0],[89,13,89,26,0],[90,9,90,10,0],[91,5,91,6,0],[92,39,92,40,0],[94,9,94,47,0],[96,9,96,25,0],[96,26,96,27,0],[97,13,97,36,0],[98,13,98,31,0],[99,9,99,10,0],[101,9,101,22,0],[102,5,102,6,0],[103,31,103,32,0],[104,9,104,23,0],[105,9,105,23,0],[106,9,106,62,0],[107,5,107,6,0],[114,34,114,35,0],[116,9,116,33,0],[117,9,117,68,0],[119,9,119,76,0],[120,5,120,6,0],[126,47,126,48,0],[128,9,128,34,0],[130,9,130,60,0],[131,9,131,134,0],[133,9,133,87,0],[133,88,133,89,0],[134,13,134,71,0],[135,9,135,10,0],[136,5,136,6,0],[142,50,142,51,0],[145,9,145,79,0],[146,9,146,153,0],[148,9,148,73,0],[149,9,149,74,0],[150,5,150,6,0],[158,64,158,65,0],[162,9,162,90,0],[164,9,164,67,0],[166,9,166,79,0],[168,9,168,45,0],[168,46,168,47,0],[170,13,170,60,0],[171,13,171,45,0],[172,16,172,17,0],[173,13,173,36,0],[175,5,175,6,0]]);
    </script>
  </body>
</html>