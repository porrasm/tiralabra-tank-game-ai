<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>p:\stuff\projects\minigamesproject\minigamesproject\assets\_assets\scripts\bearded man studios\scripts\networking\forge\networking\udppacketcomposer.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
/*-----------------------------+-------------------------------\
|                                                              |
|                         !!!NOTICE!!!                         |
|                                                              |
|  These libraries are under heavy development so they are     |
|  subject to make many changes as development continues.      |
|  For this reason, the libraries may not be well commented.   |
|  THANK YOU for supporting forge with all your feedback       |
|  suggestions, bug reports and comments!                      |
|                                                              |
|                              - The Forge Team                |
|                                Bearded Man Studios, Inc.     |
|                                                              |
|  This source code, project files, and associated files are   |
|  copyrighted by Bearded Man Studios, Inc. (2012-2017) and    |
|  may not be redistributed without written permission.        |
|                                                              |
\------------------------------+------------------------------*/

using BeardedManStudios.Forge.Networking.Frame;
using BeardedManStudios.Threading;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;

namespace BeardedManStudios.Forge.Networking
{
	public class UDPPacketComposer : BasePacketComposer
    {
		/// &lt;summary&gt;
		/// A base for any composer based events
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;composer&quot;&gt;The composer that fired off the event&lt;/param&gt;
		public delegate void ComposerEvent(UDPPacketComposer composer);

		/// &lt;summary&gt;
		/// Occurs when this composer has completed all of its messaging tasks
		/// &lt;/summary&gt;
		public event ComposerEvent completed;

		/// &lt;summary&gt;
		/// The maximum size allowed for each packet
		/// &lt;/summary&gt;
		public const ushort PACKET_SIZE = 1200;

		/// &lt;summary&gt;
		/// A reference to the client worker that this composer belongs to
		/// &lt;/summary&gt;
		public BaseUDP ClientWorker { get; private set; }

		/// &lt;summary&gt;
		/// The target player in question that will be receiving this data
		/// &lt;/summary&gt;
		public NetworkingPlayer Player { get; private set; }

		/// &lt;summary&gt;
		/// If this message is reliable so that the object knows if it needs to attempt to resend packets
		/// &lt;/summary&gt;
		public bool Reliable { get; private set; }

		/// &lt;summary&gt;
		/// The list of packets that are to be resent if it is reliable, otherwise it is just the
		/// list of packets that is to be sent and forgotten about
		/// &lt;/summary&gt;
		public Dictionary&lt;int, UDPPacket&gt; PendingPackets { get; private set; }

		public UDPPacketComposer() { }

		public UDPPacketComposer(BaseUDP clientWorker, NetworkingPlayer player, FrameStream frame, bool reliable = false)
		{
#if DEEP_LOGGING
			Logging.BMSLog.Log(&quot;---------------------------\n&quot; + (new System.Diagnostics.StackTrace()).ToString() + &quot;\nUNIQUE ID: &quot; + frame.UniqueId.ToString() + &quot;\n---------------------------&quot;);
#endif

			Init(clientWorker, player, frame, reliable);
		}

		public void Init(BaseUDP clientWorker, NetworkingPlayer player, FrameStream frame, bool reliable = false)
		{
			ClientWorker = clientWorker;
			Player = player;
			Frame = frame;
			Reliable = reliable;

			Initialize();
		}

		/// &lt;summary&gt;
		/// Send the packet off to the recipient
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;data&quot;&gt;The packet data that is to be sent&lt;/param&gt;
		private void Send(byte[] data)
		{
			ClientWorker.Client.Send(data, data.Length, Player.IPEndPointHandle);
		}

		private void Initialize()
		{
			CreatePackets();

			// If this is a reliable message then we need to make sure to try and resend the message
			// at a given interval, later on this could be sent at the players last ping + time buffer
			if (Reliable)
			{
				// Make sure to register that this composer is to listen for completed packets to know
				// when each of the packets have been confirmed by the recipient
				ClientWorker.messageConfirmed += MessageConfirmed;

				Player.QueueComposer(this);
			}
			else
			{
				// Go through all of the packets that were created and send them out immediately
				Task.Queue(() =&gt;
				{
					lock (PendingPackets)
					{
						foreach (KeyValuePair&lt;int, UDPPacket&gt; kv in PendingPackets)
						{
							Send(kv.Value.rawBytes);

							ClientWorker.BandwidthOut += (ulong)kv.Value.rawBytes.Length;

							// Spread the packets apart by 1 ms to prevent any clobbering that may happen
							// on the socket layer for sending too much data
							Thread.Sleep(1);
						}
					}
					Cleanup();
				});
			}
		}

		/// &lt;summary&gt;
		/// Cleans up the thread, pending packets, and fires off any completion events
		/// &lt;/summary&gt;
		private void Cleanup()
		{
			lock (PendingPackets)
			{
				PendingPackets.Clear();
			}

			if (completed != null)
				completed(this);
		}

		/// &lt;summary&gt;
		/// Go through all of the data and compile it into separated packets based on the PACKET_SIZE
		/// &lt;/summary&gt;
		private void CreatePackets()
		{
			PendingPackets = new Dictionary&lt;int, UDPPacket&gt;();

			// Get all of the data that is available for this frame
			byte[] data = Frame.GetData(Reliable, Player);

			int byteIndex = 0, orderId = 0;

			byte[] trailer = new byte[9];

			Buffer.BlockCopy(BitConverter.GetBytes(Frame.GroupId), 0, trailer, 0, sizeof(int));

			if (Reliable)
				trailer[trailer.Length - 1] |= 0x1;

			do
			{
				int remainingPacketSize = data.Length - byteIndex + trailer.Length;
				bool endPacket = remainingPacketSize &lt;= PACKET_SIZE;
				int length = 0;

				// We need to add the time step to this packet if it is not the end
				if (!endPacket)
				{
					// We need to backtrack the length of the added timestamp
					length -= sizeof(ulong);
					remainingPacketSize += -length;
				}

				// Create the packet space in memory and assign it to the correct length
				byte[] packet = new byte[Math.Min(PACKET_SIZE, remainingPacketSize)];

				length += packet.Length - trailer.Length;

				// Copy the bytes from the source into the new packet
				Buffer.BlockCopy(data, byteIndex, packet, 0, length);

				// Make sure we count every byte so we end the loop correctly and also so we know
				// if this is the last packet in the sequence
				byteIndex += length;

				if (endPacket)
				{
					trailer[trailer.Length - 1] |= 0x2;

					// Add the receivers to the end header byte
					trailer[trailer.Length - 1] |= (byte)(((int)Frame.Receivers) &lt;&lt; 4);
				}
				else    // We need to copy the unique id into this message
					Buffer.BlockCopy(BitConverter.GetBytes(Frame.UniqueId), 0, packet, length, sizeof(ulong));

				// Set the order id for this packet in the trailer
				Buffer.BlockCopy(BitConverter.GetBytes(orderId), 0, trailer, sizeof(int), sizeof(int));

				// Copy the trailer to the end of the packet
				Buffer.BlockCopy(trailer, 0, packet, packet.Length - trailer.Length, trailer.Length);

				// Create and add the new packet to pending packets so that it can be sent out
				PendingPackets.Add(orderId, new UDPPacket(Reliable, endPacket, Frame.GroupId, orderId, Frame.UniqueId, packet, false, Frame.Receivers));
				orderId++;
			} while (byteIndex &lt; data.Length);
		}

		/// &lt;summary&gt;
		/// Go through all of the pending packets and resend them
		/// &lt;/summary&gt;
		public override void ResendPackets(ulong timestep, ref int counter)
		{
			lock (PendingPackets)
			{
				foreach (var key in PendingPackets.Keys.ToArray())
				{
					if (PendingPackets[key].LastSentTimestep + (ulong)Player.RoundTripLatency &gt; timestep)
						continue;

					if (counter &lt;= 0)
					{
						PendingPackets[key] = PendingPackets[key].UpdateTimestep(timestep);
						continue;
					}

					counter -= PendingPackets[key].rawBytes.Length;

					PendingPackets[key] = PendingPackets[key].DoingRetry(timestep);
					Send(PendingPackets[key].rawBytes);
					ClientWorker.BandwidthOut += (ulong)PendingPackets[key].rawBytes.Length;
				}
			}
		}

		/// &lt;summary&gt;
		/// This method is called when a packet is received and is a confirmation packet
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;packet&quot;&gt;The packet that was received&lt;/param&gt;
		private void MessageConfirmed(NetworkingPlayer player, UDPPacket packet)
		{
			// Check to make sure that this packet was sent from this group
			if (packet.groupId != Frame.GroupId)
				return;

			// Check to make sure that the packet was sent from this composer
			if (packet.uniqueId != Frame.UniqueId)
				return;

			if (player != Player)
				return;

			lock (PendingPackets)
			{
				UDPPacket foundPacket;

				// Check to see if we already received a confirmation for this packet
				if (!PendingPackets.TryGetValue(packet.orderId, out foundPacket))
					return;

				player.RoundTripLatency = (int)(player.Networker.Time.Timestep - foundPacket.LastSentTimestep);

				// Remove the packet from pending so that it isn&#39;t sent again
				PendingPackets.Remove(packet.orderId);

				// All of the messages have been successfully confirmed, so we can remove the event listener
				if (PendingPackets.Count == 0)
				{
					ClientWorker.messageConfirmed -= MessageConfirmed;

					Cleanup();
					Player.EnqueueComposerToRemove(packet.uniqueId);
				}
			}
		}
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[50,33,50,37,0],[50,38,50,50,0],[55,36,55,40,0],[55,41,55,53,0],[60,26,60,30,0],[60,31,60,43,0],[66,54,66,58,0],[66,59,66,71,0],[68,3,68,29,0],[68,30,68,31,0],[68,32,68,33,0],[70,3,70,116,0],[71,3,71,4,0],[76,4,76,48,0],[77,3,77,4,0],[80,3,80,4,0],[81,4,81,32,0],[82,4,82,20,0],[83,4,83,18,0],[84,4,84,24,0],[86,4,86,17,0],[87,3,87,4,0],[94,3,94,4,0],[95,4,95,73,0],[96,3,96,4,0],[99,3,99,4,0],[100,4,100,20,0],[104,4,104,17,0],[105,4,105,5,0],[108,5,108,55,0],[110,5,110,32,0],[111,4,111,5,0],[113,4,113,5,0],[115,5,116,5,0],[116,5,116,6,0],[116,6,117,6,0],[117,6,117,27,0],[117,27,118,6,0],[118,6,118,7,0],[118,7,119,7,0],[119,7,119,14,0],[119,14,119,16,0],[119,16,119,47,0],[119,47,119,48,0],[119,48,119,50,0],[119,50,119,51,0],[119,51,119,65,0],[119,65,120,7,0],[120,7,120,8,0],[120,8,121,8,0],[121,8,121,32,0],[121,32,123,8,0],[123,8,123,69,0],[123,69,127,8,0],[127,8,127,24,0],[127,24,128,7,0],[128,7,128,8,0],[128,8,129,6,0],[129,6,129,7,0],[129,7,130,6,0],[130,6,130,16,0],[130,16,131,5,0],[131,5,131,6,0],[131,6,131,8,0],[115,5,131,8,0],[132,4,132,5,0],[133,3,133,4,0],[139,3,139,4,0],[140,4,140,25,0],[141,4,141,5,0],[142,5,142,28,0],[143,4,143,5,0],[145,4,145,26,0],[146,5,146,21,0],[147,3,147,4,0],[153,3,153,4,0],[154,4,154,54,0],[157,4,157,50,0],[159,4,159,21,0],[159,23,159,34,0],[161,4,161,33,0],[163,4,163,87,0],[165,4,165,17,0],[166,5,166,40,0],[169,4,169,5,0],[170,5,170,72,0],[171,5,171,57,0],[172,5,172,20,0],[175,5,175,20,0],[176,5,176,6,0],[178,6,178,30,0],[179,6,179,37,0],[180,5,180,6,0],[183,5,183,74,0],[185,5,185,46,0],[188,5,188,58,0],[192,5,192,25,0],[194,5,194,19,0],[195,5,195,6,0],[196,6,196,41,0],[199,6,199,73,0],[200,5,200,6,0],[202,6,202,96,0],[205,5,205,92,0],[208,5,208,90,0],[211,5,211,141,0],[212,5,212,15,0],[213,4,213,5,0],[213,6,213,38,0],[214,3,214,4,0],[220,3,220,4,0],[221,4,221,25,0],[222,4,222,5,0],[223,5,223,12,0],[223,14,223,21,0],[223,22,223,24,0],[223,25,223,54,0],[224,5,224,6,0],[225,6,225,91,0],[226,7,226,16,0],[228,6,228,23,0],[229,6,229,7,0],[230,7,230,74,0],[231,7,231,16,0],[234,6,234,53,0],[236,6,236,69,0],[237,6,237,41,0],[238,6,238,78,0],[239,5,239,6,0],[240,4,240,5,0],[241,3,241,4,0],[248,3,248,4,0],[250,4,250,40,0],[251,5,251,12,0],[254,4,254,42,0],[255,5,255,12,0],[257,4,257,25,0],[258,5,258,12,0],[260,4,260,25,0],[261,4,261,5,0],[265,5,265,70,0],[266,6,266,13,0],[268,5,268,100,0],[271,5,271,43,0],[274,5,274,35,0],[275,5,275,6,0],[276,6,276,56,0],[278,6,278,16,0],[279,6,279,54,0],[280,5,280,6,0],[281,4,281,5,0],[282,3,282,4,0]]);
    </script>
  </body>
</html>