<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>p:\stuff\projects\minigamesproject\minigamesproject\assets\_assets\scripts\bearded man studios\scripts\networking\forge\datastore\cache.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
/*-----------------------------+-------------------------------\
|                                                              |
|                         !!!NOTICE!!!                         |
|                                                              |
|  These libraries are under heavy development so they are     |
|  subject to make many changes as development continues.      |
|  For this reason, the libraries may not be well commented.   |
|  THANK YOU for supporting forge with all your feedback       |
|  suggestions, bug reports and comments!                      |
|                                                              |
|                              - The Forge Team                |
|                                Bearded Man Studios, Inc.     |
|                                                              |
|  This source code, project files, and associated files are   |
|  copyrighted by Bearded Man Studios, Inc. (2012-2017) and    |
|  may not be redistributed without written permission.        |
|                                                              |
\------------------------------+------------------------------*/

using BeardedManStudios.Forge.Networking.Frame;
using System;
using System.Collections.Generic;

namespace BeardedManStudios.Forge.Networking.DataStore
{
	/// &lt;summary&gt;
	/// The main class for managing and communicating data from the server cache
	/// &lt;/summary&gt;
	/// &lt;remarks&gt;
	/// Cache is used to store any arbitrary data for your game, you can deposit supported data types to the server with a key, then access them again
	/// on any client by using the key to access the specific data stored. Cache.Set() and Cache.Request() being the two primary ways to use Cache.
	/// &lt;/remarks&gt;
	public class Cache
	{
		public const int DEFAULT_CACHE_SERVER_PORT = 15942;

		// Default expiry datetime for a cached object.
		private readonly DateTime maxDateTime = DateTime.MaxValue;

		/// &lt;summary&gt;
		/// The memory cache for the data
		/// &lt;/summary&gt;
		private Dictionary&lt;string, CachedObject&gt; memory = new Dictionary&lt;string, CachedObject&gt;();

		/// &lt;summary&gt;
		/// The main socket for communicating the cache back and forth
		/// &lt;/summary&gt;
		public NetWorker Socket { get; private set; }

		// TODO:  Possibly make this global
		/// &lt;summary&gt;
		/// The set of types that are allowed and a byte mapping to them
		/// &lt;/summary&gt;
		private static Dictionary&lt;byte, Type&gt; typeMap = new Dictionary&lt;byte, Type&gt;() {
			{ 0, typeof(byte) },
			{ 1, typeof(char) },
			{ 2, typeof(short) },
			{ 3, typeof(ushort) },
			{ 4, typeof(int) },
			{ 5, typeof(uint) },
			{ 6, typeof(long) },
			{ 7, typeof(ulong) },
			{ 8, typeof(bool) },
			{ 9, typeof(float) },
			{ 10, typeof(double) },
			{ 11, typeof(string) },
			{ 12, typeof(Vector) },/*
			{ 12, typeof(Vector2) },
			{ 13, typeof(Vector3) },
			{ 14, typeof(Vector4) },
			{ 15, typeof(Quaternion) },
			{ 16, typeof(Color) }*/
		};

		/// &lt;summary&gt;
		/// The current id that the callback stack is on
		/// &lt;/summary&gt;
		private int responseHookIncrementer = 0;

		/// &lt;summary&gt;
		/// The main callback stack for when requesting data
		/// &lt;/summary&gt;
		private Dictionary&lt;int, Action&lt;object&gt;&gt; responseHooks = new Dictionary&lt;int, Action&lt;object&gt;&gt;();

		public Cache(NetWorker socket)
		{
			Socket = socket;
			Socket.binaryMessageReceived += BinaryMessageReceived;
		}

		private void RemoveExpiredObjects()
		{
			foreach (KeyValuePair&lt;string, CachedObject&gt; entry in memory)
				if (entry.Value.IsExpired())
					memory.Remove(entry.Key);
		}

		/// &lt;summary&gt;
		/// Called when the network as interpreted that a cache message has been sent from the server
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;player&quot;&gt;The server&lt;/param&gt;
		/// &lt;param name=&quot;frame&quot;&gt;The data that was received&lt;/param&gt;
		private void BinaryMessageReceived(NetworkingPlayer player, Binary frame, NetWorker sender)
		{
			if (frame.GroupId != MessageGroupIds.CACHE)
				return;

			if (sender is IServer)
			{
				byte type = ObjectMapper.Instance.Map&lt;byte&gt;(frame.StreamData);
				int responseHookId = ObjectMapper.Instance.Map&lt;int&gt;(frame.StreamData);
				string key = ObjectMapper.Instance.Map&lt;string&gt;(frame.StreamData);

				object obj = Get(key);

				// TODO:  Let the client know it is null
				if (obj == null)
					return;

				BMSByte data = ObjectMapper.BMSByte(type, responseHookId, obj);

				Binary sendFrame = new Binary(sender.Time.Timestep, sender is TCPClient, data, Receivers.Target, MessageGroupIds.CACHE, sender is BaseTCP);

				if (sender is BaseTCP)
					((TCPServer)sender).Send(player.TcpClientHandle, sendFrame);
				else
					((UDPServer)sender).Send(player, sendFrame, true);
			}
			else
			{
				byte type = ObjectMapper.Instance.Map&lt;byte&gt;(frame.StreamData);
				int responseHookId = ObjectMapper.Instance.Map&lt;int&gt;(frame.StreamData);

				object obj = null;

				if (typeMap[type] == typeof(string))
					obj = ObjectMapper.Instance.Map&lt;string&gt;(frame.StreamData);
				/*else if (typeMap[type] == typeof(Vector2))
					obj = ObjectMapper.Map&lt;Vector2&gt;(stream);
				else if (typeMap[type] == typeof(Vector3))
					obj = ObjectMapper.Map&lt;Vector3&gt;(stream);
				else if (typeMap[type] == typeof(Vector4))
					obj = ObjectMapper.Map&lt;Vector4&gt;(stream);
				else if (typeMap[type] == typeof(Color))
					obj = ObjectMapper.Map&lt;Color&gt;(stream);
				else if (typeMap[type] == typeof(Quaternion))
					obj = ObjectMapper.Map&lt;Quaternion&gt;(stream);*/
				else
					obj = ObjectMapper.Instance.Map(typeMap[type], frame.StreamData);

				if (responseHooks.ContainsKey(responseHookId))
				{
					responseHooks[responseHookId](obj);
					responseHooks.Remove(responseHookId);
				}
			}
		}

		/// &lt;summary&gt;
		/// Get an object from cache
		/// &lt;/summary&gt;
		/// &lt;typeparam name=&quot;T&quot;&gt;The type of object to store&lt;/typeparam&gt;
		/// &lt;param name=&quot;key&quot;&gt;The name variable used for storing the desired object&lt;/param&gt;
		/// &lt;returns&gt;Return object from key otherwise return the default value of the type or null&lt;/returns&gt;
		private T Get&lt;T&gt;(string key)
		{
			if (!Socket.IsServer)
				return default(T);

			if (!memory.ContainsKey(key))
				return default(T);

			if (memory[key] is T)
				return (T)memory[key].Value;

			return default(T);
		}

		/// &lt;summary&gt;
		/// Used on the server to get an object at a given key from cache
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;key&quot;&gt;The key to be used in the dictionary lookup&lt;/param&gt;
		/// &lt;returns&gt;The object at the given key in cache otherwise null&lt;/returns&gt;
		private object Get(string key)
		{
			if (!Socket.IsServer)
				return null;

			if (memory.ContainsKey(key))
				return memory[key].Value;

			return null;
		}

		/// &lt;summary&gt;
		/// Get an object from cache
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;key&quot;&gt;The name variable used for storing the desired object&lt;/param&gt;
		/// &lt;returns&gt;The string data at the desired key or null&lt;/returns&gt;
		/// &lt;remarks&gt;
		/// Allows a client (or the server) to get a value from the Cache, the value is read directly from the server.
		/// A callback must be specified, this is because the code has to be executed after a moment when the response from the server
		/// is received. Request can be done like this:
		/// &lt;code&gt;
		/// void getServerDescription(){
		/// Cache.Request&lt;string&gt;(&quot;server_description&quot;, delegate (object response){
		///	 Debug.Log(((string) response));
		/// });
		/// }
		/// &lt;/code&gt;
		/// The Cache only supports Forge&#39;s supported data Types, you can find a list of supported data Types in the NetSync documentation...
		/// &lt;/remarks&gt;
		public void Request&lt;T&gt;(string key, Action&lt;object&gt; callback)
		{
			if (callback == null)
				throw new Exception(&quot;A callback is needed when requesting data from the server&quot;);

			if (Socket.IsServer)
			{
				callback(Get&lt;T&gt;(key));
				return;
			}

			responseHooks.Add(responseHookIncrementer, callback);

			byte targetType = byte.MaxValue;

			foreach (KeyValuePair&lt;byte, Type&gt; kv in typeMap)
			{
				if (typeof(T) == kv.Value)
				{
					targetType = kv.Key;
					break;
				}
			}

			if (targetType == byte.MaxValue)
				throw new Exception(&quot;Invalid type specified&quot;);

			BMSByte data = ObjectMapper.BMSByte(targetType, responseHookIncrementer, key);

			Binary sendFrame = new Binary(Socket.Time.Timestep, Socket is TCPClient, data, Receivers.Server, MessageGroupIds.CACHE, Socket is BaseTCP);

#if STEAMWORKS
            if (Socket is SteamP2PClient)
                ((SteamP2PClient)Socket).Send(sendFrame, true);
            else if (Socket is BaseTCP)
#else
            if (Socket is BaseTCP)
#endif
                ((TCPClient)Socket).Send(sendFrame);
			else
				((UDPClient)Socket).Send(sendFrame, true);

			responseHookIncrementer++;
		}


        /// &lt;summary&gt;
        /// Inserts a NEW key/value into cache
        /// &lt;/summary&gt;
        /// &lt;typeparam name=&quot;T&quot;&gt;The serializable type of object&lt;/typeparam&gt;
        /// &lt;param name=&quot;key&quot;&gt;The name variable used for storing the specified object&lt;/param&gt;
        /// &lt;param name=&quot;value&quot;&gt;The object that is to be stored into cache&lt;/param&gt;
        /// &lt;returns&gt;True if successful insert or False if the key already exists&lt;/returns&gt;
        public bool Insert&lt;T&gt;(string key, T value)
		{
			return Insert(key, value, maxDateTime);
		}

		/// &lt;summary&gt;
		/// Inserts a NEW key/value into cache
		/// &lt;/summary&gt;
		/// &lt;typeparam name=&quot;T&quot;&gt;The serializable type of object&lt;/typeparam&gt;
		/// &lt;param name=&quot;key&quot;&gt;The name variable used for storing the specified object&lt;/param&gt;
		/// &lt;param name=&quot;value&quot;&gt;The object that is to be stored into cache&lt;/param&gt;
		/// &lt;param name=&quot;expireAt&quot;&gt;The DateTime defining when the cached object should expire&lt;/param&gt;
		/// &lt;returns&gt;True if successful insert or False if the key already exists&lt;/returns&gt;
		public bool Insert&lt;T&gt;(string key, T value, DateTime expireAt)
		{
			if (!(Socket is IServer))
				throw new Exception(&quot;Inserting cache values is not yet supported for clients!&quot;);

			if (!memory.ContainsKey(key))
				return false;

			memory.Add(key, new CachedObject(value, expireAt));

			return true;
		}

		/// &lt;summary&gt;
		/// Inserts a new key/value or updates a key&#39;s value in cache
		/// &lt;/summary&gt;
		/// &lt;typeparam name=&quot;T&quot;&gt;The serializable type of object&lt;/typeparam&gt;
		/// &lt;param name=&quot;key&quot;&gt;The name variable used for storing the specified object&lt;/param&gt;
		/// &lt;param name=&quot;value&quot;&gt;The object that is to be stored into cache&lt;/param&gt;
		/// &lt;remarks&gt;
		/// This inputs a value into the cache, this can only be called on the server, you can only input Types forge supports (See NetSync for supported Types).
		/// &lt;/remarks&gt;
		public void Set&lt;T&gt;(string key, T value)
		{
			Set(key, value, maxDateTime);
		}

		/// &lt;summary&gt;
		/// Inserts a new key/value or updates a key&#39;s value in cache
		/// &lt;/summary&gt;
		/// &lt;typeparam name=&quot;T&quot;&gt;The serializable type of object&lt;/typeparam&gt;
		/// &lt;param name=&quot;key&quot;&gt;The name variable used for storing the specified object&lt;/param&gt;
		/// &lt;param name=&quot;value&quot;&gt;The object that is to be stored into cache&lt;/param&gt;
		/// &lt;param name=&quot;expireAt&quot;&gt;The DateTime defining when the cached object should expire&lt;/param&gt;
		public void Set&lt;T&gt;(string key, T value, DateTime expireAt)
		{
			if (!(Socket is IServer))
				throw new Exception(&quot;Setting cache values is not yet supported for clients!&quot;);

			var cachedObject = new CachedObject(value, expireAt);

			if (!memory.ContainsKey(key))
				memory.Add(key, cachedObject);
			else
				memory[key] = cachedObject;
		}

		/// &lt;summary&gt;
		/// CachedObject class.
		/// &lt;/summary&gt;
		public class CachedObject
		{
			public object Value { get; private set; }

			public DateTime ExpireAt { get; private set; }

			public CachedObject(object value, DateTime expireAt)
			{
				Value = value;
				ExpireAt = expireAt;
			}

			public bool IsExpired()
			{
				return DateTime.Now &gt;= ExpireAt;
			}
		}
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[38,3,38,61,0],[43,3,43,92,0],[48,29,48,33,0],[48,34,48,46,0],[54,3,73,5,0],[78,3,78,43,0],[83,3,83,97,0],[85,3,85,33,0],[86,3,86,4,0],[87,4,87,20,0],[88,4,88,58,0],[89,3,89,4,0],[92,3,92,4,0],[93,4,93,11,0],[93,13,93,53,0],[93,54,93,56,0],[93,57,93,63,0],[94,5,94,33,0],[95,6,95,31,0],[96,3,96,4,0],[104,3,104,4,0],[105,4,105,47,0],[106,5,106,12,0],[108,4,108,26,0],[109,4,109,5,0],[110,5,110,67,0],[111,5,111,75,0],[112,5,112,70,0],[114,5,114,27,0],[117,5,117,21,0],[118,6,118,13,0],[120,5,120,68,0],[122,5,122,144,0],[124,5,124,27,0],[125,6,125,66,0],[127,6,127,56,0],[128,4,128,5,0],[130,4,130,5,0],[131,5,131,67,0],[132,5,132,75,0],[134,5,134,23,0],[136,5,136,41,0],[137,6,137,64,0],[149,6,149,71,0],[151,5,151,51,0],[152,5,152,6,0],[153,6,153,41,0],[154,6,154,43,0],[155,5,155,6,0],[156,4,156,5,0],[157,3,157,4,0],[166,3,166,4,0],[167,4,167,25,0],[168,5,168,23,0],[170,4,170,33,0],[171,5,171,23,0],[173,4,173,25,0],[174,5,174,33,0],[176,4,176,22,0],[177,3,177,4,0],[185,3,185,4,0],[186,4,186,25,0],[187,5,187,17,0],[189,4,189,32,0],[190,5,190,30,0],[192,4,192,16,0],[193,3,193,4,0],[214,3,214,4,0],[215,4,215,25,0],[216,5,216,86,0],[218,4,218,24,0],[219,4,219,5,0],[220,5,220,27,0],[221,5,221,12,0],[224,4,224,57,0],[226,4,226,36,0],[228,4,228,11,0],[228,13,228,40,0],[228,41,228,43,0],[228,44,228,51,0],[229,4,229,5,0],[230,5,230,31,0],[231,5,231,6,0],[232,6,232,26,0],[233,6,233,12,0],[235,4,235,5,0],[237,4,237,36,0],[238,5,238,51,0],[240,4,240,82,0],[242,4,242,143,0],[249,13,249,35,0],[251,17,251,53,0],[253,5,253,47,0],[255,4,255,30,0],[256,3,256,4,0],[267,3,267,4,0],[268,4,268,43,0],[269,3,269,4,0],[280,3,280,4,0],[281,4,281,29,0],[282,5,282,85,0],[284,4,284,33,0],[285,5,285,18,0],[287,4,287,55,0],[289,4,289,16,0],[290,3,290,4,0],[302,3,302,4,0],[303,4,303,33,0],[304,3,304,4,0],[314,3,314,4,0],[315,4,315,29,0],[316,5,316,83,0],[318,4,318,57,0],[320,4,320,33,0],[321,5,321,35,0],[323,5,323,32,0],[324,3,324,4,0],[331,26,331,30,0],[331,31,331,43,0],[333,31,333,35,0],[333,36,333,48,0],[335,4,335,56,0],[336,4,336,5,0],[337,5,337,19,0],[338,5,338,25,0],[339,4,339,5,0],[342,4,342,5,0],[343,5,343,37,0],[344,4,344,5,0]]);
    </script>
  </body>
</html>