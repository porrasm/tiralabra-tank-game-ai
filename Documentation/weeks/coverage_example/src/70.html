<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>p:\stuff\projects\minigamesproject\minigamesproject\assets\_assets\scripts\bearded man studios\scripts\networking\forge\networking\cachedudpclient.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
//
// System.Net.Sockets.UdpClient.cs
//
// Author:
//	Gonzalo Paniagua Javier &lt;gonzalo@ximian.com&gt;
//	Sridhar Kulkarni (sridharkulkarni@gmail.com)
//	Marek Safar (marek.safar@gmail.com)
//
// Modified by:
//	Brent Farris (brent@beardedmangames.com)
//
// Copyright (C) Ximian, Inc. http://www.ximian.com
// Copyright 2011 Xamarin Inc.
//

//
// Permission is hereby granted, free of charge, to any person obtaining
// a copy of this software and associated documentation files (the
// &quot;Software&quot;), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to
// permit persons to whom the Software is furnished to do so, subject to
// the following conditions:
// 
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
// LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
// OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
// WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
//

#if !UNITY_WEBGL
#if !NetFX_CORE

using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;

namespace BeardedManStudios.Forge.Networking
{
	public class CachedUdpClient : IDisposable
	{
		public const char HOST_PORT_CHARACTER_SEPARATOR = &#39;+&#39;;
		private bool disposed = false;
		private bool active = false;
		private Socket socket;
		private AddressFamily family = AddressFamily.InterNetwork;
		private byte[] recvbuffer;

		public CachedUdpClient()
			: this(AddressFamily.InterNetwork)
		{
		}

		public CachedUdpClient(AddressFamily family)
		{
			if (family != AddressFamily.InterNetwork &amp;&amp; family != AddressFamily.InterNetworkV6)
				throw new ArgumentException(&quot;Family must be InterNetwork or InterNetworkV6&quot;, &quot;family&quot;);

			this.family = family;
			InitSocket(null);
		}

		public CachedUdpClient(int port)
		{
			if (port &lt; IPEndPoint.MinPort || port &gt; IPEndPoint.MaxPort)
				throw new ArgumentOutOfRangeException(&quot;port&quot;);

			this.family = AddressFamily.InterNetwork;

			IPEndPoint localEP = new IPEndPoint(IPAddress.Any, port);
			InitSocket(localEP);
		}

		public CachedUdpClient(IPEndPoint localEP)
		{
			if (localEP == null)
				throw new ArgumentNullException(&quot;localEP&quot;);

			this.family = localEP.AddressFamily;

			InitSocket(localEP);
		}

		public CachedUdpClient(int port, AddressFamily family)
		{
			if (family != AddressFamily.InterNetwork &amp;&amp; family != AddressFamily.InterNetworkV6)
				throw new ArgumentException(&quot;Family must be InterNetwork or InterNetworkV6&quot;, &quot;family&quot;);

			if (port &lt; IPEndPoint.MinPort ||
				port &gt; IPEndPoint.MaxPort)
			{
				throw new ArgumentOutOfRangeException(&quot;port&quot;);
			}

			this.family = family;

			IPEndPoint localEP;

			if (family == AddressFamily.InterNetwork)
				localEP = new IPEndPoint(IPAddress.Any, port);
			else
				localEP = new IPEndPoint(IPAddress.IPv6Any, port);
			InitSocket(localEP);
		}

		public CachedUdpClient(Socket targetSocket)
		{
			socket = targetSocket;
		}

		public CachedUdpClient(string hostname, int port)
		{
			if (hostname == null)
				throw new ArgumentNullException(&quot;hostname&quot;);

			if (port &lt; IPEndPoint.MinPort || port &gt; IPEndPoint.MaxPort)
				throw new ArgumentOutOfRangeException(&quot;port&quot;);

			InitSocket(null);
			Connect(hostname, port);
		}

		private void InitSocket(EndPoint localEP)
		{
			if (socket != null)
			{
				socket.Close();
				socket = null;
			}

			socket = new Socket(family, SocketType.Dgram, ProtocolType.Udp);

			if (localEP != null)
				socket.Bind(localEP);

			recBuffer.SetSize(65536);
		}

		#region Close
		public void Close()
		{
			((IDisposable)this).Dispose();
		}
		#endregion
		#region Connect

		void DoConnect(IPEndPoint endPoint)
		{
			/* Catch EACCES and turn on SO_BROADCAST then,
			 * as UDP Sockets don&#39;t have it set by default
			 */
			try
			{
				socket.Connect(endPoint);
			}
			catch (SocketException ex)
			{
				if (ex.ErrorCode == (int)SocketError.AccessDenied)
				{
					socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.Broadcast, 1);

					socket.Connect(endPoint);
				}
				else
				{
					throw;
				}
			}
		}

		public void Connect(IPEndPoint endPoint)
		{
			CheckDisposed();
			if (endPoint == null)
				throw new ArgumentNullException(&quot;endPoint&quot;);

			DoConnect(endPoint);
			active = true;
		}

		public void Connect(IPAddress addr, int port)
		{
			if (addr == null)
				throw new ArgumentNullException(&quot;addr&quot;);

			if (port &lt; IPEndPoint.MinPort || port &gt; IPEndPoint.MaxPort)
				throw new ArgumentOutOfRangeException(&quot;port&quot;);


			Connect(new IPEndPoint(addr, port));
		}

		public void Connect(string hostname, int port)
		{
			if (port &lt; IPEndPoint.MinPort || port &gt; IPEndPoint.MaxPort)
				throw new ArgumentOutOfRangeException(&quot;port&quot;);

			IPAddress[] addresses = Dns.GetHostAddresses(hostname);
			for (int i = 0; i &lt; addresses.Length; i++)
			{
				try
				{
					this.family = addresses[i].AddressFamily;
					Connect(new IPEndPoint(addresses[i], port));
					break;
				}
				catch (Exception e)
				{
					if (i == addresses.Length - 1)
					{
						if (socket != null)
						{
							socket.Close();
							socket = null;
						}
						/// This is the last entry, re-throw the exception
						throw e;
					}
				}
			}
		}
		#endregion
		#region Multicast methods
		public void DropMulticastGroup(IPAddress multicastAddr)
		{
			CheckDisposed();
			if (multicastAddr == null)
				throw new ArgumentNullException(&quot;multicastAddr&quot;);

			if (family == AddressFamily.InterNetwork)
				socket.SetSocketOption(SocketOptionLevel.IP, SocketOptionName.DropMembership,
					new MulticastOption(multicastAddr));
			else
				socket.SetSocketOption(SocketOptionLevel.IPv6, SocketOptionName.DropMembership,
					new IPv6MulticastOption(multicastAddr));
		}

		public void DropMulticastGroup(IPAddress multicastAddr,
			int ifindex)
		{
			CheckDisposed();

			/* LAMESPEC: exceptions haven&#39;t been specified
			 * for this overload.
			 */
			if (multicastAddr == null)
			{
				throw new ArgumentNullException(&quot;multicastAddr&quot;);
			}

			/* Does this overload only apply to IPv6?
			 * Only the IPv6MulticastOption has an
			 * ifindex-using constructor.  The MS docs
			 * don&#39;t say.
			 */
			if (family == AddressFamily.InterNetworkV6)
			{
				socket.SetSocketOption(SocketOptionLevel.IPv6, SocketOptionName.DropMembership, new IPv6MulticastOption(multicastAddr, ifindex));
			}
		}

		public void JoinMulticastGroup(IPAddress multicastAddr)
		{
			CheckDisposed();

			if (multicastAddr == null)
				throw new ArgumentNullException(&quot;multicastAddr&quot;);

			if (family == AddressFamily.InterNetwork)
				socket.SetSocketOption(SocketOptionLevel.IP, SocketOptionName.AddMembership,
					new MulticastOption(multicastAddr));
			else
				socket.SetSocketOption(SocketOptionLevel.IPv6, SocketOptionName.AddMembership,
					new IPv6MulticastOption(multicastAddr));
		}

		public void JoinMulticastGroup(int ifindex,
			IPAddress multicastAddr)
		{
			CheckDisposed();

			if (multicastAddr == null)
				throw new ArgumentNullException(&quot;multicastAddr&quot;);

			if (family == AddressFamily.InterNetworkV6)
				socket.SetSocketOption(SocketOptionLevel.IPv6, SocketOptionName.AddMembership, new IPv6MulticastOption(multicastAddr, ifindex));
			else
				throw new SocketException((int)SocketError.OperationNotSupported);
		}

		public void JoinMulticastGroup(IPAddress multicastAddr, int timeToLive)
		{
			CheckDisposed();
			if (multicastAddr == null)
				throw new ArgumentNullException(&quot;multicastAddr&quot;);
			if (timeToLive &lt; 0 || timeToLive &gt; 255)
				throw new ArgumentOutOfRangeException(&quot;timeToLive&quot;);

			JoinMulticastGroup(multicastAddr);
			if (family == AddressFamily.InterNetwork)
				socket.SetSocketOption(SocketOptionLevel.IP, SocketOptionName.MulticastTimeToLive,
					timeToLive);
			else
				socket.SetSocketOption(SocketOptionLevel.IPv6, SocketOptionName.MulticastTimeToLive,
					timeToLive);
		}

		public void JoinMulticastGroup(IPAddress multicastAddr,
			IPAddress localAddress)
		{
			CheckDisposed();

			if (family == AddressFamily.InterNetwork)
				socket.SetSocketOption(SocketOptionLevel.IP, SocketOptionName.AddMembership, new MulticastOption(multicastAddr, localAddress));
			else
				throw new SocketException((int)SocketError.OperationNotSupported);
		}

		#endregion
		#region Data I/O
		private BMSByte recBuffer = new BMSByte();
		private EndPoint endPoint = null;
		private Dictionary&lt;EndPoint, string&gt; connections = new Dictionary&lt;EndPoint, string&gt;();
		public BMSByte Receive(ref IPEndPoint remoteEP, ref string endpoint)
		{
			CheckDisposed();

			recBuffer.Clear();

			if (endPoint == null)
				endPoint = new IPEndPoint(IPAddress.Any, 0);

			int dataRead = socket.ReceiveFrom(recBuffer.byteArr, ref endPoint);

			if (!connections.ContainsKey(endPoint))
				connections.Add(endPoint, (((IPEndPoint)endPoint).Address.ToString() + HOST_PORT_CHARACTER_SEPARATOR + ((IPEndPoint)endPoint).Port.ToString()));

			endpoint = connections[endPoint];

			//if (dataRead &lt; recBuffer.Size)
			//	recBuffer = CutArray(recBuffer, dataRead);

			recBuffer.SetSize(dataRead);

			remoteEP = (IPEndPoint)endPoint;
			return recBuffer;
		}

		int DoSend(byte[] dgram, int bytes, IPEndPoint endPoint)
		{
			/* Catch EACCES and turn on SO_BROADCAST then,
			 * as UDP Sockets don&#39;t have it set by default
			 */
			try
			{
				if (endPoint == null)
				{
					return (socket.Send(dgram, 0, bytes,
						SocketFlags.None));
				}
				else
				{
					return (socket.SendTo(dgram, 0, bytes,
						SocketFlags.None,
						endPoint));
				}
			}
			catch (SocketException ex)
			{
				if (ex.ErrorCode == (int)SocketError.AccessDenied)
				{
					socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.Broadcast, 1);
					if (endPoint == null)
					{
						return (socket.Send(dgram, 0, bytes, SocketFlags.None));
					}
					else
					{
						return (socket.SendTo(dgram, 0, bytes, SocketFlags.None, endPoint));
					}
				}
				else
					throw new InvalidProgramException(ex.Message);
			}
		}

		public int Send(byte[] dgram, int bytes)
		{
			CheckDisposed();
			if (dgram == null)
				throw new ArgumentNullException(&quot;dgram&quot;);

			if (!active)
				throw new InvalidOperationException(&quot;Operation not allowed on &quot; +
					&quot;non-connected Sockets.&quot;);

			return (DoSend(dgram, bytes, null));
		}

		public int Send(byte[] dgram, int bytes, IPEndPoint endPoint)
		{
			CheckDisposed();
			if (dgram == null)
				throw new ArgumentNullException(&quot;dgram is null&quot;);

			if (active)
			{
				if (endPoint != null)
					throw new InvalidOperationException(&quot;Cannot send packets to an &quot; +
						&quot;arbitrary host while connected.&quot;);

				return (DoSend(dgram, bytes, null));
			}

			return (DoSend(dgram, bytes, endPoint));
		}

		public int Send(byte[] dgram, int bytes, string hostname, int port)
		{
			return Send(dgram, bytes,
				new IPEndPoint(Dns.GetHostAddresses(hostname)[0], port));
		}

		private byte[] CutArray(byte[] orig, int length)
		{
			byte[] newArray = new byte[length];
			Buffer.BlockCopy(orig, 0, newArray, 0, length);

			return newArray;
		}
		#endregion

		IAsyncResult DoBeginSend(byte[] datagram, int bytes,
			IPEndPoint endPoint,
			AsyncCallback requestCallback,
			object state)
		{
			/* Catch EACCES and turn on SO_BROADCAST then,
			 * as UDP Sockets don&#39;t have it set by default
			 */
			try
			{
				if (endPoint == null)
				{
					return (socket.BeginSend(datagram, 0, bytes, SocketFlags.None, requestCallback, state));
				}
				else
				{
					return (socket.BeginSendTo(datagram, 0, bytes, SocketFlags.None, endPoint, requestCallback, state));
				}
			}
			catch (SocketException ex)
			{
				if (ex.ErrorCode == (int)SocketError.AccessDenied)
				{
					socket.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.Broadcast, 1);
					if (endPoint == null)
					{
						return (socket.BeginSend(datagram, 0, bytes, SocketFlags.None, requestCallback, state));
					}
					else
					{
						return (socket.BeginSendTo(datagram, 0, bytes, SocketFlags.None, endPoint, requestCallback, state));
					}
				}
				else
				{
					throw;
				}
			}
		}

		public IAsyncResult BeginSend(byte[] datagram, int bytes,
			AsyncCallback requestCallback,
			object state)
		{
			return (BeginSend(datagram, bytes, null,
				requestCallback, state));
		}

		public IAsyncResult BeginSend(byte[] datagram, int bytes,
			IPEndPoint endPoint,
			AsyncCallback requestCallback,
			object state)
		{
			CheckDisposed();

			if (datagram == null)
			{
				throw new ArgumentNullException(&quot;datagram&quot;);
			}

			return (DoBeginSend(datagram, bytes, endPoint,
				requestCallback, state));
		}

		public IAsyncResult BeginSend(byte[] datagram, int bytes,
			string hostname, int port,
			AsyncCallback requestCallback,
			object state)
		{
			return (BeginSend(datagram, bytes, new IPEndPoint(Dns.GetHostAddresses(hostname)[0], port), requestCallback, state));
		}

		public int EndSend(IAsyncResult asyncResult)
		{
			CheckDisposed();

			if (asyncResult == null)
			{
				throw new ArgumentNullException(&quot;asyncResult is a null reference&quot;);
			}

			return (socket.EndSend(asyncResult));
		}

		public IAsyncResult BeginReceive(AsyncCallback requestCallback, object state)
		{
			CheckDisposed();

			recvbuffer = new byte[8192];

			EndPoint ep;

			if (family == AddressFamily.InterNetwork)
			{
				ep = new IPEndPoint(IPAddress.Any, 0);
			}
			else
			{
				ep = new IPEndPoint(IPAddress.IPv6Any, 0);
			}

			return (socket.BeginReceiveFrom(recvbuffer, 0, 8192,
				SocketFlags.None,
				ref ep,
				requestCallback, state));
		}

		public byte[] EndReceive(IAsyncResult asyncResult, ref IPEndPoint remoteEP)
		{
			CheckDisposed();

			if (asyncResult == null)
			{
				throw new ArgumentNullException(&quot;asyncResult is a null reference&quot;);
			}

			EndPoint ep;

			if (family == AddressFamily.InterNetwork)
			{
				ep = new IPEndPoint(IPAddress.Any, 0);
			}
			else
			{
				ep = new IPEndPoint(IPAddress.IPv6Any, 0);
			}

			int bytes = socket.EndReceiveFrom(asyncResult,
				ref ep);
			remoteEP = (IPEndPoint)ep;

			/* Need to copy into a new array here, because
			 * otherwise the returned array length is not
			 * &#39;bytes&#39;
			 */
			byte[] buf = new byte[bytes];
			Array.Copy(recvbuffer, buf, bytes);

			return (buf);
		}

		#region Properties
		protected bool Active
		{
			get { return active; }
			set { active = value; }
		}

		public Socket Client
		{
			get { return socket; }
			set { socket = value; }
		}

		public int Available
		{
			get
			{
				return (socket.Available);
			}
		}

		public bool DontFragment
		{
			get
			{
				return (socket.DontFragment);
			}
			set
			{
				socket.DontFragment = value;
			}
		}

		public bool EnableBroadcast
		{
			get
			{
				return (socket.EnableBroadcast);
			}
			set
			{
				socket.EnableBroadcast = value;
			}
		}

		public bool ExclusiveAddressUse
		{
			get
			{
				return (socket.ExclusiveAddressUse);
			}
			set
			{
				socket.ExclusiveAddressUse = value;
			}
		}

		public bool MulticastLoopback
		{
			get
			{
				return (socket.MulticastLoopback);
			}
			set
			{
				socket.MulticastLoopback = value;
			}
		}

		public short Ttl
		{
			get
			{
				return (socket.Ttl);
			}
			set
			{
				socket.Ttl = value;
			}
		}

		#endregion
		#region Disposing
		void IDisposable.Dispose()
		{
			Dispose(true);
			GC.SuppressFinalize(this);
		}

		protected virtual void Dispose(bool disposing)
		{
			if (disposed)
				return;
			disposed = true;

			if (disposing)
			{
				if (socket != null)
					socket.Close();

				socket = null;
			}
		}

		~CachedUdpClient()
		{
			Dispose(false);
		}

		private void CheckDisposed()
		{
			if (disposed)
				throw new ObjectDisposedException(GetType().FullName);
		}
		#endregion

#if Net_4_5

public Task&lt;UdpReceiveResult&gt; ReceiveAsync ()
{
return Task&lt;UdpReceiveResult&gt;.Factory.FromAsync (BeginReceive, r =&gt; {
IPEndPoint remoteEndPoint = null;
return new UdpReceiveResult (EndReceive (r, ref remoteEndPoint), remoteEndPoint);
}, null);
}

public Task&lt;int&gt; SendAsync (byte[] datagram, int bytes)
{
return Task&lt;int&gt;.Factory.FromAsync (BeginSend, EndSend, datagram, bytes, null);
}

public Task&lt;int&gt; SendAsync (byte[] datagram, int bytes, IPEndPoint endPoint)
{
return Task&lt;int&gt;.Factory.FromAsync (BeginSend, EndSend, datagram, bytes, endPoint, null);
}

public Task&lt;int&gt; SendAsync (byte[] datagram, int bytes, string hostname, int port)
{
var t = Tuple.Create (datagram, bytes, hostname, port, this);

return Task&lt;int&gt;.Factory.FromAsync ((callback, state) =&gt; {
var d = (Tuple&lt;byte[], int, string, int, UdpClient&gt;) state;
return d.Item5.BeginSend (d.Item1, d.Item2, d.Item3, d.Item4, callback, null);
}, EndSend, t);

}
#endif
	}
}

#endif
#endif
    </pre>
    <script type="text/javascript">
      highlightRanges([[50,3,50,33,0],[50,3,50,33,0],[50,3,50,33,0],[50,3,50,33,0],[50,3,50,33,0],[50,3,50,33,0],[51,3,51,31,0],[51,3,51,31,0],[51,3,51,31,0],[51,3,51,31,0],[51,3,51,31,0],[51,3,51,31,0],[53,3,53,61,0],[53,3,53,61,0],[53,3,53,61,0],[53,3,53,61,0],[53,3,53,61,0],[53,3,53,61,0],[57,6,57,38,0],[58,3,58,4,0],[59,3,59,4,0],[61,3,61,47,0],[62,3,62,4,0],[63,4,63,87,0],[64,5,64,92,0],[66,4,66,25,0],[67,4,67,21,0],[68,3,68,4,0],[70,3,70,35,0],[71,3,71,4,0],[72,4,72,63,0],[73,5,73,51,0],[75,4,75,45,0],[77,4,77,61,0],[78,4,78,24,0],[79,3,79,4,0],[81,3,81,45,0],[82,3,82,4,0],[83,4,83,24,0],[84,5,84,48,0],[86,4,86,40,0],[88,4,88,24,0],[89,3,89,4,0],[91,3,91,57,0],[92,3,92,4,0],[93,4,93,87,0],[94,5,94,92,0],[96,4,97,31,0],[98,4,98,5,0],[99,5,99,51,0],[102,4,102,25,0],[106,4,106,45,0],[107,5,107,51,0],[109,5,109,55,0],[110,4,110,24,0],[111,3,111,4,0],[113,3,113,46,0],[114,3,114,4,0],[115,4,115,26,0],[116,3,116,4,0],[118,3,118,52,0],[119,3,119,4,0],[120,4,120,25,0],[121,5,121,49,0],[123,4,123,63,0],[124,5,124,51,0],[126,4,126,21,0],[127,4,127,28,0],[128,3,128,4,0],[131,3,131,4,0],[132,4,132,23,0],[133,4,133,5,0],[134,5,134,20,0],[135,5,135,19,0],[136,4,136,5,0],[138,4,138,68,0],[140,4,140,24,0],[141,5,141,26,0],[143,4,143,29,0],[144,3,144,4,0],[148,3,148,4,0],[149,4,149,34,0],[150,3,150,4,0],[155,3,155,4,0],[160,4,160,5,0],[161,5,161,30,0],[162,4,162,5,0],[163,4,163,30,0],[164,4,164,5,0],[165,5,165,55,0],[166,5,166,6,0],[167,6,167,86,0],[169,6,169,31,0],[170,5,170,6,0],[172,5,172,6,0],[173,6,173,12,0],[175,4,175,5,0],[176,3,176,4,0],[179,3,179,4,0],[180,4,180,20,0],[181,4,181,25,0],[182,5,182,49,0],[184,4,184,24,0],[185,4,185,18,0],[186,3,186,4,0],[189,3,189,4,0],[190,4,190,21,0],[191,5,191,45,0],[193,4,193,63,0],[194,5,194,51,0],[197,4,197,40,0],[198,3,198,4,0],[201,3,201,4,0],[202,4,202,63,0],[203,5,203,51,0],[205,4,205,59,0],[206,9,206,18,0],[206,20,206,40,0],[206,42,206,45,0],[207,4,207,5,0],[209,5,209,6,0],[210,6,210,47,0],[211,6,211,50,0],[212,6,212,12,0],[214,5,214,24,0],[215,5,215,6,0],[216,6,216,36,0],[217,6,217,7,0],[218,7,218,26,0],[219,7,219,8,0],[220,8,220,23,0],[221,8,221,22,0],[222,7,222,8,0],[224,7,224,15,0],[226,5,226,6,0],[227,4,227,5,0],[228,3,228,4,0],[232,3,232,4,0],[233,4,233,20,0],[234,4,234,30,0],[235,5,235,54,0],[237,4,237,45,0],[238,5,239,42,0],[241,5,242,46,0],[243,3,243,4,0],[247,3,247,4,0],[248,4,248,20,0],[253,4,253,30,0],[254,4,254,5,0],[255,5,255,54,0],[263,4,263,47,0],[264,4,264,5,0],[265,5,265,134,0],[266,4,266,5,0],[267,3,267,4,0],[270,3,270,4,0],[271,4,271,20,0],[273,4,273,30,0],[274,5,274,54,0],[276,4,276,45,0],[277,5,278,42,0],[280,5,281,46,0],[282,3,282,4,0],[286,3,286,4,0],[287,4,287,20,0],[289,4,289,30,0],[290,5,290,54,0],[292,4,292,47,0],[293,5,293,133,0],[295,5,295,71,0],[296,3,296,4,0],[299,3,299,4,0],[300,4,300,20,0],[301,4,301,30,0],[302,5,302,54,0],[303,4,303,43,0],[304,5,304,57,0],[306,4,306,38,0],[307,4,307,45,0],[308,5,309,18,0],[311,5,312,18,0],[313,3,313,4,0],[317,3,317,4,0],[318,4,318,20,0],[320,4,320,45,0],[321,5,321,132,0],[323,5,323,71,0],[324,3,324,4,0],[328,3,328,45,0],[328,3,328,45,0],[328,3,328,45,0],[328,3,328,45,0],[328,3,328,45,0],[328,3,328,45,0],[329,3,329,36,0],[329,3,329,36,0],[329,3,329,36,0],[329,3,329,36,0],[329,3,329,36,0],[329,3,329,36,0],[330,3,330,89,0],[330,3,330,89,0],[330,3,330,89,0],[330,3,330,89,0],[330,3,330,89,0],[330,3,330,89,0],[332,3,332,4,0],[333,4,333,20,0],[335,4,335,22,0],[337,4,337,25,0],[338,5,338,49,0],[340,4,340,71,0],[342,4,342,43,0],[343,5,343,149,0],[345,4,345,37,0],[350,4,350,32,0],[352,4,352,36,0],[353,4,353,21,0],[354,3,354,4,0],[357,3,357,4,0],[362,4,362,5,0],[363,5,363,26,0],[364,5,364,6,0],[365,6,366,26,0],[369,5,369,6,0],[370,6,372,18,0],[375,4,375,30,0],[376,4,376,5,0],[377,5,377,55,0],[378,5,378,6,0],[379,6,379,86,0],[380,6,380,27,0],[381,6,381,7,0],[382,7,382,63,0],[385,6,385,7,0],[386,7,386,75,0],[390,6,390,52,0],[392,3,392,4,0],[395,3,395,4,0],[396,4,396,20,0],[397,4,397,22,0],[398,5,398,46,0],[400,4,400,16,0],[401,5,402,32,0],[404,4,404,40,0],[405,3,405,4,0],[408,3,408,4,0],[409,4,409,20,0],[410,4,410,22,0],[411,5,411,54,0],[413,4,413,15,0],[414,4,414,5,0],[415,5,415,26,0],[416,6,417,42,0],[419,5,419,41,0],[422,4,422,44,0],[423,3,423,4,0],[426,3,426,4,0],[427,4,428,62,0],[429,3,429,4,0],[432,3,432,4,0],[433,4,433,39,0],[434,4,434,51,0],[436,4,436,20,0],[437,3,437,4,0],[444,3,444,4,0],[449,4,449,5,0],[450,5,450,26,0],[451,5,451,6,0],[452,6,452,94,0],[455,5,455,6,0],[456,6,456,106,0],[459,4,459,30,0],[460,4,460,5,0],[461,5,461,55,0],[462,5,462,6,0],[463,6,463,86,0],[464,6,464,27,0],[465,6,465,7,0],[466,7,466,95,0],[469,6,469,7,0],[470,7,470,107,0],[474,5,474,6,0],[475,6,475,12,0],[478,3,478,4,0],[483,3,483,4,0],[484,4,485,30,0],[486,3,486,4,0],[492,3,492,4,0],[493,4,493,20,0],[495,4,495,25,0],[496,4,496,5,0],[497,5,497,49,0],[500,4,501,30,0],[502,3,502,4,0],[508,3,508,4,0],[509,4,509,121,0],[510,3,510,4,0],[513,3,513,4,0],[514,4,514,20,0],[516,4,516,28,0],[517,4,517,5,0],[518,5,518,72,0],[521,4,521,41,0],[522,3,522,4,0],[525,3,525,4,0],[526,4,526,20,0],[528,4,528,32,0],[532,4,532,45,0],[533,4,533,5,0],[534,5,534,43,0],[535,4,535,5,0],[537,4,537,5,0],[538,5,538,47,0],[539,4,539,5,0],[541,4,544,30,0],[545,3,545,4,0],[548,3,548,4,0],[549,4,549,20,0],[551,4,551,28,0],[552,4,552,5,0],[553,5,553,72,0],[558,4,558,45,0],[559,4,559,5,0],[560,5,560,43,0],[561,4,561,5,0],[563,4,563,5,0],[564,5,564,47,0],[565,4,565,5,0],[567,4,568,13,0],[569,4,569,30,0],[575,4,575,33,0],[576,4,576,39,0],[578,4,578,17,0],[579,3,579,4,0],[584,8,584,9,0],[584,10,584,24,0],[584,25,584,26,0],[585,8,585,9,0],[585,10,585,25,0],[585,26,585,27,0],[590,8,590,9,0],[590,10,590,24,0],[590,25,590,26,0],[591,8,591,9,0],[591,10,591,25,0],[591,26,591,27,0],[597,4,597,5,0],[598,5,598,31,0],[599,4,599,5,0],[605,4,605,5,0],[606,5,606,34,0],[607,4,607,5,0],[609,4,609,5,0],[610,5,610,33,0],[611,4,611,5,0],[617,4,617,5,0],[618,5,618,37,0],[619,4,619,5,0],[621,4,621,5,0],[622,5,622,36,0],[623,4,623,5,0],[629,4,629,5,0],[630,5,630,41,0],[631,4,631,5,0],[633,4,633,5,0],[634,5,634,40,0],[635,4,635,5,0],[641,4,641,5,0],[642,5,642,39,0],[643,4,643,5,0],[645,4,645,5,0],[646,5,646,38,0],[647,4,647,5,0],[653,4,653,5,0],[654,5,654,25,0],[655,4,655,5,0],[657,4,657,5,0],[658,5,658,24,0],[659,4,659,5,0],[665,3,665,4,0],[666,4,666,18,0],[667,4,667,30,0],[668,3,668,4,0],[671,3,671,4,0],[672,4,672,17,0],[673,5,673,12,0],[674,4,674,20,0],[676,4,676,18,0],[677,4,677,5,0],[678,5,678,24,0],[679,6,679,21,0],[681,5,681,19,0],[682,4,682,5,0],[683,3,683,4,0],[686,3,686,4,0],[686,3,686,4,0],[687,4,687,19,0],[688,3,688,4,0],[688,3,688,4,0],[691,3,691,4,0],[692,4,692,17,0],[693,5,693,59,0],[694,3,694,4,0]]);
    </script>
  </body>
</html>