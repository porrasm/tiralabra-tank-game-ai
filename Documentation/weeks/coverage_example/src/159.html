<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>p:\stuff\projects\minigamesproject\minigamesproject\assets\_assets\scripts\bearded man studios\scripts\networking\forge\networking\tcpclientwebsockets.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
/*-----------------------------+-------------------------------\
|                                                              |
|                         !!!NOTICE!!!                         |
|                                                              |
|  These libraries are under heavy development so they are     |
|  subject to make many changes as development continues.      |
|  For this reason, the libraries may not be well commented.   |
|  THANK YOU for supporting forge with all your feedback       |
|  suggestions, bug reports and comments!                      |
|                                                              |
|                              - The Forge Team                |
|                                Bearded Man Studios, Inc.     |
|                                                              |
|  This source code, project files, and associated files are   |
|  copyrighted by Bearded Man Studios, Inc. (2012-2017) and    |
|  may not be redistributed without written permission.        |
|                                                              |
\------------------------------+------------------------------*/

using BeardedManStudios.Forge.Networking.Frame;
using System;
using System.Runtime.InteropServices;

namespace BeardedManStudios.Forge.Networking
{
	public class TCPClientWebsockets : TCPClientBase
	{
        //TODO: Brent, figure out how to processor define this in a dll for unity
        // or we need to make 2 dlls, one with and one without this pre-processored defined out
        // This breaks iOS support because it cannot do [DllImport..]
#if !UNITY_IOS
		[DllImport(&quot;__Internal&quot;)]
		private static extern void ForgeConnect(string host, ushort port);

		[DllImport(&quot;__Internal&quot;)]
		private static extern void ForgeWrite(byte[] data, int length);

		[DllImport(&quot;__Internal&quot;)]
		private static extern IntPtr ForgeShiftDataRead();

		[DllImport(&quot;__Internal&quot;)]
		private static extern int ForgeContainsData();

		[DllImport(&quot;__Internal&quot;)]
		private static extern void ForgeClose();

		[DllImport(&quot;__Internal&quot;)]
		private static extern void ForgeLog(string data);

		[DllImport(&quot;__Internal&quot;)]
		private static extern bool CheckSocketConnection();

		public override void Connect(string host, ushort port = DEFAULT_PORT)
		{
			//Set the port
			SetPort(port);

			ForgeConnect(host, port);
		}

		public void CheckConnection()
		{
			if (!CheckSocketConnection())
				return;

			// This was a successful bind so fire the events for it
			OnBindSuccessful();

			// Setup the identity of the server as a player
			server = new NetworkingPlayer(0, null, true, null, this);
		}

		/// &lt;summary&gt;
		/// The direct byte send method to the specified client
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;client&quot;&gt;The target client that will receive the frame&lt;/param&gt;
		/// &lt;param name=&quot;frame&quot;&gt;The frame that is to be sent to the specified client&lt;/param&gt;
		public override void Send(FrameStream frame)
		{
			// Get the raw bytes from the frame and send them
			byte[] data = frame.GetData();

			ForgeWrite(data, data.Length);
		}

		public override void Disconnect(bool forced)
		{
			ForgeClose();

			// Send signals to the methods registered to the disconnec events
			if (!forced)
				OnDisconnected();
			else
				OnForcedDisconnect();

			for (int i = 0; i &lt; Players.Count; ++i)
				OnPlayerDisconnected(Players[i]);
		}

		public void UpdateStep()
		{
			if (!IsBound)
			{
				CheckConnection();
				return;
			}

			int length = ForgeContainsData();
			if (length == 0)
				return;

			IntPtr ptr = ForgeShiftDataRead();
			byte[] bytes = new byte[length];
			Marshal.Copy(ptr, bytes, 0, bytes.Length);

			if (bytes.Length &gt; 0)
			{
				byte messageType = 130;

				// Get the frame that was sent by the server, the server
				// does not send masked data, only the client so send false for mask
				FrameStream frame = Factory.ReadFrameStream(messageType, bytes, 0, MessageGroupIds.TCP_FIND_GROUP_ID, Server);

				// A message has been successfully read from the network so relay that
				// to all methods registered to the event
				OnMessageReceived(Server, frame);
			}
		}
#endif
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[54,3,54,4,0],[56,4,56,18,0],[58,4,58,29,0],[59,3,59,4,0],[62,3,62,4,0],[63,4,63,33,0],[64,5,64,12,0],[67,4,67,23,0],[70,4,70,61,0],[71,3,71,4,0],[79,3,79,4,0],[81,4,81,34,0],[83,4,83,34,0],[84,3,84,4,0],[87,3,87,4,0],[88,4,88,17,0],[91,4,91,16,0],[92,5,92,22,0],[94,5,94,26,0],[96,9,96,18,0],[96,20,96,37,0],[96,39,96,42,0],[97,5,97,38,0],[98,3,98,4,0],[101,3,101,4,0],[102,4,102,17,0],[103,4,103,5,0],[104,5,104,23,0],[105,5,105,12,0],[108,4,108,37,0],[109,4,109,20,0],[110,5,110,12,0],[112,4,112,38,0],[113,4,113,36,0],[114,4,114,46,0],[116,4,116,25,0],[117,4,117,5,0],[118,5,118,28,0],[122,5,122,115,0],[126,5,126,38,0],[127,4,127,5,0],[128,3,128,4,0]]);
    </script>
  </body>
</html>