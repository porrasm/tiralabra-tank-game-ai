<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>p:\stuff\projects\minigamesproject\minigamesproject\assets\_assets\scripts\bearded man studios\scripts\networking\forge\networking\websockets.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
/*-----------------------------+-------------------------------\
|                                                              |
|                         !!!NOTICE!!!                         |
|                                                              |
|  These libraries are under heavy development so they are     |
|  subject to make many changes as development continues.      |
|  For this reason, the libraries may not be well commented.   |
|  THANK YOU for supporting forge with all your feedback       |
|  suggestions, bug reports and comments!                      |
|                                                              |
|                              - The Forge Team                |
|                                Bearded Man Studios, Inc.     |
|                                                              |
|  This source code, project files, and associated files are   |
|  copyrighted by Bearded Man Studios, Inc. (2012-2017) and    |
|  may not be redistributed without written permission.        |
|                                                              |
\------------------------------+------------------------------*/

using System;
using System.Security.Cryptography;
using System.Text;
using System.Text.RegularExpressions;

namespace BeardedManStudios.Forge.Networking
{
	/// &lt;summary&gt;
	/// A static class of helper methods to setup and handle Websocket features
	/// &lt;/summary&gt;
	public static class Websockets
	{
		public static byte[] ConnectionHeader(string headerHash, ushort port)
		{
			// This is a typical Websockets accept header to be validated
			byte[] connectHeader = Encoding.UTF8.GetBytes(&quot;GET / HTTP/1.1\r\n&quot; +
				&quot;Host: http://developers.forgepowered.com:&quot; + port.ToString() + &quot;\r\n&quot; +
				&quot;Upgrade: websocket\r\n&quot; +
				&quot;Connection: Upgrade\r\n&quot; +
				&quot;Sec-WebSocket-Key: &quot; + headerHash + &quot;\r\n&quot; +
				&quot;Sec-WebSocket-Version: 13\r\n&quot; +
				&quot;\r\n&quot;); // HTTP/1.1 end of header fields

			return connectHeader;
		}

		public static bool ValidateResponseHeader(string headerHash, byte[] bytes)
		{
			// The first packet response from the server is going to be a string
			string tmp = Encoding.UTF8.GetString(bytes);
			string[] headers = tmp.Replace(&quot;\r&quot;, &quot;&quot;).Split(&#39;\n&#39;);

			// Improper header, so a disconnect is required
			if (headers.Length &lt; 4)
				return false;

			// Validate that the header sent by the server correctly lines
			// up with what the expected response
			if (headers[0] == &quot;HTTP/1.1 101 Switching Protocols&quot; &amp;&amp;
				headers[1] == &quot;Connection: Upgrade&quot; &amp;&amp;
				headers[2] == &quot;Upgrade: websocket&quot; &amp;&amp;
				headers[3].StartsWith(&quot;Sec-WebSocket-Accept: &quot;))
			{
				string hash = headers[3].Substring(headers[3].IndexOf(&#39; &#39;) + 1);
				if (hash == HeaderHashKeyCheck(headerHash))
					return true;
			}

			return false;
		}

		/// &lt;summary&gt;
		/// Check to see if a header is the correct websocket header, if so
		/// then generate a response to send back, otherwise return null
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;headers&quot;&gt;The sent headers that need to verified&lt;/param&gt;
		/// &lt;returns&gt;The response to be sent back, or null if failed validation&lt;/returns&gt;
		public static byte[] ValidateConnectionHeader(byte[] headers)
		{
			// The validation headers are always a string
			string data = Encoding.UTF8.GetString(headers);

			// Make sure that it starts as a GET request
			if (new Regex(&quot;^GET&quot;).IsMatch(data))
			{
				// Generate a response by hasing the provided random string key
				byte[] response = Encoding.UTF8.GetBytes(&quot;HTTP/1.1 101 Switching Protocols\r\n&quot;
					+ &quot;Connection: Upgrade\r\n&quot;
					+ &quot;Upgrade: websocket\r\n&quot;
					+ &quot;Sec-WebSocket-Accept: &quot; + Convert.ToBase64String((new SHA1CryptoServiceProvider()).ComputeHash(Encoding.UTF8.GetBytes(
						new Regex(&quot;Sec-WebSocket-Key: (.*)&quot;).Match(data).Groups[1].Value.Trim() + &quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot;
					))) + &quot;\r\n&quot;
					+ &quot;\r\n&quot;); // HTTP/1.1 end of header fields

				return response;
			}

			// Was not a GET request so failed
			return null;
		}

		/// &lt;summary&gt;
		/// Generate a random header hash key that is to be hashed by the server
		/// &lt;/summary&gt;
		/// &lt;returns&gt;The hash of a random string&lt;/returns&gt;
		public static string HeaderHashKey()
		{
			string headerHash = &quot;&quot;;
			Random rand = new Random();
			char[] availableChars = &quot;1234567890qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM&quot;.ToCharArray();

			// Generate a random string
			for (int i = 0; i &lt; 9; i++)
				headerHash += availableChars[rand.Next(0, availableChars.Length)];

			// Hash the string
			headerHash = Convert.ToBase64String((new SHA1CryptoServiceProvider()).ComputeHash(Encoding.UTF8.GetBytes(headerHash)));

			return headerHash;
		}

		/// &lt;summary&gt;
		/// Compare the hash with the provided Websockets code
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;data&quot;&gt;The hash that was generated by Websockets.HeaderHashKey&lt;/param&gt;
		/// &lt;returns&gt;Hashed string that is to be compared with the server&#39;s hash response&lt;/returns&gt;
		public static string HeaderHashKeyCheck(string data)
		{
			return Convert.ToBase64String((new SHA1CryptoServiceProvider()).ComputeHash(Encoding.UTF8.GetBytes(data + &quot;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&quot;)));
		}
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[33,3,33,4,0],[35,4,41,13,0],[43,4,43,25,0],[44,3,44,4,0],[47,3,47,4,0],[49,4,49,48,0],[50,4,50,57,0],[53,4,53,27,0],[54,5,54,18,0],[58,4,61,53,0],[62,4,62,5,0],[63,5,63,69,0],[64,5,64,48,0],[65,6,65,18,0],[66,4,66,5,0],[68,4,68,17,0],[69,3,69,4,0],[78,3,78,4,0],[80,4,80,51,0],[83,4,83,40,0],[84,4,84,5,0],[86,5,92,16,0],[94,5,94,21,0],[98,4,98,16,0],[99,3,99,4,0],[106,3,106,4,0],[107,4,107,27,0],[108,4,108,31,0],[109,4,109,107,0],[112,9,112,18,0],[112,20,112,25,0],[112,27,112,30,0],[113,5,113,71,0],[116,4,116,123,0],[118,4,118,22,0],[119,3,119,4,0],[127,3,127,4,0],[128,4,128,152,0],[129,3,129,4,0]]);
    </script>
  </body>
</html>