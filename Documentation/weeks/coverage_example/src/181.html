<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>p:\stuff\projects\minigamesproject\minigamesproject\assets\_assets\scripts\games\tankgame\tankai\datastructures\linkedprioritylist.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">

/// &lt;summary&gt;
/// Linked priority list. The type &lt;typeparamref name=&quot;T&quot;/&gt; with the lowest priority will always be the first one, and the one with the greates value will be the last one. Functionality is identical to a priority queue.
/// &lt;/summary&gt;
/// &lt;typeparam name=&quot;T&quot;&gt;&lt;/typeparam&gt;
public class LinkedPriorityList&lt;T&gt; {

    #region fields
    public int Count { get; private set; }

    private class Node&lt;T&gt; {

        public Node(T value, double priority, Node&lt;T&gt; next) {
            this.value = value;
            this.priority = priority;
            this.next = next;
        }

        public T value;
        public double priority;
        public Node&lt;T&gt; next;
    }

    private Node&lt;T&gt; first;
    #endregion

    public LinkedPriorityList() {
        Count = 0;
    }

    #region Adding
    /// &lt;summary&gt;
    /// Adds a new value of type &lt;typeparamref name=&quot;T&quot;/&gt; to the queue based on it&#39;s priority
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;nodeVal&quot;&gt;Value of type &lt;typeparamref name=&quot;T&quot;/&gt; to add&lt;/param&gt;
    /// &lt;param name=&quot;priority&quot;&gt;Priority of the value&lt;/param&gt;
    public void Add(T nodeVal, double priority) {

        if (Count == 0) {
            AddFirst(nodeVal, priority);
        } else if (priority &lt; first.priority) {
            ReplaceFirst(nodeVal, priority);
        } else {
            AddNew(nodeVal, priority);
        }

        Count++;
    }

    private void AddFirst(T nodeVal, double priority) {
        first = new Node&lt;T&gt;(nodeVal, priority, null);
    }
    private void ReplaceFirst(T nodeVal, double priority) {

        Node&lt;T&gt; next = first;
        AddFirst(nodeVal, priority);

        first.next = next;
    }
    private void AddAfter(Node&lt;T&gt; node, Node&lt;T&gt; newNode) {
        newNode.next = node.next;
        node.next = newNode;
    }

    private void AddNew(T nodeVal, double priority) {

        Node&lt;T&gt; node = first;
        Node&lt;T&gt; newNode = new Node&lt;T&gt;(nodeVal, priority, null);

        while (node.next != null) {

            if (priority &lt; node.next.priority) {
                AddAfter(node, newNode);
                return;
            }
            node = node.next;
        }

        node.next = newNode;
    }
    #endregion

    #region Getting
    /// &lt;summary&gt;
    /// Returns the first value
    /// &lt;/summary&gt;
    public T First {
        get {
            return first.value;
        }
    }

    /// &lt;summary&gt;
    /// Returns and removes the first value
    /// &lt;/summary&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public T Remove() {

        if (Count == 0) {
            throw new System.Exception(&quot;Queue is empty.&quot;);
        }

        T value = first.value;
        first = first.next;
        Count--;

        return value;
    }

    /// &lt;summary&gt;
    /// Returns an equal object from the list.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;value&quot;&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    public T Find(T value) {

        Node&lt;T&gt; node = first;

        for (int i = 0; i &lt; Count; i++) {
            if (node.value.Equals(value)) {
                return node.value;
            }
            node = node.next;
        }

        return default(T);
    }
    #endregion

    /// &lt;summary&gt;
    /// Clears the list
    /// &lt;/summary&gt;
    public void Clear() {
        first = null;
        Count = 0;
    }

    public bool Contains(T value) {

        Node&lt;T&gt; node = first;

        for (int i = 0; i &lt; Count; i++) {
            if (node.value.Equals(value)) {
                return true;
            }
            node = node.next;
        }

        return false;
    }

    /// &lt;summary&gt;
    /// Returns an array with all the type &lt;typeparamref name=&quot;T&quot;/&gt; values in the correct order.
    /// &lt;/summary&gt;
    /// &lt;returns&gt;Ordered array of type &lt;typeparamref name=&quot;T&quot;/&gt;&lt;/returns&gt;
    public T[] ToArray() {

        T[] array = new T[Count];

        Node&lt;T&gt; node = first;

        for (int i = 0; i &lt; Count; i++) {
            array[i] = node.value;
            node = node.next;
        }

        return array;
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[9,24,9,28,1],[9,29,9,41,1],[13,9,13,60,1],[13,61,13,62,1],[14,13,14,32,1],[15,13,15,38,1],[16,13,16,30,1],[17,9,17,10,1],[27,5,27,32,1],[27,33,27,34,1],[28,9,28,19,1],[29,5,29,6,1],[37,49,37,50,1],[39,9,39,24,1],[39,25,39,26,1],[40,13,40,41,1],[41,9,41,10,1],[41,16,41,46,1],[41,47,41,48,1],[42,13,42,45,1],[43,9,43,10,1],[43,16,43,17,1],[44,13,44,39,1],[45,9,45,10,1],[47,9,47,17,1],[48,5,48,6,1],[50,55,50,56,1],[51,9,51,54,1],[52,5,52,6,1],[53,59,53,60,1],[55,9,55,30,1],[56,9,56,37,1],[58,9,58,27,1],[59,5,59,6,1],[60,58,60,59,1],[61,9,61,34,1],[62,9,62,29,1],[63,5,63,6,1],[65,53,65,54,1],[67,9,67,30,1],[68,9,68,64,1],[70,9,70,34,1],[70,35,70,36,1],[72,13,72,47,1],[72,48,72,49,1],[73,17,73,41,1],[74,17,74,24,1],[76,13,76,30,1],[77,9,77,10,1],[79,9,79,29,1],[80,5,80,6,1],[88,13,88,14,1],[89,13,89,32,1],[90,9,90,10,1],[97,23,97,24,1],[99,9,99,24,1],[99,25,99,26,0],[100,13,100,59,0],[103,9,103,31,1],[104,9,104,28,1],[105,9,105,17,1],[107,9,107,22,1],[108,5,108,6,1],[115,28,115,29,1],[117,9,117,30,1],[119,14,119,23,1],[119,25,119,34,1],[119,36,119,39,1],[119,41,119,42,1],[120,13,120,42,1],[120,43,120,44,1],[121,17,121,35,1],[123,13,123,30,1],[124,9,124,10,1],[126,9,126,27,1],[127,5,127,6,1],[133,25,133,26,0],[134,9,134,22,0],[135,9,135,19,0],[136,5,136,6,0],[138,35,138,36,0],[140,9,140,30,0],[142,14,142,23,0],[142,25,142,34,0],[142,36,142,39,0],[142,41,142,42,0],[143,13,143,42,0],[143,43,143,44,0],[144,17,144,29,0],[146,13,146,30,0],[147,9,147,10,0],[149,9,149,22,0],[150,5,150,6,0],[156,26,156,27,0],[158,9,158,34,0],[160,9,160,30,0],[162,14,162,23,0],[162,25,162,34,0],[162,36,162,39,0],[162,41,162,42,0],[163,13,163,35,0],[164,13,164,30,0],[165,9,165,10,0],[167,9,167,22,0],[168,5,168,6,0]]);
    </script>
  </body>
</html>