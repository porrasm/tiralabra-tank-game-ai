<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>p:\stuff\projects\minigamesproject\minigamesproject\assets\_assets\scripts\bearded man studios\scripts\networking\forge\networking\basetcp.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System.Net.Sockets;
using System;

namespace BeardedManStudios.Forge.Networking
{
    // new BaseTCP as of September 2018
    public abstract class BaseTCP : NetWorker
    {
        protected BaseTCP() : base() { }
        protected BaseTCP(int maxConnections) : base(maxConnections) { }

        protected struct ReceiveToken
        {
            public NetworkingPlayer player;
            public int maxAllowedBytes;
            public int bytesReceived;
            public byte[] dataHolder;
            public ArraySegment&lt;byte&gt; internalBuffer;
        }

        private static readonly byte[] HEADER_DELIM = { 13, 10, 13, 10 }; // UTF-8 for \r\n\r\n i.e. CRLF CRLF, which appears after the last HTTP header field

        protected byte[] HandleHttpHeader(SocketAsyncEventArgs e, ref int bytesAlreadyProcessed)
        {
            if (bytesAlreadyProcessed &lt; 0)
                throw new ArgumentException(&quot;bytesAlreadyProcessed must be non-negative.&quot;);
            else if (bytesAlreadyProcessed &gt;= e.BytesTransferred)
                throw new ArgumentException(&quot;bytesAlreadyProcessed must be less than e.BytesTransferred.&quot;);

            ReceiveToken token = (ReceiveToken)e.UserToken;
            int totalBytes = token.bytesReceived + e.BytesTransferred - bytesAlreadyProcessed;
            if (totalBytes &gt;= 4)
            {
                int searchSpace = totalBytes - 3; // totalBytes - HEADER_DELIM.Length + 1
                byte[] data = token.internalBuffer.Array;
                for (int i = 0; i &lt; searchSpace; i++)
                {
                    if (HEADER_DELIM[0] == data[token.internalBuffer.Offset + i])
                    {
                        if (HEADER_DELIM[1] == data[token.internalBuffer.Offset + i + 1] &amp;&amp;
                            HEADER_DELIM[2] == data[token.internalBuffer.Offset + i + 2] &amp;&amp;
                            HEADER_DELIM[3] == data[token.internalBuffer.Offset + i + 3])
                        {
                            byte[] header = new byte[i + 4];
                            Buffer.BlockCopy(data, token.internalBuffer.Offset, header, 0, header.Length);
                            if (token.bytesReceived &gt; 0)
                            {
                                bytesAlreadyProcessed += header.Length - token.bytesReceived;
                                token.bytesReceived = 0;
                                e.SetBuffer(token.internalBuffer.Offset, token.internalBuffer.Count);
                            }
                            else
                            {
                                bytesAlreadyProcessed += header.Length;
                            }
                            if (header.Length &lt; totalBytes)
                            {
                                Buffer.BlockCopy(data, token.internalBuffer.Offset + header.Length, data, token.internalBuffer.Offset, totalBytes - header.Length);
                            }
                            e.UserToken = token;
                            return header;
                        }
                    }
                }
                if (totalBytes == token.internalBuffer.Count)
                    throw new Exception(String.Format(&quot;Could not find end of header within {0} bytes.&quot;, token.internalBuffer.Count));
            }

            token.bytesReceived = totalBytes;
            e.SetBuffer(token.internalBuffer.Offset + totalBytes, token.internalBuffer.Count - totalBytes);
            bytesAlreadyProcessed = e.BytesTransferred;
            e.UserToken = token;
            return null;
        }

        protected byte[] HandleData(SocketAsyncEventArgs e, bool isStream, ref int bytesAlreadyProcessed)
        {
            if (bytesAlreadyProcessed &lt; 0)
                throw new ArgumentException(&quot;bytesAlreadyProcessed must be non-negative.&quot;);
            else if (bytesAlreadyProcessed &gt;= e.BytesTransferred)
                throw new ArgumentException(&quot;bytesAlreadyProcessed must be less than e.BytesTransferred.&quot;);

            ReceiveToken token = (ReceiveToken)e.UserToken;
            int socketOffset = token.internalBuffer.Offset;
            byte[] bytes = token.internalBuffer.Array;
            int totalBytes;

            #region ParseFrameHeader
            if (token.dataHolder == null) // Null dataHolder means header not parsed yet
            {
                totalBytes = token.bytesReceived + e.BytesTransferred - bytesAlreadyProcessed;
                if (totalBytes &lt; 2) // Not enough bytes to determine length, so move offset
                {
                    token.bytesReceived = totalBytes;
                    e.SetBuffer(socketOffset + totalBytes, token.internalBuffer.Count - totalBytes);
                    bytesAlreadyProcessed = e.BytesTransferred;
                    e.UserToken = token;
                    return null;
                }
                int dataLength = bytes[socketOffset + 1] &amp; 127;
                bool usingMask = bytes[socketOffset + 1] &gt; 127; // same as bytes[socketOffset + 1] &amp; 128 != 0
                int payloadOffset;
                if (dataLength == 126) // 126 means 125 &lt; length &lt; 65536
                {
                    payloadOffset = 4;
                }
                else if (dataLength == 127)  // 127 means length &gt;= 65536
                {
                    payloadOffset = 10;
                }
                else
                {
                    payloadOffset = 2;
                }
                int length;
                if (payloadOffset != 2)
                {
                    if (totalBytes &lt; payloadOffset)  // Not enough bytes to determine length, so move offset
                    {
                        token.bytesReceived = totalBytes;
                        e.SetBuffer(socketOffset + totalBytes, token.internalBuffer.Count - totalBytes);
                        bytesAlreadyProcessed = e.BytesTransferred;
                        e.UserToken = token;
                        return null;
                    }

                    // Need to worry about endian order since length is in big endian
                    if (payloadOffset == 4)
                    {
                        if (BitConverter.IsLittleEndian)
                            length = BitConverter.ToUInt16(new byte[] { bytes[socketOffset + 3], bytes[socketOffset + 2] }, 0);
                        else
                            length = BitConverter.ToUInt16(bytes, socketOffset + 2);

                    }
                    else
                    {
                        // First 4 bytes will be 0 for sizes less than max int32
                        if (BitConverter.IsLittleEndian)
                            length = (int)BitConverter.ToUInt32(new byte[] { bytes[socketOffset + 9], bytes[socketOffset + 8], bytes[socketOffset + 7], bytes[socketOffset + 6] }, 0);
                        else
                            length = (int)BitConverter.ToUInt32(bytes, socketOffset + 6);
                    }

                    // Group id, receivers, time step, unique id, and router id lengths will be present in the payload length

                    //if (isStream)
                    //    length += 21;  // Group id (4), receivers (1), time step (8), unique id (8)
                    //if ((bytes[socketOffset + 0] &amp; 0xF) == (Binary.CONTROL_BYTE &amp; 0xF))
                    //    length += 1; // routerId (1) if this is a binary frame
                }
                else
                {
                    length = dataLength;
                }
                length += usingMask ? 4 + payloadOffset : payloadOffset; // Add full length of header to length
                if (length &lt; 0 || length &gt; token.maxAllowedBytes)
                    throw new UnauthorizedAccessException(String.Format(&quot;Tried to receive a frame larger than expected. Got {0}, and expected less than {1}&quot;, length, token.maxAllowedBytes));
                e.SetBuffer(token.internalBuffer.Offset, token.internalBuffer.Count);
                token.bytesReceived = 0;
                token.dataHolder = new byte[length];
            }
            #endregion

            totalBytes = token.bytesReceived + e.BytesTransferred - bytesAlreadyProcessed;
            if (totalBytes &lt; token.dataHolder.Length) // Full frame not yet received
            {
                Buffer.BlockCopy(bytes, socketOffset, token.dataHolder, token.bytesReceived, e.BytesTransferred - bytesAlreadyProcessed);
                token.bytesReceived += e.BytesTransferred - bytesAlreadyProcessed;
                bytesAlreadyProcessed = e.BytesTransferred;
                e.UserToken = token;
                return null;
            }
            else
            {
                byte[] data = token.dataHolder;
                int dataProcessed = (data.Length - token.bytesReceived);
                Buffer.BlockCopy(bytes, socketOffset, data, token.bytesReceived, dataProcessed);


                token.bytesReceived = 0;
                token.dataHolder = null;
                bytesAlreadyProcessed += dataProcessed;
                if (bytesAlreadyProcessed &lt; e.BytesTransferred) // More frames left to handle, so shuffle the remaining data to beginning of buffer.
                {
                    Buffer.BlockCopy(bytes, socketOffset + dataProcessed, bytes, socketOffset, e.BytesTransferred - bytesAlreadyProcessed);
                }
                e.UserToken = token;
                return data;
            }
        }

    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[9,31,9,37,0],[9,38,9,39,0],[9,40,9,41,0],[10,49,10,69,0],[10,70,10,71,0],[10,72,10,73,0],[21,9,21,74,0],[24,9,24,10,0],[25,13,25,43,0],[26,17,26,92,0],[27,18,27,66,0],[28,17,28,108,0],[30,13,30,60,0],[31,13,31,95,0],[32,13,32,33,0],[33,13,33,14,0],[34,17,34,50,0],[35,17,35,58,0],[36,22,36,31,0],[36,33,36,48,0],[36,50,36,53,0],[37,17,37,18,0],[38,21,38,82,0],[39,21,39,22,0],[40,25,42,90,0],[43,25,43,26,0],[44,29,44,61,0],[45,29,45,107,0],[46,29,46,57,0],[47,29,47,30,0],[48,33,48,94,0],[49,33,49,57,0],[50,33,50,102,0],[51,29,51,30,0],[53,29,53,30,0],[54,33,54,72,0],[55,29,55,30,0],[56,29,56,60,0],[57,29,57,30,0],[58,33,58,164,0],[59,29,59,30,0],[60,29,60,49,0],[61,29,61,43,0],[63,21,63,22,0],[64,17,64,18,0],[65,17,65,62,0],[66,21,66,134,0],[67,13,67,14,0],[69,13,69,46,0],[70,13,70,108,0],[71,13,71,56,0],[72,13,72,33,0],[73,13,73,25,0],[74,9,74,10,0],[77,9,77,10,0],[78,13,78,43,0],[79,17,79,92,0],[80,18,80,66,0],[81,17,81,108,0],[83,13,83,60,0],[84,13,84,60,0],[85,13,85,55,0],[89,13,89,42,0],[90,13,90,14,0],[91,17,91,95,0],[92,17,92,36,0],[93,17,93,18,0],[94,21,94,54,0],[95,21,95,101,0],[96,21,96,64,0],[97,21,97,41,0],[98,21,98,33,0],[100,17,100,64,0],[101,17,101,64,0],[103,17,103,39,0],[104,17,104,18,0],[105,21,105,39,0],[106,17,106,18,0],[107,22,107,44,0],[108,17,108,18,0],[109,21,109,40,0],[110,17,110,18,0],[112,17,112,18,0],[113,21,113,39,0],[114,17,114,18,0],[116,17,116,40,0],[117,17,117,18,0],[118,21,118,52,0],[119,21,119,22,0],[120,25,120,58,0],[121,25,121,105,0],[122,25,122,68,0],[123,25,123,45,0],[124,25,124,37,0],[128,21,128,44,0],[129,21,129,22,0],[130,25,130,57,0],[131,29,131,128,0],[133,29,133,85,0],[135,21,135,22,0],[137,21,137,22,0],[139,25,139,57,0],[140,29,140,183,0],[142,29,142,90,0],[143,21,143,22,0],[151,17,151,18,0],[153,17,153,18,0],[154,21,154,41,0],[155,17,155,18,0],[156,17,156,73,0],[157,17,157,66,0],[158,21,158,191,0],[159,17,159,86,0],[160,17,160,41,0],[161,17,161,53,0],[162,13,162,14,0],[165,13,165,91,0],[166,13,166,54,0],[167,13,167,14,0],[168,17,168,138,0],[169,17,169,83,0],[170,17,170,60,0],[171,17,171,37,0],[172,17,172,29,0],[175,13,175,14,0],[176,17,176,48,0],[177,17,177,73,0],[178,17,178,97,0],[181,17,181,41,0],[182,17,182,41,0],[183,17,183,56,0],[184,17,184,64,0],[185,17,185,18,0],[186,21,186,140,0],[187,17,187,18,0],[188,17,188,37,0],[189,17,189,29,0],[191,9,191,10,0]]);
    </script>
  </body>
</html>