<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>p:\stuff\projects\minigamesproject\minigamesproject\assets\_assets\scripts\bearded man studios\scripts\networking\forge\networking\tcpserver.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
/*-----------------------------+-------------------------------\
|                                                              |
|                         !!!NOTICE!!!                         |
|                                                              |
|  These libraries are under heavy development so they are     |
|  subject to make many changes as development continues.      |
|  For this reason, the libraries may not be well commented.   |
|  THANK YOU for supporting forge with all your feedback       |
|  suggestions, bug reports and comments!                      |
|                                                              |
|                              - The Forge Team                |
|                                Bearded Man Studios, Inc.     |
|                                                              |
|  This source code, project files, and associated files are   |
|  copyrighted by Bearded Man Studios, Inc. (2012-2017) and    |
|  may not be redistributed without written permission.        |
|                                                              |
\------------------------------+------------------------------*/

using BeardedManStudios.Forge.Networking.Frame;
using BeardedManStudios.Threading;
using System;
using System.Collections.Generic;
using System.Net;
using System.Linq;

#if WINDOWS_UWP
using Windows.Networking.Sockets;
using System.IO;
#else
using System.Net.Sockets;
#endif

namespace BeardedManStudios.Forge.Networking
{
    // new TCPServer as of September 2018
    /// &lt;summary&gt;
    /// This is the main TCP server object responsible for listening for incomming connections
    /// and reading any data sent from clients who are currently connected
    /// &lt;/summary&gt;
    public class TCPServer : BaseTCP, IServer
    {
        private CommonServerLogic commonServerLogic;

        #region Delegates
        /// &lt;summary&gt;
        /// A delegate for handling any raw TcpClient events
        /// &lt;/summary&gt;
#if WINDOWS_UWP
		public delegate void RawTcpClientEvent(StreamSocket client);
#else
        public delegate void RawTcpClientEvent(TcpClient client);
#endif
        #endregion

        #region Events
        /// &lt;summary&gt;
        /// Occurs when a raw TcpClient has successfully connected
        /// &lt;/summary&gt;
        public event RawTcpClientEvent rawClientConnected;

        /// &lt;summary&gt;
        /// Occurs when raw TcpClient has successfully connected
        /// &lt;/summary&gt;
        public event RawTcpClientEvent rawClientDisconnected;

        /// &lt;summary&gt;
        /// Occurs when raw TcpClient has been forcibly closed
        /// &lt;/summary&gt;
        public event RawTcpClientEvent rawClientForceClosed;
        #endregion

        /// &lt;summary&gt;
        /// The main listener for client connections
        /// &lt;/summary&gt;
#if WINDOWS_UWP
		private StreamSocketListener listener = null;
#else
        private TcpListener listener = null;
#endif

        /// &lt;summary&gt;
        /// The ip address that is being bound to
        /// &lt;/summary&gt;
        private IPAddress ipAddress = null;

        /// &lt;summary&gt;
        /// The main thread that will continuiously listen for new client connections
        /// &lt;/summary&gt;
        //private Thread connectionThread = null;

        /// &lt;summary&gt;
        /// The raw list of all of the clients that are connected
        /// &lt;/summary&gt;
#if WINDOWS_UWP
		private List&lt;StreamSocket&gt; rawClients = new List&lt;StreamSocket&gt;();
#else
        private List&lt;TcpClient&gt; rawClients = new List&lt;TcpClient&gt;();
#endif

        protected List&lt;FrameStream&gt; bufferedMessages = new List&lt;FrameStream&gt;();

        /// &lt;summary&gt;
        /// Used to determine if this server is currently accepting connections
        /// &lt;/summary&gt;
        public bool AcceptingConnections { get; private set; }

        public List&lt;string&gt; BannedAddresses { get; set; }

        private readonly BufferManager bufferManager;

        public TCPServer(int maxConnections) : base(maxConnections)
        {
            AcceptingConnections = true;
            BannedAddresses = new List&lt;string&gt;();
            commonServerLogic = new CommonServerLogic(this);
            if (maxConnections &gt; 128)
                bufferManager = new BufferManager(8192, 128, (maxConnections / 128) + 1);
            else
                bufferManager = new BufferManager(8192, maxConnections, 2);
        }

#if WINDOWS_UWP
		private void RawWrite(StreamSocket client, byte[] data)
#else
        private void RawWrite(TcpClient client, byte[] data)
#endif
        {
#if WINDOWS_UWP
			//Write data to the echo server.
			Stream streamOut = client.OutputStream.AsStreamForWrite();
			StreamWriter writer = new StreamWriter(streamOut);
			writer.Write(data);
			writer.Flush();
#else
            client.GetStream().Write(data, 0, data.Length);
#endif
        }

        /// &lt;summary&gt;
        /// The direct byte send method to the specified client
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;client&quot;&gt;The target client that will receive the frame&lt;/param&gt;
        /// &lt;param name=&quot;frame&quot;&gt;The frame that is to be sent to the specified client&lt;/param&gt;
#if WINDOWS_UWP
		public bool Send(StreamSocket client, FrameStream frame)
#else
        public bool Send(TcpClient client, FrameStream frame)
#endif
        {
            if (client == null)
                return false;

            // Make sure that we don&#39;t have any race conditions with writing to the same client
            lock (client)
            {
                try
                {
                    // Get the raw bytes from the frame and send them
                    byte[] data = frame.GetData();

                    RawWrite(client, data);
                    return true;
                }
                catch
                {
                    // The client is no longer connected or is unresponsive
                }
            }

            return false;
        }

        /// &lt;summary&gt;
        /// Sends binary message to the specific tcp client(s)
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;client&quot;&gt;The client to receive the message&lt;/param&gt;
        /// &lt;param name=&quot;receivers&quot;&gt;Receiver&#39;s type&lt;/param&gt;
        /// &lt;param name=&quot;messageGroupId&quot;&gt;The Binary.GroupId of the massage, use MessageGroupIds.START_OF_GENERIC_IDS + desired_id&lt;/param&gt;
        /// &lt;param name=&quot;objectsToSend&quot;&gt;Array of vars to be sent, read them with Binary.StreamData.GetBasicType&lt;typeOfObject&gt;()&lt;/param&gt;
        public bool Send(TcpClient client, Receivers receivers = Receivers.Target, int messageGroupId = MessageGroupIds.START_OF_GENERIC_IDS, params object[] objectsToSend)
        {
            BMSByte data = ObjectMapper.BMSByte(objectsToSend);
            Binary sendFrame = new Binary(Time.Timestep, false, data, Receivers.Target, messageGroupId, false);
#if WINDOWS_UWP
			public bool Send(StreamSocket client, FrameStream frame)
#else
            return Send(client, sendFrame);
#endif
        }

        /// &lt;summary&gt;
        /// Send a frame to a specific player
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;frame&quot;&gt;The frame to send to that specific player&lt;/param&gt;
        /// &lt;param name=&quot;targetPlayer&quot;&gt;The specific player to receive the frame&lt;/param&gt;
        public void SendToPlayer(FrameStream frame, NetworkingPlayer targetPlayer)
        {
            if (frame.Receivers == Receivers.AllBuffered || frame.Receivers == Receivers.OthersBuffered)
                bufferedMessages.Add(frame);

            lock (Players)
            {
                if (Players.Contains(targetPlayer))
                {
                    NetworkingPlayer player = Players[Players.IndexOf(targetPlayer)];
                    if (!player.Accepted &amp;&amp; !player.PendingAccepted)
                        return;

                    if (player == frame.Sender)
                    {
                        // Don&#39;t send a message to the sending player if it was meant for others
                        if (frame.Receivers == Receivers.Others || frame.Receivers == Receivers.OthersBuffered || frame.Receivers == Receivers.OthersProximity || frame.Receivers == Receivers.OthersProximityGrid)
                            return;
                    }

                    // Check to see if the request is based on proximity
                    if (frame.Receivers == Receivers.AllProximity || frame.Receivers == Receivers.OthersProximity)
                    {
                        // If the target player is not in the same proximity zone as the sender
                        // then it should not be sent to that player
                        if (player.ProximityLocation.DistanceSquared(frame.Sender.ProximityLocation) &gt; ProximityDistance * ProximityDistance)
                        {
                            return;
                        }
                    }

                    if (frame.Receivers == Receivers.AllProximityGrid || frame.Receivers == Receivers.OthersProximityGrid)
                    {
                        // If the target player is not in the same proximity zone as the sender
                        // then it should not be sent to that player
                        if (player.gridPosition.IsSameOrNeighbourCell(frame.Sender.gridPosition))
                        {
                            return;
                        }
                    }

                    try
                    {
                        Send(player.TcpClientHandle, frame);
                    }
                    catch
                    {
                        Disconnect(player, true);
                    }
                }
            }
        }

        /// &lt;summary&gt;
        /// Sends binary message to the specific client
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;receivers&quot;&gt;The clients / server to receive the message&lt;/param&gt;
        /// &lt;param name=&quot;messageGroupId&quot;&gt;The Binary.GroupId of the massage, use MessageGroupIds.START_OF_GENERIC_IDS + desired_id&lt;/param&gt;
        /// &lt;param name=&quot;targetPlayer&quot;&gt;The client to receive the message&lt;/param&gt;
        /// &lt;param name=&quot;objectsToSend&quot;&gt;Array of vars to be sent, read them with Binary.StreamData.GetBasicType&lt;typeOfObject&gt;()&lt;/param&gt;
        public void SendToPlayer(NetworkingPlayer targetPlayer, Receivers receivers = Receivers.Target, int messageGroupId = MessageGroupIds.START_OF_GENERIC_IDS, params object[] objectsToSend)
        {
            BMSByte data = ObjectMapper.BMSByte(objectsToSend);
            Binary sendFrame = new Binary(Time.Timestep, false, data, receivers, messageGroupId, false);
            SendToPlayer(sendFrame, targetPlayer);
        }

        /// &lt;summary&gt;
        /// Goes through all of the currently connected players and send them the frame
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;frame&quot;&gt;The frame to send to all of the connected players&lt;/param&gt;
        public void SendAll(FrameStream frame, NetworkingPlayer skipPlayer = null)
        {
            if (frame.Receivers == Receivers.AllBuffered || frame.Receivers == Receivers.OthersBuffered)
                bufferedMessages.Add(frame);

            lock (Players)
            {
                foreach (NetworkingPlayer player in Players)
                {
                    if (!commonServerLogic.PlayerIsReceiver(player, frame, ProximityDistance, skipPlayer, ProximityModeUpdateFrequency))
                        continue;

                    try
                    {
                        Send(player.TcpClientHandle, frame);
                    }
                    catch
                    {
                        Disconnect(player, true);
                    }
                }
            }
        }

        // overload for ncw field distance check case
        public void SendAll(FrameStream frame, NetworkingPlayer sender, NetworkingPlayer skipPlayer = null)
        {
            if (frame.Receivers == Receivers.AllBuffered || frame.Receivers == Receivers.OthersBuffered)
                bufferedMessages.Add(frame);
            lock (Players)
            {
                foreach (NetworkingPlayer player in Players)
                {
                    // check for distance here so the owner doesn&#39;t need to be sent in stream, used for NCW field proximity check
                    if (!commonServerLogic.PlayerIsDistanceReceiver(sender, player, frame, ProximityDistance, ProximityModeUpdateFrequency))
                        continue;
                    if (!commonServerLogic.PlayerIsReceiver(player, frame, ProximityDistance, skipPlayer, ProximityModeUpdateFrequency))
                        continue;
                    try
                    {
                        Send(player.TcpClientHandle, frame);
                    } catch
                    {
                        Disconnect(player, true);
                    }
                }
            }
        }

        /// &lt;summary&gt;
        /// Goes through all of the currently connected players and send them the frame
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;receivers&quot;&gt;The clients / server to receive the message&lt;/param&gt;
        /// &lt;param name=&quot;messageGroupId&quot;&gt;The Binary.GroupId of the massage, use MessageGroupIds.START_OF_GENERIC_IDS + desired_id&lt;/param&gt;
        /// &lt;param name=&quot;playerToIgnore&quot;&gt;The client to ignore&lt;/param&gt;
        /// &lt;param name=&quot;objectsToSend&quot;&gt;Array of vars to be sent, read them with Binary.StreamData.GetBasicType&lt;typeOfObject&gt;()&lt;/param&gt;
        public void SendAll(Receivers receivers = Receivers.All, int messageGroupId = MessageGroupIds.START_OF_GENERIC_IDS, NetworkingPlayer playerToIgnore = null, params object[] objectsToSend)
        {
            BMSByte data = ObjectMapper.BMSByte(objectsToSend);
            Binary sendFrame = new Binary(Time.Timestep, false, data, receivers, messageGroupId, true);
            SendAll(sendFrame, playerToIgnore);
        }

        /// &lt;summary&gt;
        /// Call the base disconnect pending method to remove all pending disconnecting clients
        /// &lt;/summary&gt;
        private void CleanupDisconnections() { DisconnectPending(RemovePlayer); }

        private bool PendingCommitDisconnects = false;

        /// &lt;summary&gt;
        /// Commits the disconnects
        /// &lt;/summary&gt;
        public void CommitDisconnects() { CleanupDisconnections(); }

        /// &lt;summary&gt;
        /// This will begin the connection for TCP, this is a thread blocking operation until the connection
        /// is either established or has failed
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;hostAddress&quot;&gt;[127.0.0.1] Ip Address to host from&lt;/param&gt;
        /// &lt;param name=&quot;port&quot;&gt;[15937] Port to allow connections from&lt;/param&gt;
        public void Connect(string hostAddress = &quot;0.0.0.0&quot;, ushort port = DEFAULT_PORT)
        {
            if (Disposed)
                throw new ObjectDisposedException(&quot;TCPServer&quot;, &quot;This object has been disposed and can not be used to connect, please use a new ETCPServer&quot;);

            if (string.IsNullOrEmpty(hostAddress))
                throw new BaseNetworkException(&quot;An ip address must be specified to bind to. If you are unsure, you can set to 127.0.0.1&quot;);

            // Check to see if this server is being bound to a &quot;loopback&quot; address, if so then bind to any, otherwise bind to specified address
            if (hostAddress == &quot;0.0.0.0&quot; || hostAddress == &quot;localhost&quot;)
                ipAddress = IPAddress.Any;
            else
                ipAddress = IPAddress.Parse(hostAddress);

            try
            {
                // Setup and start the base C# TcpListner
                listener = new TcpListener(ipAddress, port);
                //listener.Start();

                Me = new NetworkingPlayer(ServerPlayerCounter++, &quot;0.0.0.0&quot;, true, listener, this);
                Me.InstanceGuid = InstanceGuid.ToString();

                // Create the thread that will be listening for clients and start its execution
                //Thread connectionThread = new Thread(new ThreadStart(ListenForConnections));
                //connectionThread.Start();
                //Task.Queue(ListenForConnections);
                listener.Start();
                listener.BeginAcceptTcpClient(ListenForConnections, listener);

                // Do any generic initialization in result of the successful bind
                OnBindSuccessful();

                // Create the thread that will be listening for new data from connected clients and start its execution
                //TODO: Task.Queue(ReadClients);

                // Remove client timeouts since TCP knows when the connection has been closed.
                //// Create the thread that will check for player timeouts
                //Task.Queue(() =&gt;
                //{
                //    commonServerLogic.CheckClientTimeout((player) =&gt;
                //    {
                //        Disconnect(player, true);
                //        OnPlayerTimeout(player);
                //        CleanupDisconnections();
                //    });
                //});

                //Let myself know I connected successfully
                OnPlayerConnected(Me);
                // Set myself as a connected client
                Me.Connected = true;

                //Set the port
                SetPort((ushort)((IPEndPoint)listener.LocalEndpoint).Port);
            }
            catch (Exception e)
            {
                Logging.BMSLog.LogException(e);
                // Do any generic initialization in result of the binding failure
                OnBindFailure();

                throw new FailedBindingException(&quot;Failed to bind to host/port, see inner exception&quot;, e);
            }
        }

        /// &lt;summary&gt;
        /// Infinite loop listening for client connections on a separate thread.
        /// This loop breaks if there is an exception thrown on the blocking accept call
        /// &lt;/summary&gt;
        private void ListenForConnections(IAsyncResult obj)
        {
            TcpListener asyncListener = (TcpListener)obj.AsyncState;
            TcpClient client = null;

            try
            {
                client = asyncListener.EndAcceptTcpClient(obj);
            }
            catch
            {
                return;
            }

            asyncListener.BeginAcceptTcpClient(ListenForConnections, asyncListener);

            if (rawClients.Count == MaxConnections)
            {
                // Tell the client why they are being disconnected
                Send(client, Error.CreateErrorMessage(Time.Timestep, &quot;Max Players Reached On Server&quot;, false, MessageGroupIds.MAX_CONNECTIONS, true));

                // Send the close connection frame to the client
                Send(client, new ConnectionClose(Time.Timestep, false, Receivers.Target, MessageGroupIds.DISCONNECT, true));

                // Do disconnect logic for client
                ClientRejected(client, false);
                return;
            }
            else if (!AcceptingConnections)
            {
                // Tell the client why they are being disconnected
                Send(client, Error.CreateErrorMessage(Time.Timestep, &quot;The server is busy and not accepting connections&quot;, false, MessageGroupIds.MAX_CONNECTIONS, true));

                // Send the close connection frame to the client
                Send(client, new ConnectionClose(Time.Timestep, false, Receivers.Target, MessageGroupIds.DISCONNECT, true));

                // Do disconnect logic for client
                ClientRejected(client, false);
                return;
            }

            ArraySegment&lt;byte&gt; segment;
            if (!bufferManager.TryTakeBuffer(out segment))
            {
                // Tell the client why they are being disconnected
                Send(client, Error.CreateErrorMessage(Time.Timestep, &quot;The server is busy and not accepting connections&quot;, false, MessageGroupIds.MAX_CONNECTIONS, true));

                // Send the close connection frame to the client
                Send(client, new ConnectionClose(Time.Timestep, false, Receivers.Target, MessageGroupIds.DISCONNECT, true));

                // Do disconnect logic for client
                ClientRejected(client, false);
                throw new OutOfMemoryException(&quot;Buffer manager has run out of allocated memory (possible memory leak).&quot;);
            }

            // Clients will be looped through on other threads so be sure to lock it before adding
            ReceiveToken token;
            lock (Players)
            {
                rawClients.Add(client);

                // Create the identity wrapper for this player
                NetworkingPlayer player = new NetworkingPlayer(ServerPlayerCounter++, ((IPEndPoint)client.Client.RemoteEndPoint).Address.ToString(), false, client, this);

                // Generically add the player and fire off the events attached to player joining
                OnPlayerConnected(player);

                token = new ReceiveToken
                {
                    internalBuffer = segment,
                    player = player,
                    bytesReceived = 0,
                    dataHolder = null,
                    maxAllowedBytes = 8192
                };
            }

            // Let all of the event listeners know that the client has successfully connected
            if (rawClientConnected != null)
                rawClientConnected(client);

            SocketAsyncEventArgs e = new SocketAsyncEventArgs();
            e.Completed += new EventHandler&lt;SocketAsyncEventArgs&gt;(ReceiveAsync_Completed);
            e.UserToken = token;
            e.SetBuffer(token.internalBuffer.Array, token.internalBuffer.Offset, token.internalBuffer.Count);

            if (!client.Client.ReceiveAsync(e))
                Task.Queue(() =&gt; ReceiveAsync_Completed(this, e));


        }

        private void DoRead(SocketAsyncEventArgs e)
        {
            if (!IsBound)
            {
                ReturnBuffer(e);
                return;
            }

            ReceiveToken token = (ReceiveToken)e.UserToken;
            Socket playerSocket = null;
            try
            {
                // Try to get the client stream if it is still available
                playerSocket = token.player.TcpClientHandle.Client;
            }
            catch
            {
                // Failed to get the stream for the client so forcefully disconnect it
                //Console.WriteLine(&quot;Exception: Failed to get stream for client (Forcefully disconnecting)&quot;);
                Disconnect(token.player, true);
                ReturnBuffer(e);
                return;
            }

            // If the player is no longer connected, then make sure to disconnect it properly
            if (!token.player.TcpClientHandle.Connected)
            {
                Disconnect(token.player, false);
                ReturnBuffer(e);
                return;
            }

            // False means operation was synchronous (usually error)
            if (!playerSocket.ReceiveAsync(e))
                ReceiveAsync_Completed(this, e);
        }

        private void ReceiveAsync_Completed(object sender, SocketAsyncEventArgs e)
        {
            if (e.BytesTransferred &gt; 0 &amp;&amp; e.SocketError == SocketError.Success)
            {
                int bytesAlreadyProcessed = 0;
                ReceiveToken token = (ReceiveToken)e.UserToken;
                if (!token.player.Accepted &amp;&amp; !token.player.Connected)
                {
                    byte[] header = HandleHttpHeader(e, ref bytesAlreadyProcessed);
                    if (header == null)
                    {
                        DoRead(e);
                        return;
                    }
                    byte[] response = Websockets.ValidateConnectionHeader(header);

                    // The response will be null if the header sent is invalid, if so then disconnect client as they are sending invalid headers
                    if (response == null)
                    {
                        OnPlayerRejected(token.player);
                        Disconnect(token.player, true);
                        ReturnBuffer(e);
                        return;
                    }

                    // If all is in order then send the validated response to the client
                    token.player.TcpClientHandle.GetStream().Write(response, 0, response.Length);

                    // The player has successfully connected
                    token.player.Connected = true;
                }
                while (bytesAlreadyProcessed &lt; e.BytesTransferred)
                {
                    byte[] data = HandleData(e, true, ref bytesAlreadyProcessed);
                    if (data == null)
                    {
                        break;
                    }
                    FrameStream frame = Factory.DecodeMessage(data, true, MessageGroupIds.TCP_FIND_GROUP_ID, token.player);
                    if (!token.player.Accepted)
                    {
                        if (frame.GroupId == MessageGroupIds.NETWORK_ID_REQUEST)
                        {
                            token.player.InstanceGuid = ((Text)frame).ToString();

                            bool rejected;
                            OnPlayerGuidAssigned(token.player, out rejected);

                            // If the player was rejected during the handling of the playerGuidAssigned event, don&#39;t accept them.
                            if (rejected)
                                break;

                            token.maxAllowedBytes = int.MaxValue;

                            if (authenticator != null)
                            {
                                authenticator.IssueChallenge(this, token.player, IssueChallenge, AuthUser);
                            } else
                            {
                                AuthUser(token.player);
                            }
                        } else if (frame.GroupId == MessageGroupIds.AUTHENTICATION_RESPONSE)
                        {
                            // Authenticate user response
                            if (authenticator == null)
                                return;

                            authenticator.VerifyResponse(this, token.player, frame.StreamData, AuthUser, RejectUser);

                        } else
                        {
                            Disconnect(token.player, true);
                            ReturnBuffer(e);
                        }
                    }
                    else
                    {
                        token.player.Ping();
                        FireRead(frame, token.player);
                    }
                }
                DoRead(e);
            }
            else
            {
                Disconnect(((ReceiveToken)e.UserToken).player, true);
                ReturnBuffer(e);
            }
        }

        private void ReturnBuffer(SocketAsyncEventArgs e)
        {
            if (e.UserToken != null)
            {
                ReceiveToken token = (ReceiveToken)e.UserToken;
				bufferManager.ReturnBuffer(token.internalBuffer);
				token.internalBuffer = default(ArraySegment&lt;byte&gt;);
				e.SetBuffer(new byte[0], 0, 0);
			}
        }

        /// &lt;summary&gt;
        /// Callback for user auth. Sends an auth challenge to the user.
        /// &lt;/summary&gt;
        private void IssueChallenge(NetworkingPlayer player, BMSByte buffer)
        {
            Send(player.TcpClientHandle, new Binary(Time.Timestep, false, buffer, Receivers.Target, MessageGroupIds.AUTHENTICATION_CHALLENGE, true));
        }

        /// &lt;summary&gt;
        /// Callback for user auth. Authenticates the user and sends the user their network id for acceptance.
        /// &lt;/summary&gt;
        private void AuthUser(NetworkingPlayer player)
        {
            OnPlayerAuthenticated(player);

            // If authenticated, send the player their network id and accept them
            var buffer = new BMSByte();
            buffer.Append(BitConverter.GetBytes(player.NetworkId));
            Send(player.TcpClientHandle, new Binary(Time.Timestep, false, buffer, Receivers.Target, MessageGroupIds.NETWORK_ID_REQUEST, true));
            SendBuffer(player);

            OnPlayerAccepted(player);
        }

        /// &lt;summary&gt;
        /// Callback for user auth. Sends an authentication failure message to the user and then disconnects them.
        /// &lt;/summary&gt;
        private void RejectUser(NetworkingPlayer player)
        {
            OnPlayerRejected(player);
            Send(player.TcpClientHandle, Error.CreateErrorMessage(Time.Timestep, &quot;Authentication Failed&quot;, false, MessageGroupIds.AUTHENTICATION_FAILURE, true));
            SendBuffer(player);
            Disconnect(player, true);
            CommitDisconnects();
        }

        /// &lt;summary&gt;
        /// Disconnects this server and all of it&#39;s clients
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;forced&quot;&gt;Used to tell if this disconnect was intentional &lt;c&gt;false&lt;/c&gt; or caused by an exception &lt;c&gt;true&lt;/c&gt;&lt;/param&gt;
        public override void Disconnect(bool forced)
        {
            // Since we are disconnecting we need to stop the read thread
            readThreadCancel = true;

            lock (Players)
            {
                // Stop listening for new connections
                listener.Stop();

                // Go through all of the players and disconnect them
                foreach (NetworkingPlayer player in Players)
                    Disconnect(player, true);

                // Send signals to the methods registered to the disconnec events
                if (!forced)
                    OnDisconnected();
                else
                    OnForcedDisconnect();
            }

            CommitDisconnects();
        }

        /// &lt;summary&gt;
        /// Disconnects a client from this listener
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;client&quot;&gt;The target client to be disconnected&lt;/param&gt;
        public void Disconnect(NetworkingPlayer player, bool forced)
        {
            commonServerLogic.Disconnect(player, forced, DisconnectingPlayers, ForcedDisconnectingPlayers);
            if (!PendingCommitDisconnects)
            {
                PendingCommitDisconnects = true;
                Task.Queue(() =&gt; {
                    PendingCommitDisconnects = false;
                    CommitDisconnects();
                }, 30000);
            }
        }

        /// &lt;summary&gt;
        /// Fully remove the player from the network
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;player&quot;&gt;The target player&lt;/param&gt;
        /// &lt;param name=&quot;forced&quot;&gt;If the player is being forcibly removed from an exception&lt;/param&gt;
        private void RemovePlayer(NetworkingPlayer player, bool forced)
        {
            lock (Players)
            {
                if (player.IsDisconnecting)
                    return;

                player.IsDisconnecting = true;
            }

            // Tell the player that he is getting disconnected
            if(player.TcpClientHandle != null &amp;&amp; player.TcpClientHandle.Connected)
                Send(player.TcpClientHandle, new ConnectionClose(Time.Timestep, false, Receivers.Target, MessageGroupIds.DISCONNECT, true));

            if (!forced)
            {
                Task.Queue(() =&gt;
                {
                    FinalizeRemovePlayer(player, forced);
                }, 1000);
            }
            else
                FinalizeRemovePlayer(player, forced);
        }

        private void FinalizeRemovePlayer(NetworkingPlayer player, bool forced)
        {
            OnPlayerDisconnected(player);
            if(player.TcpClientHandle != null)
                player.TcpClientHandle.Close();
            rawClients.Remove(player.TcpClientHandle);

            if (!forced)
            {
                // Let all of the event listeners know that the client has successfully disconnected
                if (rawClientDisconnected != null)
                    rawClientDisconnected(player.TcpClientHandle);
                DisconnectingPlayers.Remove(player);
            }
            else
            {
                // Let all of the event listeners know that this was a forced disconnect
                if (forced &amp;&amp; rawClientForceClosed != null)
                    rawClientForceClosed(player.TcpClientHandle);
                ForcedDisconnectingPlayers.Remove(player);
            }
        }

#if WINDOWS_UWP
		private void ClientRejected(StreamSocket client, bool forced)
#else
        private void ClientRejected(TcpClient client, bool forced)
#endif
        {
            // Clean up the client objects
            client.Close();
        }

        private void SendBuffer(NetworkingPlayer player)
        {
            foreach (FrameStream frame in bufferedMessages)
                Send(player.TcpClientHandle, frame);
        }

        public override void Ping()
        {
            // I am the server, so 0 ms...
            OnPingRecieved(0, Me);
        }

        /// &lt;summary&gt;
        /// Pong back to the client
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;playerRequesting&quot;&gt;&lt;/param&gt;
        protected override void Pong(NetworkingPlayer playerRequesting, DateTime time)
        {
            SendToPlayer(GeneratePong(time), playerRequesting);
        }

        public void StopAcceptingConnections()
        {
            AcceptingConnections = false;
        }

        public void StartAcceptingConnections()
        {
            AcceptingConnections = true;
        }

        public void BanPlayer(ulong networkId, int minutes)
        {
            NetworkingPlayer player = Players.FirstOrDefault(p =&gt; p.NetworkId == networkId);

            if (player == null)
                return;

            BannedAddresses.Add(player.Ip);
            Disconnect(player, true);
            CommitDisconnects();
        }

        public override void FireRead(FrameStream frame, NetworkingPlayer currentPlayer)
        {
            // The client has told the server that it is disconnecting
            if (frame is ConnectionClose)
            {
                // Confirm the connection close
                Send(currentPlayer.TcpClientHandle, new ConnectionClose(Time.Timestep, false, Receivers.Target, MessageGroupIds.DISCONNECT, true));

                Disconnect(currentPlayer, false);
                CommitDisconnects();
                return;
            }

            // A message has been successfully read from the network so relay that
            // to all methods registered to the event
            OnMessageReceived(currentPlayer, frame);
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[79,9,79,45,0],[85,9,85,44,0],[98,9,98,68,0],[101,9,101,80,0],[106,44,106,48,0],[106,49,106,61,0],[108,47,108,51,0],[108,52,108,56,0],[112,48,112,68,0],[113,9,113,10,0],[114,13,114,41,0],[115,13,115,50,0],[116,13,116,61,0],[117,13,117,38,0],[118,17,118,90,0],[120,17,120,76,0],[121,9,121,10,0],[128,9,128,10,0],[136,13,136,60,0],[138,9,138,10,0],[150,9,150,10,0],[151,13,151,32,0],[152,17,152,30,0],[155,13,155,26,0],[156,13,156,14,0],[158,17,158,18,0],[160,21,160,51,0],[162,21,162,44,0],[163,21,163,33,0],[165,17,165,22,0],[166,17,166,18,0],[168,17,168,18,0],[169,13,169,14,0],[171,13,171,26,0],[172,9,172,10,0],[182,9,182,10,0],[183,13,183,64,0],[184,13,184,112,0],[188,13,188,44,0],[190,9,190,10,0],[198,9,198,10,0],[199,13,199,105,0],[200,17,200,45,0],[202,13,202,27,0],[203,13,203,14,0],[204,17,204,52,0],[205,17,205,18,0],[206,21,206,86,0],[207,21,207,69,0],[208,25,208,32,0],[210,21,210,48,0],[211,21,211,22,0],[213,25,213,212,0],[214,29,214,36,0],[215,21,215,22,0],[218,21,218,115,0],[219,21,219,22,0],[222,25,222,142,0],[223,25,223,26,0],[224,29,224,36,0],[226,21,226,22,0],[228,21,228,123,0],[229,21,229,22,0],[232,25,232,98,0],[233,25,233,26,0],[234,29,234,36,0],[236,21,236,22,0],[239,21,239,22,0],[240,25,240,61,0],[241,21,241,22,0],[242,21,242,26,0],[243,21,243,22,0],[244,25,244,50,0],[245,21,245,22,0],[246,17,246,18,0],[247,13,247,14,0],[248,9,248,10,0],[258,9,258,10,0],[259,13,259,64,0],[260,13,260,105,0],[261,13,261,51,0],[262,9,262,10,0],[269,9,269,10,0],[270,13,270,105,0],[271,17,271,45,0],[273,13,273,27,0],[274,13,274,14,0],[275,17,275,24,0],[275,26,275,49,0],[275,50,275,52,0],[275,53,275,60,0],[276,17,276,18,0],[277,21,277,137,0],[278,25,278,34,0],[281,21,281,22,0],[282,25,282,61,0],[283,21,283,22,0],[284,21,284,26,0],[285,21,285,22,0],[286,25,286,50,0],[287,21,287,22,0],[288,17,288,18,0],[289,13,289,14,0],[290,9,290,10,0],[294,9,294,10,0],[295,13,295,105,0],[296,17,296,45,0],[297,13,297,27,0],[298,13,298,14,0],[299,17,299,24,0],[299,26,299,49,0],[299,50,299,52,0],[299,53,299,60,0],[300,17,300,18,0],[302,21,302,141,0],[303,25,303,34,0],[304,21,304,137,0],[305,25,305,34,0],[307,21,307,22,0],[308,25,308,61,0],[309,21,309,22,0],[309,23,309,28,0],[310,21,310,22,0],[311,25,311,50,0],[312,21,312,22,0],[313,17,313,18,0],[314,13,314,14,0],[315,9,315,10,0],[325,9,325,10,0],[326,13,326,64,0],[327,13,327,104,0],[328,13,328,48,0],[329,9,329,10,0],[334,46,334,47,0],[334,48,334,80,0],[334,81,334,82,0],[336,9,336,55,0],[341,41,341,42,0],[341,43,341,67,0],[341,68,341,69,0],[350,9,350,10,0],[351,13,351,26,0],[352,17,352,157,0],[354,13,354,51,0],[355,17,355,139,0],[358,13,358,72,0],[359,17,359,43,0],[361,17,361,58,0],[364,13,364,14,0],[366,17,366,61,0],[369,17,369,99,0],[370,17,370,59,0],[376,17,376,34,0],[377,17,377,79,0],[380,17,380,36,0],[398,17,398,39,0],[400,17,400,37,0],[403,17,403,76,0],[404,13,404,14,0],[405,13,405,32,0],[406,13,406,14,0],[407,17,407,48,0],[409,17,409,33,0],[411,17,411,105,0],[413,9,413,10,0],[420,9,420,10,0],[421,13,421,69,0],[422,13,422,37,0],[425,13,425,14,0],[426,17,426,64,0],[427,13,427,14,0],[428,13,428,18,0],[429,13,429,14,0],[430,17,430,24,0],[433,13,433,85,0],[435,13,435,52,0],[436,13,436,14,0],[438,17,438,150,0],[441,17,441,125,0],[444,17,444,47,0],[445,17,445,24,0],[447,18,447,44,0],[448,13,448,14,0],[450,17,450,169,0],[453,17,453,125,0],[456,17,456,47,0],[457,17,457,24,0],[461,13,461,59,0],[462,13,462,14,0],[464,17,464,169,0],[467,17,467,125,0],[470,17,470,47,0],[471,17,471,122,0],[476,13,476,27,0],[477,13,477,14,0],[478,17,478,40,0],[481,17,481,171,0],[484,17,484,43,0],[486,17,493,19,0],[494,13,494,14,0],[497,13,497,44,0],[498,17,498,44,0],[500,13,500,65,0],[501,13,501,91,0],[502,13,502,33,0],[503,13,503,110,0],[505,13,505,48,0],[506,17,506,34,0],[506,34,506,65,0],[506,65,506,67,0],[506,17,506,67,0],[509,9,509,10,0],[512,9,512,10,0],[513,13,513,26,0],[514,13,514,14,0],[515,17,515,33,0],[516,17,516,24,0],[519,13,519,60,0],[520,13,520,40,0],[522,13,522,14,0],[524,17,524,68,0],[525,13,525,14,0],[526,13,526,18,0],[527,13,527,14,0],[530,17,530,48,0],[531,17,531,33,0],[532,17,532,24,0],[536,13,536,57,0],[537,13,537,14,0],[538,17,538,49,0],[539,17,539,33,0],[540,17,540,24,0],[544,13,544,47,0],[545,17,545,49,0],[546,9,546,10,0],[549,9,549,10,0],[550,13,550,80,0],[551,13,551,14,0],[552,17,552,47,0],[553,17,553,64,0],[554,17,554,71,0],[555,17,555,18,0],[556,21,556,84,0],[557,21,557,40,0],[558,21,558,22,0],[559,25,559,35,0],[560,25,560,32,0],[562,21,562,83,0],[565,21,565,42,0],[566,21,566,22,0],[567,25,567,56,0],[568,25,568,56,0],[569,25,569,41,0],[570,25,570,32,0],[574,21,574,98,0],[577,21,577,51,0],[578,17,578,18,0],[579,17,579,67,0],[580,17,580,18,0],[581,21,581,82,0],[582,21,582,38,0],[583,21,583,22,0],[584,25,584,31,0],[586,21,586,124,0],[587,21,587,48,0],[588,21,588,22,0],[589,25,589,81,0],[590,25,590,26,0],[591,29,591,82,0],[594,29,594,78,0],[597,29,597,42,0],[598,33,598,39,0],[600,29,600,66,0],[602,29,602,55,0],[603,29,603,30,0],[604,33,604,108,0],[605,29,605,30,0],[606,29,606,30,0],[607,33,607,56,0],[608,29,608,30,0],[609,25,609,26,0],[609,32,609,93,0],[610,25,610,26,0],[612,29,612,55,0],[613,33,613,40,0],[615,29,615,118,0],[617,25,617,26,0],[618,25,618,26,0],[619,29,619,60,0],[620,29,620,45,0],[621,25,621,26,0],[622,21,622,22,0],[624,21,624,22,0],[625,25,625,45,0],[626,25,626,55,0],[627,21,627,22,0],[628,17,628,18,0],[629,17,629,27,0],[630,13,630,14,0],[632,13,632,14,0],[633,17,633,70,0],[634,17,634,33,0],[635,13,635,14,0],[636,9,636,10,0],[639,9,639,10,0],[640,13,640,37,0],[641,13,641,14,0],[642,17,642,64,0],[643,5,643,54,0],[644,5,644,56,0],[645,5,645,36,0],[646,4,646,5,0],[647,9,647,10,0],[653,9,653,10,0],[654,13,654,150,0],[655,9,655,10,0],[661,9,661,10,0],[662,13,662,43,0],[665,13,665,40,0],[666,13,666,68,0],[667,13,667,144,0],[668,13,668,32,0],[670,13,670,38,0],[671,9,671,10,0],[677,9,677,10,0],[678,13,678,38,0],[679,13,679,161,0],[680,13,680,32,0],[681,13,681,38,0],[682,13,682,33,0],[683,9,683,10,0],[690,9,690,10,0],[692,13,692,37,0],[694,13,694,27,0],[695,13,695,14,0],[697,17,697,33,0],[700,17,700,24,0],[700,26,700,49,0],[700,50,700,52,0],[700,53,700,60,0],[701,21,701,46,0],[704,17,704,29,0],[705,21,705,38,0],[707,21,707,42,0],[708,13,708,14,0],[710,13,710,33,0],[711,9,711,10,0],[718,9,718,10,0],[719,13,719,108,0],[720,13,720,43,0],[721,13,721,14,0],[722,17,722,49,0],[723,17,723,34,0],[723,34,723,35,0],[723,35,724,21,0],[724,21,724,54,0],[724,54,725,21,0],[725,21,725,41,0],[725,41,726,17,0],[726,17,726,18,0],[726,18,726,27,0],[723,17,726,27,0],[727,13,727,14,0],[728,9,728,10,0],[736,9,736,10,0],[737,13,737,27,0],[738,13,738,14,0],[739,17,739,44,0],[740,21,740,28,0],[742,17,742,47,0],[743,13,743,14,0],[746,13,746,83,0],[747,17,747,141,0],[749,13,749,25,0],[750,13,750,14,0],[751,17,752,17,0],[752,17,752,18,0],[752,18,753,21,0],[753,21,753,58,0],[753,58,754,17,0],[754,17,754,18,0],[754,18,754,26,0],[751,17,754,26,0],[755,13,755,14,0],[757,17,757,54,0],[758,9,758,10,0],[761,9,761,10,0],[762,13,762,42,0],[763,13,763,47,0],[764,17,764,48,0],[765,13,765,55,0],[767,13,767,25,0],[768,13,768,14,0],[770,17,770,51,0],[771,21,771,67,0],[772,17,772,53,0],[773,13,773,14,0],[775,13,775,14,0],[777,17,777,60,0],[778,21,778,66,0],[779,17,779,59,0],[780,13,780,14,0],[781,9,781,10,0],[788,9,788,10,0],[790,13,790,28,0],[791,9,791,10,0],[794,9,794,10,0],[795,13,795,20,0],[795,22,795,39,0],[795,40,795,42,0],[795,43,795,59,0],[796,17,796,53,0],[797,9,797,10,0],[800,9,800,10,0],[802,13,802,35,0],[803,9,803,10,0],[810,9,810,10,0],[811,13,811,64,0],[812,9,812,10,0],[815,9,815,10,0],[816,13,816,42,0],[817,9,817,10,0],[820,9,820,10,0],[821,13,821,41,0],[822,9,822,10,0],[825,9,825,10,0],[826,13,826,67,0],[826,67,826,91,0],[826,91,826,93,0],[826,13,826,93,0],[828,13,828,32,0],[829,17,829,24,0],[831,13,831,44,0],[832,13,832,38,0],[833,13,833,33,0],[834,9,834,10,0],[837,9,837,10,0],[839,13,839,42,0],[840,13,840,14,0],[842,17,842,148,0],[844,17,844,50,0],[845,17,845,37,0],[846,17,846,24,0],[851,13,851,53,0],[852,9,852,10,0]]);
    </script>
  </body>
</html>