<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>p:\stuff\projects\minigamesproject\minigamesproject\assets\_assets\scripts\bearded man studios\scripts\networking\forge\networking\objectmapper.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
/*-----------------------------+-------------------------------\
|                                                              |
|                         !!!NOTICE!!!                         |
|                                                              |
|  These libraries are under heavy development so they are     |
|  subject to make many changes as development continues.      |
|  For this reason, the libraries may not be well commented.   |
|  THANK YOU for supporting forge with all your feedback       |
|  suggestions, bug reports and comments!                      |
|                                                              |
|                              - The Forge Team                |
|                                Bearded Man Studios, Inc.     |
|                                                              |
|  This source code, project files, and associated files are   |
|  copyrighted by Bearded Man Studios, Inc. (2012-2017) and    |
|  may not be redistributed without written permission.        |
|                                                              |
\------------------------------+------------------------------*/

#if BMS_DEBUGGING
#define BMS_DEBUGGING_UNITY
#endif

using System;
using System.IO;
using System.Text;

namespace BeardedManStudios.Forge.Networking
{
	public class ObjectMapper
	{
		protected static ObjectMapper instance = null;
		public static ObjectMapper Instance
		{
			get
			{
				if (instance != null)
					return instance;

				instance = new ObjectMapper();
				return instance;
			}
		}

		protected ObjectMapper() { }

		protected int byteArrSize, size = 0;

		public void UseAsDefault() { instance = this; }

		/// &lt;summary&gt;
		/// Map a type of object from a BMSByte to a object
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;type&quot;&gt;Type of object to map&lt;/param&gt;
		/// &lt;param name=&quot;stream&quot;&gt;BMSByte to be used&lt;/param&gt;
		/// &lt;returns&gt;Returns the mapped object&lt;/returns&gt;
		public virtual object Map(Type type, BMSByte stream)
		{
			object obj = null;

			if (type == typeof(string))
				obj = stream.GetBasicType&lt;string&gt;();
			else if (type == typeof(Vector))
				obj = stream.GetBasicType&lt;Vector&gt;();
			else if (type.IsArray)
				obj = MapArray(type, stream);
			else if (type == typeof(BMSByte))
				obj = MapBMSByte(stream);
			else if (type.IsEnum)
				obj = MapBasicType(Enum.GetUnderlyingType(type), stream);
			else
				obj = MapBasicType(type, stream);

			return obj;
		}

		/// &lt;summary&gt;
		/// Get a mapped value out of the BMSByte
		/// &lt;/summary&gt;
		/// &lt;typeparam name=&quot;T&quot;&gt;Value to get out of it&lt;/typeparam&gt;
		/// &lt;param name=&quot;stream&quot;&gt;BMSByte to be used&lt;/param&gt;
		/// &lt;returns&gt;Returns a mapped value from the BMSByte&lt;/returns&gt;
		public virtual T Map&lt;T&gt;(BMSByte stream)
		{
			object obj = null;
			var genericType = typeof(T);

			if (genericType == typeof(string))
				obj = stream.GetBasicType&lt;string&gt;();
			else if (genericType == typeof(Vector))
				obj = stream.GetBasicType&lt;Vector&gt;();
			else if (genericType.IsArray)
				obj = MapArray(genericType, stream);
			else if (genericType == typeof(BMSByte))
				obj = MapBMSByte(stream);
			else if (genericType.IsEnum)
				obj = MapBasicType(Enum.GetUnderlyingType(genericType), stream);
			else
				obj = MapBasicType(genericType, stream);

			return (T)obj;
		}

		/// &lt;summary&gt;
		/// Get a mapped basic type of object from the BMSByte
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;type&quot;&gt;Type of object to be mapped&lt;/param&gt;
		/// &lt;param name=&quot;stream&quot;&gt;BMSByte to be used&lt;/param&gt;
		/// &lt;returns&gt;Returns a mapped object of the given type&lt;/returns&gt;
		public object MapBasicType(Type type, BMSByte stream)
		{
			if (type == typeof(sbyte))
				return unchecked((sbyte)stream.GetBasicType&lt;byte&gt;());
			else if (type == typeof(byte))
				return stream.GetBasicType&lt;byte&gt;();
			else if (type == typeof(char))
				return unchecked((char)stream.GetBasicType&lt;byte&gt;());
			else if (type == typeof(short))
				return stream.GetBasicType&lt;short&gt;();
			else if (type == typeof(ushort))
				return stream.GetBasicType&lt;ushort&gt;();
			else if (type == typeof(bool))
				return stream.GetBasicType&lt;bool&gt;();
			else if (type == typeof(int))
				return stream.GetBasicType&lt;int&gt;();
			else if (type == typeof(uint))
				return stream.GetBasicType&lt;uint&gt;();
			else if (type == typeof(float))
				return stream.GetBasicType&lt;float&gt;();
			else if (type == typeof(long))
				return stream.GetBasicType&lt;long&gt;();
			else if (type == typeof(ulong))
				return stream.GetBasicType&lt;ulong&gt;();
			else if (type == typeof(double))
				return stream.GetBasicType&lt;double&gt;();
			else if (type == typeof(string))
				return stream.GetBasicType&lt;string&gt;();
			else if (type == typeof(Vector))
				return stream.GetBasicType&lt;Vector&gt;();
			else
				// TODO:  Make this an object mapper exception
				throw new BaseNetworkException(&quot;The type &quot; + type.ToString() + &quot; is not allowed to be sent over the Network (yet)&quot;);
		}

		/// &lt;summary&gt;
		/// Map a generic array from the BMSBytes
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;type&quot;&gt;The type of the array&lt;/param&gt;
		/// &lt;param name=&quot;bytes&quot;&gt;The bytes to read from&lt;/param&gt;
		/// &lt;returns&gt;The array that was found&lt;/returns&gt;
		public object MapArray(Type type, BMSByte bytes)
		{
			int rank = type.GetArrayRank();
			Type targetType = type.GetElementType();

			if (targetType != typeof(byte))
				throw new Exception(&quot;Currently only byte arrays can be sent as arrays&quot;);

			if (rank &gt; 4)
				throw new Exception(&quot;Currently the system only supports up to 4 dimensions in an array&quot;);

			int i, j, k, l;

			// Read each dimension length first
			int[] lengths = new int[rank];
			for (i = 0; i &lt; rank; i++)
				lengths[i] = bytes.GetBasicType&lt;int&gt;();

			switch (rank)
			{
				case 1:
					byte[] arr1 = new byte[lengths[0]];

					for (i = 0; i &lt; lengths[0]; i++)
						arr1[i] = bytes.GetBasicType&lt;byte&gt;();

					return arr1;
				case 2:
					byte[,] arr2 = new byte[lengths[0], lengths[1]];

					for (i = 0; i &lt; lengths[0]; i++)
						for (j = 0; j &lt; lengths[1]; j++)
							arr2[i, j] = bytes.GetBasicType&lt;byte&gt;();

					return arr2;
				case 3:
					byte[,,] arr3 = new byte[lengths[0], lengths[1], lengths[2]];

					for (i = 0; i &lt; lengths[0]; i++)
						for (j = 0; j &lt; lengths[1]; j++)
							for (k = 0; k &lt; lengths[2]; k++)
								arr3[i, j, k] = bytes.GetBasicType&lt;byte&gt;();

					return arr3;
				case 4:
					byte[,,,] arr4 = new byte[lengths[0], lengths[1], lengths[2], lengths[3]];

					for (i = 0; i &lt; lengths[0]; i++)
						for (j = 0; j &lt; lengths[1]; j++)
							for (k = 0; k &lt; lengths[2]; k++)
								for (l = 0; l &lt; lengths[3]; l++)
									arr4[i, j, k, l] = bytes.GetBasicType&lt;byte&gt;();

					return arr4;
			}

			return null;
		}

		/// &lt;summary&gt;
		/// Get a BMSByte out of a BMSByte
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;type&quot;&gt;Type of object to be mapped&lt;/param&gt;
		/// &lt;param name=&quot;stream&quot;&gt;BMSByte to be used&lt;/param&gt;
		/// &lt;returns&gt;A BMSByte that was read from the BMSByte&lt;/returns&gt;
		public object MapBMSByte(BMSByte stream)
		{
			size = Map&lt;int&gt;(stream);
			return new BMSByte().Clone(Map&lt;byte[]&gt;(stream));
		}

		/// &lt;summary&gt;
		/// Get a byte[] out of a BMSByte
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;args&quot;&gt;Arguments passed through to get mapped&lt;/param&gt;
		/// &lt;returns&gt;A byte[] of the mapped arguments&lt;/returns&gt;
		public BMSByte MapBytes(BMSByte bytes, params object[] args)
		{
			byte[][] bytesToMap = new byte[args.Length][];
			for (int i = 0; i &lt; args.Length; i++)
			{
				Type type = null;
				if (args[i] != null)
					type = args[i].GetType();

				bytesToMap[i] = GetBytesArray(args[i], type);
			}
			bytes.Append(bytesToMap);
			return bytes;
		}

		/// &lt;summary&gt;
		/// Gets the bytes for the Instance of an Object and appends them to a &lt;c&gt;BMSByte&lt;/c&gt;.
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;o&quot;&gt;The Instance of the Object.&lt;/param&gt;
		/// &lt;param name=&quot;type&quot;&gt;The Type of the Object.&lt;/param&gt;
		/// &lt;param name=&quot;bytes&quot;&gt;&lt;c&gt;BMSByte&lt;/c&gt; to which the bytes should be added.&lt;/param&gt;
		protected virtual void GetBytes(object o, Type type, ref BMSByte bytes)
		{
			if (type == typeof(string))
			{
				var strBytes = Encoding.UTF8.GetBytes(o == null ? string.Empty : (string)o);
				// TODO:  Need to make custom string serialization to binary
				bytes.Append(BitConverter.GetBytes(strBytes.Length));

				if (strBytes.Length &gt; 0)
					bytes.Append(strBytes);
			}
			else if (type == typeof(Vector))
			{
				Vector vec = (Vector)o;
				bytes.Append(BitConverter.GetBytes(vec.x));
				bytes.Append(BitConverter.GetBytes(vec.y));
				bytes.Append(BitConverter.GetBytes(vec.z));
			}
			else if (type == null) //TODO: Check if this causes other issues
				bytes.Append(new byte[1] { 0 });
			else if (type == typeof(sbyte))
				bytes.BlockCopy&lt;sbyte&gt;(o, 1);
			else if (type == typeof(byte))
				bytes.BlockCopy&lt;byte&gt;(o, 1);
			else if (type == typeof(char))
				bytes.BlockCopy&lt;char&gt;(o, 1);
			else if (type == typeof(bool))
				bytes.Append(BitConverter.GetBytes((bool)o));
			else if (type == typeof(short))
				bytes.Append(BitConverter.GetBytes((short)o));
			else if (type == typeof(ushort))
				bytes.Append(BitConverter.GetBytes((ushort)o));
			else if (type == typeof(int))
				bytes.Append(BitConverter.GetBytes((int)o));
			else if (type == typeof(uint))
				bytes.Append(BitConverter.GetBytes((uint)o));
			else if (type == typeof(long))
				bytes.Append(BitConverter.GetBytes((long)o));
			else if (type == typeof(ulong))
				bytes.Append(BitConverter.GetBytes((ulong)o));
			else if (type == typeof(float))
				bytes.Append(BitConverter.GetBytes((float)o));
			else if (type == typeof(double))
				bytes.Append(BitConverter.GetBytes((double)o));
			else if (type.IsArray)
			{
				int rank = type.GetArrayRank();
				Type targetType = type.GetElementType();

				if (targetType != typeof(byte))
					throw new Exception(&quot;Currently only byte arrays can be sent as arrays&quot;);

				if (rank &gt; 4)
					throw new Exception(&quot;Currently the system only supports up to 4 dimensions in an array&quot;);

				int i, j, k, l;

				// Write each dimension length first
				int[] lengths = new int[rank];
				for (i = 0; i &lt; rank; i++)
				{
					lengths[i] = ((Array)o).GetLength(i);
					bytes.Append(BitConverter.GetBytes(lengths[i]));
				}

				switch (rank)
				{
					case 1:
						for (i = 0; i &lt; lengths[0]; i++)
							GetBytes(((Array)o).GetValue(i), targetType, ref bytes);
						break;
					case 2:
						for (i = 0; i &lt; lengths[0]; i++)
							for (j = 0; j &lt; lengths[1]; j++)
								GetBytes(((Array)o).GetValue(i, j), targetType, ref bytes);
						break;
					case 3:
						for (i = 0; i &lt; lengths[0]; i++)
							for (j = 0; j &lt; lengths[1]; j++)
								for (k = 0; k &lt; lengths[2]; k++)
									GetBytes(((Array)o).GetValue(i, j, k), targetType, ref bytes);
						break;
					case 4:
						for (i = 0; i &lt; lengths[0]; i++)
							for (j = 0; j &lt; lengths[1]; j++)
								for (k = 0; k &lt; lengths[2]; k++)
									for (l = 0; l &lt; lengths[3]; l++)
										GetBytes(((Array)o).GetValue(i, j, k, l), targetType, ref bytes);
						break;
				}
			}
			else if (type == typeof(BMSByte))
			{
				bytes.Append(BitConverter.GetBytes(((BMSByte)o).Size));
				bytes.BlockCopy(((BMSByte)o).byteArr, ((BMSByte)o).StartIndex(), ((BMSByte)o).Size);
			}
			else if (type.IsEnum)
				GetBytes(o, Enum.GetUnderlyingType(type), ref bytes);
			else
			{
				// TODO:  Make this a more appropriate exception
				throw new BaseNetworkException(&quot;The type &quot; + type.ToString() + &quot; is not allowed to be sent over the Network (yet)&quot;);
			}
		}

		/// &lt;summary&gt;
		/// Gets the bytes array for the Instance of an Object
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;o&quot;&gt;The Instance of the Object.&lt;/param&gt;
		/// &lt;param name=&quot;type&quot;&gt;The Type of the Object.&lt;/param&gt;
		protected virtual byte[] GetBytesArray(object o, Type type)
		{
			if (type == typeof(string))
			{
				var strBytes = Encoding.UTF8.GetBytes(o == null ? string.Empty : (string)o);
				byte[] bytes = new byte[strBytes.Length + sizeof(int)];
				// TODO:  Need to make custom string serialization to binary
				Buffer.BlockCopy(BitConverter.GetBytes(strBytes.Length), 0, bytes, 0, sizeof(int));
				if (strBytes.Length &gt; 0)
					Buffer.BlockCopy(strBytes, 0, bytes, sizeof(int), strBytes.Length);
				return bytes;
			}
			else if (type == typeof(Vector))
			{
				Vector vec = (Vector)o;
				byte[] bytes = new byte[sizeof(float) * 3];
				Buffer.BlockCopy(BitConverter.GetBytes(vec.x), 0, bytes, 0, sizeof(float));
				Buffer.BlockCopy(BitConverter.GetBytes(vec.y), 0, bytes, sizeof(float), sizeof(float));
				Buffer.BlockCopy(BitConverter.GetBytes(vec.z), 0, bytes, sizeof(float) * 2, sizeof(float));
				return bytes;
			}
			else if (type == null) //TODO: Check if this causes other issues
				return new byte[1] { 0 };
			else if (type == typeof(sbyte))
				return new byte[1] {(byte) ((sbyte)o) };
			else if (type == typeof(byte))
				return new byte[1] { (byte)o };
			else if (type == typeof(char))
				return new byte[1] { (byte)((char)o) };
			else if (type == typeof(bool))
				return BitConverter.GetBytes((bool)o);
			else if (type == typeof(short))
				return BitConverter.GetBytes((short)o);
			else if (type == typeof(ushort))
				return BitConverter.GetBytes((ushort)o);
			else if (type == typeof(int))
				return BitConverter.GetBytes((int)o);
			else if (type == typeof(uint))
				return BitConverter.GetBytes((uint)o);
			else if (type == typeof(long))
				return BitConverter.GetBytes((long)o);
			else if (type == typeof(ulong))
				return BitConverter.GetBytes((ulong)o);
			else if (type == typeof(float))
				return BitConverter.GetBytes((float)o);
			else if (type == typeof(double))
				return BitConverter.GetBytes((double)o);
			else if (type.IsArray)
			{
				byte[] bytes;

				using (MemoryStream stream = new MemoryStream())
				{
					using (BinaryWriter writer = new BinaryWriter(stream))
					{
						int rank = type.GetArrayRank();
						Type targetType = type.GetElementType();

						if (targetType != typeof(byte))
							throw new Exception(&quot;Currently only byte arrays can be sent as arrays&quot;);

						if (rank &gt; 4)
							throw new Exception(&quot;Currently the system only supports up to 4 dimensions in an array&quot;);

						int i, j, k, l;

						// Write each dimension length first
						int[] lengths = new int[rank];
						for (i = 0; i &lt; rank; i++)
						{
							lengths[i] = ((Array)o).GetLength(i);
							writer.Write(BitConverter.GetBytes(lengths[i]));
						}

						switch (rank)
						{
							case 1:
								for (i = 0; i &lt; lengths[0]; i++)
									writer.Write(GetBytesArray(((Array)o).GetValue(i), targetType));
								break;
							case 2:
								for (i = 0; i &lt; lengths[0]; i++)
									for (j = 0; j &lt; lengths[1]; j++)
										writer.Write(GetBytesArray(((Array)o).GetValue(i, j), targetType));
								break;
							case 3:
								for (i = 0; i &lt; lengths[0]; i++)
									for (j = 0; j &lt; lengths[1]; j++)
										for (k = 0; k &lt; lengths[2]; k++)
											writer.Write(GetBytesArray(((Array)o).GetValue(i, j, k), targetType));
								break;
							case 4:
								for (i = 0; i &lt; lengths[0]; i++)
									for (j = 0; j &lt; lengths[1]; j++)
										for (k = 0; k &lt; lengths[2]; k++)
											for (l = 0; l &lt; lengths[3]; l++)
												writer.Write(GetBytesArray(((Array)o).GetValue(i, j, k, l), targetType));
								break;
						}
						bytes = stream.ToArray();
					}
					return bytes;
				}
			}
			else if (type == typeof(BMSByte))
			{
				byte[] bytesSize = BitConverter.GetBytes(((BMSByte)o).Size);
				byte[] bytes = new byte[bytesSize.Length + ((BMSByte)o).Size];
				Buffer.BlockCopy(((BMSByte)o).byteArr, ((BMSByte)o).StartIndex(), bytes, bytesSize.Length, ((BMSByte)o).Size);
				return bytes;
			}
			else if (type.IsEnum)
				return GetBytesArray(o, Enum.GetUnderlyingType(type));
			else
			{
				// TODO:  Make this a more appropriate exception
				throw new BaseNetworkException(&quot;The type &quot; + type.ToString() + &quot; is not allowed to be sent over the Network (yet)&quot;);
			}
		}

		/// &lt;summary&gt;
		/// Creates a BMSByte using ObjectMapper
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;argsToMap&quot;&gt;Objects to be mapped&lt;/param&gt;
		public static BMSByte BMSByte(params object[] argsToMap)
		{
			BMSByte data = new BMSByte();
			Instance.MapBytes(data, argsToMap);
			return data;
		}
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[32,3,32,49,0],[36,4,36,5,0],[37,5,37,26,0],[38,6,38,22,0],[40,5,40,35,0],[41,5,41,21,0],[42,4,42,5,0],[45,3,45,27,0],[45,28,45,29,0],[45,30,45,31,0],[47,30,47,38,0],[49,30,49,31,0],[49,32,49,48,0],[49,49,49,50,0],[58,3,58,4,0],[59,4,59,22,0],[61,4,61,31,0],[62,5,62,41,0],[63,9,63,36,0],[64,5,64,41,0],[65,9,65,26,0],[66,5,66,34,0],[67,9,67,37,0],[68,5,68,30,0],[69,9,69,25,0],[70,5,70,62,0],[72,5,72,38,0],[74,4,74,15,0],[75,3,75,4,0],[84,3,84,4,0],[85,4,85,22,0],[86,4,86,32,0],[88,4,88,38,0],[89,5,89,41,0],[90,9,90,43,0],[91,5,91,41,0],[92,9,92,33,0],[93,5,93,41,0],[94,9,94,44,0],[95,5,95,30,0],[96,9,96,32,0],[97,5,97,69,0],[99,5,99,45,0],[101,4,101,18,0],[102,3,102,4,0],[111,3,111,4,0],[112,4,112,30,0],[113,5,113,58,0],[114,9,114,34,0],[115,5,115,40,0],[116,9,116,34,0],[117,5,117,57,0],[118,9,118,35,0],[119,5,119,41,0],[120,9,120,36,0],[121,5,121,42,0],[122,9,122,34,0],[123,5,123,40,0],[124,9,124,33,0],[125,5,125,39,0],[126,9,126,34,0],[127,5,127,40,0],[128,9,128,35,0],[129,5,129,41,0],[130,9,130,34,0],[131,5,131,40,0],[132,9,132,35,0],[133,5,133,41,0],[134,9,134,36,0],[135,5,135,42,0],[136,9,136,36,0],[137,5,137,42,0],[138,9,138,36,0],[139,5,139,42,0],[142,5,142,121,0],[143,3,143,4,0],[152,3,152,4,0],[153,4,153,35,0],[154,4,154,44,0],[156,4,156,35,0],[157,5,157,77,0],[159,4,159,17,0],[160,5,160,94,0],[165,4,165,34,0],[166,9,166,14,0],[166,16,166,24,0],[166,26,166,29,0],[167,5,167,44,0],[169,4,169,17,0],[172,6,172,41,0],[174,11,174,16,0],[174,18,174,32,0],[174,34,174,37,0],[175,7,175,44,0],[177,6,177,18,0],[179,6,179,54,0],[181,11,181,16,0],[181,18,181,32,0],[181,34,181,37,0],[182,12,182,17,0],[182,19,182,33,0],[182,35,182,38,0],[183,8,183,48,0],[185,6,185,18,0],[187,6,187,67,0],[189,11,189,16,0],[189,18,189,32,0],[189,34,189,37,0],[190,12,190,17,0],[190,19,190,33,0],[190,35,190,38,0],[191,13,191,18,0],[191,20,191,34,0],[191,36,191,39,0],[192,9,192,52,0],[194,6,194,18,0],[196,6,196,80,0],[198,11,198,16,0],[198,18,198,32,0],[198,34,198,37,0],[199,12,199,17,0],[199,19,199,33,0],[199,35,199,38,0],[200,13,200,18,0],[200,20,200,34,0],[200,36,200,39,0],[201,14,201,19,0],[201,21,201,35,0],[201,37,201,40,0],[202,10,202,56,0],[204,6,204,18,0],[207,4,207,16,0],[208,3,208,4,0],[217,3,217,4,0],[218,4,218,28,0],[219,4,219,52,0],[220,3,220,4,0],[228,3,228,4,0],[229,4,229,50,0],[230,9,230,18,0],[230,20,230,35,0],[230,37,230,40,0],[231,4,231,5,0],[232,5,232,22,0],[233,5,233,25,0],[234,6,234,31,0],[236,5,236,50,0],[237,4,237,5,0],[238,4,238,29,0],[239,4,239,17,0],[240,3,240,4,0],[249,3,249,4,0],[250,4,250,31,0],[251,4,251,5,0],[252,5,252,81,0],[254,5,254,58,0],[256,5,256,29,0],[257,6,257,29,0],[258,4,258,5,0],[259,9,259,36,0],[260,4,260,5,0],[261,5,261,28,0],[262,5,262,48,0],[263,5,263,48,0],[264,5,264,48,0],[265,4,265,5,0],[266,9,266,26,0],[267,5,267,37,0],[268,9,268,35,0],[269,5,269,34,0],[270,9,270,34,0],[271,5,271,33,0],[272,9,272,34,0],[273,5,273,33,0],[274,9,274,34,0],[275,5,275,50,0],[276,9,276,35,0],[277,5,277,51,0],[278,9,278,36,0],[279,5,279,52,0],[280,9,280,33,0],[281,5,281,49,0],[282,9,282,34,0],[283,5,283,50,0],[284,9,284,34,0],[285,5,285,50,0],[286,9,286,35,0],[287,5,287,51,0],[288,9,288,35,0],[289,5,289,51,0],[290,9,290,36,0],[291,5,291,52,0],[292,9,292,26,0],[293,4,293,5,0],[294,5,294,36,0],[295,5,295,45,0],[297,5,297,36,0],[298,6,298,78,0],[300,5,300,18,0],[301,6,301,95,0],[306,5,306,35,0],[307,10,307,15,0],[307,17,307,25,0],[307,27,307,30,0],[308,5,308,6,0],[309,6,309,43,0],[310,6,310,54,0],[311,5,311,6,0],[313,5,313,18,0],[316,12,316,17,0],[316,19,316,33,0],[316,35,316,38,0],[317,8,317,64,0],[318,7,318,13,0],[320,12,320,17,0],[320,19,320,33,0],[320,35,320,38,0],[321,13,321,18,0],[321,20,321,34,0],[321,36,321,39,0],[322,9,322,68,0],[323,7,323,13,0],[325,12,325,17,0],[325,19,325,33,0],[325,35,325,38,0],[326,13,326,18,0],[326,20,326,34,0],[326,36,326,39,0],[327,14,327,19,0],[327,21,327,35,0],[327,37,327,40,0],[328,10,328,72,0],[329,7,329,13,0],[331,12,331,17,0],[331,19,331,33,0],[331,35,331,38,0],[332,13,332,18,0],[332,20,332,34,0],[332,36,332,39,0],[333,14,333,19,0],[333,21,333,35,0],[333,37,333,40,0],[334,15,334,20,0],[334,22,334,36,0],[334,38,334,41,0],[335,11,335,76,0],[336,7,336,13,0],[338,4,338,5,0],[339,9,339,37,0],[340,4,340,5,0],[341,5,341,60,0],[342,5,342,89,0],[343,4,343,5,0],[344,9,344,25,0],[345,5,345,58,0],[347,4,347,5,0],[349,5,349,121,0],[351,3,351,4,0],[359,3,359,4,0],[360,4,360,31,0],[361,4,361,5,0],[362,5,362,81,0],[363,5,363,60,0],[365,5,365,88,0],[366,5,366,29,0],[367,6,367,73,0],[368,5,368,18,0],[370,9,370,36,0],[371,4,371,5,0],[372,5,372,28,0],[373,5,373,48,0],[374,5,374,80,0],[375,5,375,92,0],[376,5,376,96,0],[377,5,377,18,0],[379,9,379,26,0],[380,5,380,30,0],[381,9,381,35,0],[382,5,382,45,0],[383,9,383,34,0],[384,5,384,36,0],[385,9,385,34,0],[386,5,386,44,0],[387,9,387,34,0],[388,5,388,43,0],[389,9,389,35,0],[390,5,390,44,0],[391,9,391,36,0],[392,5,392,45,0],[393,9,393,33,0],[394,5,394,42,0],[395,9,395,34,0],[396,5,396,43,0],[397,9,397,34,0],[398,5,398,43,0],[399,9,399,35,0],[400,5,400,44,0],[401,9,401,35,0],[402,5,402,44,0],[403,9,403,36,0],[404,5,404,45,0],[405,9,405,26,0],[406,4,406,5,0],[409,12,409,52,0],[410,5,410,6,0],[411,13,411,59,0],[412,6,412,7,0],[413,7,413,38,0],[414,7,414,47,0],[416,7,416,38,0],[417,8,417,80,0],[419,7,419,20,0],[420,8,420,97,0],[425,7,425,37,0],[426,12,426,17,0],[426,19,426,27,0],[426,29,426,32,0],[427,7,427,8,0],[428,8,428,45,0],[429,8,429,56,0],[430,7,430,8,0],[432,7,432,20,0],[435,14,435,19,0],[435,21,435,35,0],[435,37,435,40,0],[436,10,436,74,0],[437,9,437,15,0],[439,14,439,19,0],[439,21,439,35,0],[439,37,439,40,0],[440,15,440,20,0],[440,22,440,36,0],[440,38,440,41,0],[441,11,441,78,0],[442,9,442,15,0],[444,14,444,19,0],[444,21,444,35,0],[444,37,444,40,0],[445,15,445,20,0],[445,22,445,36,0],[445,38,445,41,0],[446,16,446,21,0],[446,23,446,37,0],[446,39,446,42,0],[447,12,447,82,0],[448,9,448,15,0],[450,14,450,19,0],[450,21,450,35,0],[450,37,450,40,0],[451,15,451,20,0],[451,22,451,36,0],[451,38,451,41,0],[452,16,452,21,0],[452,23,452,37,0],[452,39,452,42,0],[453,17,453,22,0],[453,24,453,38,0],[453,40,453,43,0],[454,13,454,86,0],[455,9,455,15,0],[457,7,457,32,0],[458,6,458,7,0],[459,6,459,19,0],[462,9,462,37,0],[463,4,463,5,0],[464,5,464,65,0],[465,5,465,67,0],[466,5,466,115,0],[467,5,467,18,0],[469,9,469,25,0],[470,5,470,59,0],[472,4,472,5,0],[474,5,474,121,0],[476,3,476,4,0],[483,3,483,4,0],[484,4,484,33,0],[485,4,485,39,0],[486,4,486,16,0],[487,3,487,4,0]]);
    </script>
  </body>
</html>