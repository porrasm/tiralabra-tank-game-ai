<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>p:\stuff\projects\minigamesproject\minigamesproject\assets\_assets\scripts\games\tankgame\tankai\datastructures\tankbullettrajectory.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using UnityEngine;

/// &lt;summary&gt;
/// Class used to determine where a bullet will go
/// &lt;/summary&gt;
public class TankBulletTrajectory {

    #region fields;
    TankAIBulletChecker checker;
    private TankAI ai;
    private TankBullet bullet;
    private bool fail;

    public bool HitAI { get; private set; }

    private Vector[] trajectory;
    public Vector[] Trajectory { get =&gt; trajectory; set =&gt; trajectory = value; }
    #endregion

    public TankBulletTrajectory(TankAIBulletChecker checker, TankBullet bullet) {
        this.checker = checker;
        ai = checker.AI;
        this.bullet = bullet;
    }

    /// &lt;summary&gt;
    /// Approximates the future trajectory of a bullet
    /// &lt;/summary&gt;
    public void CalculateTrajectory() {

        HitAI = false;

        Trajectory = new Vector[bullet.Bounces + 2];
        Trajectory[0] = new Vector(bullet.transform.position);

        SetTrajectory();
    }

    private void SetTrajectory() {

        Vector direction = new Vector(bullet.Velocity.normalized);

        for (int i = 1; i &lt; Trajectory.Length; i++) {

            
            //if (HitAI) {
            //    Array.Resize(ref trajectory, i + 1);
            //    break;
            //}

            if (!CalculateNextHit(ref direction, Trajectory[i - 1], i)) {
                Array.Resize(ref trajectory, i + 2);
                break;
            }
        }
    }

    /// &lt;summary&gt;
    /// Calculates the bullets next collision position and approximates the bounce of the bullet
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;direction&quot;&gt;&lt;/param&gt;
    /// &lt;param name=&quot;currentPos&quot;&gt;&lt;/param&gt;
    /// &lt;param name=&quot;index&quot;&gt;&lt;/param&gt;
    /// &lt;returns&gt;&lt;/returns&gt;
    private bool CalculateNextHit(ref Vector direction, Vector currentPos, int index) {

        RaycastHit hit;
        if (!Physics.Raycast(currentPos.Vector3, direction.Vector3, out hit, Mathf.Infinity, 9, QueryTriggerInteraction.Ignore)) {
            Debug.Log(&quot;Trajectory raycast did not hit anything.&quot;);
            return false;
        }

        if (hit.collider.gameObject.transform.parent == ai.transform) {
            HitAI = true;

            Vector3 newPos = hit.point + 0.2f * direction.Normalized.Vector3;

            // Continue next raycast from inside the collider
            if (!Physics.Raycast(ai.transform.position, direction.Vector3, out hit, Mathf.Infinity, 9, QueryTriggerInteraction.Ignore)) {
                Debug.Log(&quot;Trajectory raycast did not hit anything after hitting player.&quot;);
                return false;
            }
        }

        Vector hitPos = new Vector(hit.point);

        Trajectory[index] = hitPos;

        direction = Vector.Reflect(direction, new Vector(hit.normal));

        IncrementValues(currentPos, hitPos, direction);

        return true;
    }

    /// &lt;summary&gt;
    /// Increments the values in the TankAIBulletChecker.CellBulletCounts based on whether or not the bullet will pass over certain coordinates.
    /// &lt;/summary&gt;
    /// &lt;param name=&quot;position&quot;&gt;&lt;/param&gt;
    /// &lt;param name=&quot;endPos&quot;&gt;&lt;/param&gt;
    /// &lt;param name=&quot;direction&quot;&gt;&lt;/param&gt;
    private void IncrementValues(Vector position, Vector endPos, Vector direction) {

        bool xTest = position.x &gt; endPos.x;
        bool yTest = position.y &gt; endPos.y;

        for (int i = 0; ; i++) {
            position += direction.Normalized;

            IntCoords coords = Vector.PositionToCoords(position);

            if (coords.x &gt;= TankSettings.LevelWidth || coords.y &gt;= TankSettings.LevelHeight
                || coords.x &lt; 0 || coords.y &lt; 0) {
                break;
            }

            if (position.x &gt; endPos.x != xTest || position.y &gt; endPos.y != yTest) {
                break;
            }

            checker.CellBulletCounts[coords.x, coords.y]++;
        }
    }
}


    </pre>
    <script type="text/javascript">
      highlightRanges([[19,25,19,29,0],[19,30,19,42,0],[22,41,22,51,0],[22,60,22,78,0],[25,5,25,80,0],[25,81,25,82,0],[26,9,26,32,0],[27,9,27,25,0],[28,9,28,30,0],[29,5,29,6,0],[34,39,34,40,0],[36,9,36,23,0],[38,9,38,53,0],[39,9,39,63,0],[41,9,41,25,0],[42,5,42,6,0],[44,34,44,35,0],[46,9,46,67,0],[48,14,48,23,0],[48,25,48,46,0],[48,48,48,51,0],[48,53,48,54,0],[56,13,56,72,0],[56,73,56,74,0],[57,17,57,53,0],[58,17,58,23,0],[60,9,60,10,0],[61,5,61,6,0],[70,87,70,88,0],[73,9,73,129,0],[73,130,73,131,0],[74,13,74,67,0],[75,13,75,26,0],[78,9,78,70,0],[78,71,78,72,0],[79,13,79,26,0],[81,13,81,78,0],[84,13,84,136,0],[84,137,84,138,0],[85,17,85,92,0],[86,17,86,30,0],[88,9,88,10,0],[90,9,90,47,0],[92,9,92,36,0],[94,9,94,71,0],[96,9,96,56,0],[98,9,98,21,0],[99,5,99,6,0],[107,84,107,85,0],[109,9,109,44,0],[110,9,110,44,0],[112,14,112,23,0],[112,27,112,30,0],[112,32,112,33,0],[113,13,113,46,0],[115,13,115,66,0],[117,13,118,49,0],[118,50,118,51,0],[119,17,119,23,0],[122,13,122,82,0],[122,83,122,84,0],[123,17,123,23,0],[126,13,126,60,0],[127,9,127,10,0],[128,5,128,6,0]]);
    </script>
  </body>
</html>