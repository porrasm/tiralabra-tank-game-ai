<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>p:\stuff\projects\minigamesproject\minigamesproject\assets\_assets\scripts\games\tankgame\tankai\tankdfspath.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;

public class TankDFSPath : TankAIPathfinding {

    #region fields
    private byte[,] visited;

    private IntCoords start, end;

    private IntCoords coords;
    // Replace list
    public bool building;
    private Stack&lt;IntCoords&gt; route;

    private bool found;

    private FoundCondition foundCondition;
    #endregion

    public TankDFSPath(byte[,] level) :base(level) {

    }

    public override Vector[] FindPath(IntCoords start, IntCoords end, FoundCondition foundCondition) {
        this.start = start;
        this.end = end;

        this.foundCondition = foundCondition;

        visited = new byte[level.GetLength(0), level.GetLength(1)];
        route = new Stack&lt;IntCoords&gt;();

        found = false;

        Visit(start, 1);
        DFSRecursiveSearch(start, BestDirection2(start));

        // Replace this
        return route.Select(o =&gt; Vector.CoordsToPosition(o)).ToArray();
    }
    private void DFSRecursiveSearch(IntCoords coords, TankDirection direction) {

        if (foundCondition(coords)) {
            found = true;
            route.Push(coords);
            return;
        }

        if (found) {
            return;
        }

        IntCoords newCoords = coords.MoveToDirection(direction);


        if (InvalidCoords(newCoords, false)) {
            return;
        }

        Visit(newCoords, 1);
        route.Push(coords);   

        for (int i = 0; i &lt; 8; i++) {
            TankDirection newDirection = BestDirection2(newCoords);
            if (newDirection == TankDirection.None) {
                Visit(newCoords, 2);
                break;
            } else if (newDirection == TankDirection.Backtrack) {
                break;
            }
            DFSRecursiveSearch(newCoords, newDirection);
        }

        if (!found) {
            route.Pop();
        }
    }

    private TankDirection BestDirection2(IntCoords coords) {

        TankDirection optDirection = TankDirection.None;
        float distance = float.MaxValue;
        IntCoords shortestCoords = new IntCoords(0, 0);

        byte allowed = level[coords.x, coords.y];

        for (int i = 0; i &lt; 8; i++) {
            TankDirection direction = (TankDirection)i;

            if (!TankDirectionTools.AllowedDirection(allowed, direction)) {
                continue;
            }

            IntCoords newCoords = coords.MoveToDirection(direction);

            if (Visited(newCoords) &gt; 0) {
                continue;
            }

            float newDistance = Vector.Distance(Vector.CoordsToPosition(newCoords), Vector.CoordsToPosition(end));

            if (newDistance &lt; distance || (Visited(newCoords) == 0 &amp;&amp; newDistance &lt;= distance)) {
                distance = newDistance;
                optDirection = direction;
                shortestCoords = newCoords;
            }
        }

        return optDirection;
    }

    private int Visited(IntCoords coords) {
        return visited[coords.x, coords.y];
    }

    private void Visit(IntCoords coords, byte value) {
        visited[coords.x, coords.y] = value;
    }
    private bool InvalidCoords(IntCoords coords, bool strict) {

        bool ob = coords.x &lt; 0 || coords.x &gt;= level.GetLength(0) ||
            coords.y &lt; 0 || coords.y &gt;= level.GetLength(1);

        if (!ob) {
            int limit = 2;
            if (strict) {
                limit = 1;
            }
            return visited[coords.x, coords.y] &gt;= limit;
        }

        return true;
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[24,40,24,51,1],[24,52,24,53,1],[26,5,26,6,1],[28,102,28,103,1],[29,9,29,28,1],[30,9,30,24,1],[32,9,32,46,1],[34,9,34,68,1],[35,9,35,40,1],[37,9,37,23,1],[39,9,39,25,1],[40,9,40,58,1],[43,9,43,34,1],[43,34,43,60,1],[43,60,43,72,1],[43,9,43,72,1],[44,5,44,6,1],[45,80,45,81,1],[47,9,47,36,1],[47,37,47,38,1],[48,13,48,26,1],[49,13,49,32,1],[50,13,50,20,1],[53,9,53,19,1],[53,20,53,21,0],[54,13,54,20,0],[57,9,57,65,1],[60,9,60,45,1],[60,46,60,47,0],[61,13,61,20,0],[64,9,64,29,1],[65,9,65,28,1],[67,14,67,23,1],[67,25,67,30,1],[67,32,67,35,1],[67,37,67,38,1],[68,13,68,68,1],[69,13,69,52,1],[69,53,69,54,0],[70,17,70,37,0],[71,17,71,23,0],[72,20,72,64,1],[72,65,72,66,0],[73,17,73,23,0],[75,13,75,57,1],[76,9,76,10,1],[78,9,78,20,1],[78,21,78,22,0],[79,13,79,25,0],[80,9,80,10,0],[81,5,81,6,1],[83,60,83,61,1],[85,9,85,57,1],[86,9,86,41,1],[87,9,87,56,1],[89,9,89,50,1],[91,14,91,23,1],[91,25,91,30,1],[91,32,91,35,1],[91,37,91,38,1],[92,13,92,56,1],[94,13,94,74,1],[94,75,94,76,1],[95,17,95,26,1],[98,13,98,69,1],[100,13,100,40,1],[100,41,100,42,1],[101,17,101,26,1],[104,13,104,115,1],[106,13,106,96,1],[106,97,106,98,1],[107,17,107,40,1],[108,17,108,42,1],[109,17,109,44,1],[110,13,110,14,1],[111,9,111,10,1],[113,9,113,29,1],[114,5,114,6,1],[116,43,116,44,1],[117,9,117,44,1],[118,5,118,6,1],[120,54,120,55,1],[121,9,121,45,1],[122,5,122,6,1],[123,63,123,64,1],[125,9,126,60,1],[128,9,128,17,1],[128,18,128,19,1],[129,13,129,27,1],[130,13,130,24,1],[130,25,130,26,0],[131,17,131,27,0],[132,13,132,14,0],[133,13,133,57,1],[136,9,136,21,0],[137,5,137,6,1]]);
    </script>
  </body>
</html>