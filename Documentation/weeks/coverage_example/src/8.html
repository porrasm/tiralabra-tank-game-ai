<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>p:\stuff\projects\minigamesproject\minigamesproject\assets\_assets\scripts\bearded man studios\scripts\networking\forge\networking\udpclient.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
/*-----------------------------+-------------------------------\
|                                                              |
|                         !!!NOTICE!!!                         |
|                                                              |
|  These libraries are under heavy development so they are     |
|  subject to make many changes as development continues.      |
|  For this reason, the libraries may not be well commented.   |
|  THANK YOU for supporting forge with all your feedback       |
|  suggestions, bug reports and comments!                      |
|                                                              |
|                              - The Forge Team                |
|                                Bearded Man Studios, Inc.     |
|                                                              |
|  This source code, project files, and associated files are   |
|  copyrighted by Bearded Man Studios, Inc. (2012-2017) and    |
|  may not be redistributed without written permission.        |
|                                                              |
\------------------------------+------------------------------*/

using BeardedManStudios.Forge.Networking.Frame;
using BeardedManStudios.Forge.Networking.Nat;
using BeardedManStudios.Threading;
using System;
using System.Net;
using System.Net.Sockets;
using System.Threading;

namespace BeardedManStudios.Forge.Networking
{
	public class UDPClient : BaseUDP, IClient
	{
		/// &lt;summary&gt;
		/// The max amount of tries that this client will attempt to connect to the server
		/// where there is 3 seconds between each attempt
		/// &lt;/summary&gt;
		public const int CONNECT_TRIES = 10;

		/// &lt;summary&gt;
		/// The minimum size of a frame
		/// &lt;/summary&gt;
		private const int MINIMUM_FRAME_SIZE = 17;

		/// &lt;summary&gt;
		/// The hash that is / was validated by the server
		/// &lt;/summary&gt;
		private string headerHash = string.Empty;

		/// &lt;summary&gt;
		/// Used to determine if the client has requested to be accepted by the server
		/// &lt;/summary&gt;
		private bool headerExchanged = false;

		/// &lt;summary&gt;
		/// The identity of the server as a player
		/// &lt;/summary&gt;
		private NetworkingPlayer server = null;
		public NetworkingPlayer Server { get { return server; } }

		public UDPPacketManager packetManager = new UDPPacketManager();

		public NatHolePunch nat = new NatHolePunch();

		public event BaseNetworkEvent connectAttemptFailed;

		public override void Send(FrameStream frame, bool reliable = false)
		{
			UDPPacketComposer composer = new UDPPacketComposer();

			// If this message is reliable then make sure to keep a reference to the composer
			// so that there are not any run-away threads
			if (reliable)
			{
				// Use the completed event to clean up the object from memory
				composer.completed += ComposerCompleted;
				pendingComposers.Add(composer);
			}

			//TODO: New constructor for setting up callbacks before regular constructor (as seen above)
			composer.Init(this, Server, frame, reliable);
		}

		/// &lt;summary&gt;
		/// Sends binary message to the specified receiver(s)
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;receivers&quot;&gt;The clients / server to receive the message&lt;/param&gt;
		/// &lt;param name=&quot;messageGroupId&quot;&gt;The Binary.GroupId of the massage, use MessageGroupIds.START_OF_GENERIC_IDS + desired_id&lt;/param&gt;
		/// &lt;param name=&quot;reliable&quot;&gt;True if message must be delivered&lt;/param&gt;
		/// &lt;param name=&quot;objectsToSend&quot;&gt;Array of vars to be sent, read them with Binary.StreamData.GetBasicType&lt;typeOfObject&gt;()&lt;/param&gt;
		public virtual void Send(Receivers receivers = Receivers.Server, int messageGroupId = MessageGroupIds.START_OF_GENERIC_IDS, bool reliable = false , params object[] objectsToSend)
		{
			BMSByte data = ObjectMapper.BMSByte(objectsToSend);
			Binary sendFrame = new Binary(Time.Timestep, false, data, receivers, messageGroupId, false);
			Send(sendFrame, reliable);
		}

		/// &lt;summary&gt;
		/// This will connect a UDP client to a given UDP server
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;host&quot;&gt;The server&#39;s host address on the network&lt;/param&gt;
		/// &lt;param name=&quot;port&quot;&gt;The port that the server is hosting on&lt;/param&gt;
		/// &lt;param name=&quot;natHost&quot;&gt;The NAT server host address, if blank NAT will be skipped&lt;/param&gt;
		/// &lt;param name=&quot;natPort&quot;&gt;The port that the NAT server is hosting on&lt;/param&gt;
		/// &lt;param name=&quot;pendCreates&quot;&gt;Immidiately set the NetWorker::PendCreates to true&lt;/param&gt;
		public void Connect(string host, ushort port = DEFAULT_PORT, string natHost = &quot;&quot;, ushort natPort = NatHolePunch.DEFAULT_NAT_SERVER_PORT, bool pendCreates = false, ushort overrideBindingPort = DEFAULT_PORT + 1)
		{
			if (Disposed)
				throw new ObjectDisposedException(&quot;UDPClient&quot;, &quot;This object has been disposed and can not be used to connect, please use a new UDPClient&quot;);

			// By default pending creates should be true and flushed when ready
			if (!pendCreates)
				PendCreates = true;

			try
			{
				ushort clientPort = overrideBindingPort;

				// Make sure not to listen on the same port as the server for local networks
				if (clientPort == port)
					clientPort++;

				for (; ; clientPort++)
				{
					try
					{
						Client = new CachedUdpClient(clientPort);
						break;
					}
					catch
					{
						if (port == 0)
							throw new BaseNetworkException(&quot;There were no ports available starting from port &quot; + port);
					}
				}

				Client.EnableBroadcast = true;

				// If the server is behind a NAT, request for the port punch by the nat server
				if (!string.IsNullOrEmpty(natHost))
					nat.Connect(host, port, clientPort, natHost, natPort);

				// Do any generic initialization in result of the successful bind
				OnBindSuccessful();

				// Get a random hash key that needs to be used for validating that the server was connected to
				headerHash = Websockets.HeaderHashKey();

				// This is a typical Websockets accept header to be validated
				byte[] connectHeader = Websockets.ConnectionHeader(headerHash, port);

				try
				{
					// Setup the identity of the server as a player
					server = new NetworkingPlayer(0, host, true, ResolveHost(host, port), this);
				}
				catch (ArgumentException)
				{
					if (connectAttemptFailed != null)
						connectAttemptFailed(this);

					throw;
				}

				// Create the thread that will be listening for new data from connected clients and start its execution
				Task.Queue(ReadNetwork);

				//Let myself know I connected successfully
				OnPlayerConnected(server);

				// Set myself as a connected client
				server.Connected = true;

				//Set the port
				SetPort(clientPort);

				int connectCounter = 0;
				Task.Queue(() =&gt;
				{
					do
					{
						// Send the accept headers to the server to validate
						Client.Send(connectHeader, connectHeader.Length, Server.IPEndPointHandle);
						Thread.Sleep(3000);
					} while (!headerExchanged &amp;&amp; IsBound &amp;&amp; ++connectCounter &lt; CONNECT_TRIES);

					if (connectCounter &gt;= CONNECT_TRIES)
					{
						if (connectAttemptFailed != null)
							connectAttemptFailed(this);
					}
				});
			}
			catch (Exception e)
			{
				Logging.BMSLog.LogException(e);
				// Do any generic initialization in result of the binding failure
				OnBindFailure();

				throw new FailedBindingException(&quot;Failed to bind to host/port, see inner exception&quot;, e);
			}
		}

		/// &lt;summary&gt;
		/// Disconnect this client from the server
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;forced&quot;&gt;Used to tell if this disconnect was intentional &lt;c&gt;false&lt;/c&gt; or caused by an exception &lt;c&gt;true&lt;/c&gt;&lt;/param&gt;
		public override void Disconnect(bool forced)
		{
			if (Client == null)
				return;

			lock (Client)
			{
				if (forced)
					CloseConnection();
				else
				{
					var frame = new ConnectionClose(Time.Timestep, false, Receivers.Server, MessageGroupIds.DISCONNECT, false);
					Send(frame, true);
					Task.Queue(CloseConnection, 1000);
				}

				// Send signals to the methods registered to the disconnect events
				if (forced)
					//	OnDisconnected();
					//else
					OnForcedDisconnect();
			}
		}

		/// &lt;summary&gt;
		/// Infinite loop listening for new data from all connected clients on a separate thread.
		/// This loop breaks when readThreadCancel is set to true
		/// &lt;/summary&gt;
		private void ReadNetwork()
		{
			IPEndPoint groupEP = new IPEndPoint(IPAddress.Any, 0);
			string incomingEndpoint = string.Empty;

			try
			{
				BMSByte packet = null;
				// Intentional infinite loop
				while (IsBound)
				{
					// If the read has been flagged to be canceled then break from this loop
					if (readThreadCancel)
						return;

					try
					{
						// Read a packet from the network
						packet = Client.Receive(ref groupEP, ref incomingEndpoint);

						if (PacketLossSimulation &gt; 0.0f &amp;&amp; new Random().NextDouble() &lt;= PacketLossSimulation)
						{
							// Skip this message
							continue;
						}

						BandwidthIn += (ulong)packet.Size;
					}
					catch (SocketException /*ex*/)
					{
						// This is a common exception when we exit the blocking call
						//Logging.BMSLog.LogException(ex);
						Disconnect(true);
					}

					// Check to make sure a message was received
					if (packet == null || packet.Size &lt;= 0)
						continue;

					// This message was not from the server
					if (groupEP.Address != Server.IPEndPointHandle.Address &amp;&amp;
						groupEP.Port != Server.IPEndPointHandle.Port)
					{
						if (packet.Size == 1 &amp;&amp; (packet[0] == SERVER_BROADCAST_CODE || packet[1] == CLIENT_BROADCAST_CODE))
						{

						}
						else if (packet.Size.Between(2, 4) &amp;&amp; packet[0] == BROADCAST_LISTING_REQUEST_1 &amp;&amp; packet[1] == BROADCAST_LISTING_REQUEST_2 &amp;&amp; packet[2] == BROADCAST_LISTING_REQUEST_3)
						{
							// This may be a local listing request so respond with the client flag byte
							Client.Send(new byte[] { CLIENT_BROADCAST_CODE }, 1, groupEP);
						}

						continue;
					}

					// Check to see if the headers have been exchanged
					if (!headerExchanged)
					{
						if (Websockets.ValidateResponseHeader(headerHash, packet.CompressBytes()))
						{
							headerExchanged = true;

							// TODO:  When getting the user id, it should also get the server time
							// by using the current time in the payload and getting it back along with server time

							// Ping the server to finalize the player&#39;s connection
							Send(Text.CreateFromString(Time.Timestep, InstanceGuid.ToString(), false, Receivers.Server, MessageGroupIds.NETWORK_ID_REQUEST, false), true);
						}
						else if (packet.Size &gt;= MINIMUM_FRAME_SIZE)
						{
							// The server sent us a message before sending a responseheader to validate
							// This happens if the server is not accepting connections or the max connection count has been reached
							// We will get two messages. The first one is either a MAX_CONNECTIONS or NOT_ACCEPT_CONNECTIONS group message.
							// The second one will be the DISCONNECT message
							UDPPacket formattedPacket = TranscodePacket(Server, packet);

							if (formattedPacket.groupId == MessageGroupIds.MAX_CONNECTIONS) {
								Logging.BMSLog.LogWarning(&quot;Max Players Reached On Server&quot;);
								// Wait for the second message (Disconnect)
								continue;
							}

							if (formattedPacket.groupId == MessageGroupIds.NOT_ACCEPT_CONNECTIONS) {
								Logging.BMSLog.LogWarning(&quot;The server is busy and not accepting connections&quot;);
								// Wait for the second message (Disconnect)
								continue;
							}

                            if (formattedPacket.groupId == MessageGroupIds.DISCONNECT) {
								CloseConnection();
								return;
							}

							// Received something unexpected so do the same thing as the if below
							Disconnect(true);
							break;
						}
						else if (packet.Size != 1 || packet[0] != 0)
						{
							Disconnect(true);
							break;
						}
						else
							continue;
					}
					else
					{
						if (packet.Size &lt; MINIMUM_FRAME_SIZE)
							continue;

						// Format the byte data into a UDPPacket struct
						UDPPacket formattedPacket = TranscodePacket(Server, packet);

						// Check to see if this is a confirmation packet, which is just
						// a packet to say that the reliable packet has been read
						if (formattedPacket.isConfirmation)
						{
							if (formattedPacket.groupId == MessageGroupIds.DISCONNECT)
							{
								CloseConnection();
								return;
							}

							OnMessageConfirmed(server, formattedPacket);
							continue;
						}

                        if (formattedPacket.groupId == MessageGroupIds.AUTHENTICATION_FAILURE)
                        {
                            Logging.BMSLog.LogWarning(&quot;The server rejected the authentication attempt&quot;);
                            // Wait for the second message (Disconnect)
                            continue;
                        }

                        // Add the packet to the manager so that it can be tracked and executed on complete
                        packetManager.AddPacket(formattedPacket, PacketSequenceComplete, this);
					}
				}
			}
			catch (Exception ex)
			{
				Logging.BMSLog.LogException(ex);
				Disconnect(true);
			}
		}

		private void PacketSequenceComplete(BMSByte data, int groupId, byte receivers, bool isReliable)
		{
			// Pull the frame from the sent message
			FrameStream frame = Factory.DecodeMessage(data.CompressBytes(), false, groupId, Server, receivers);

			if (isReliable)
			{
				frame.ExtractReliableId();

				// TODO:  If the current reliable index for this player is not at
				// the specified index, then it needs to wait for the correct ordering
				Server.WaitReliable(frame);
			}
			else
				FireRead(frame, Server);
		}

		private void CloseConnection()
		{
			nat.Disconnect();

			if (Client == null)
				return;

			OnDisconnected();

			// Close our CachedUDPClient so that it can no longer be used
			Client.Close();
			Client = null;
		}

		/// &lt;summary&gt;
		/// Request the ping from the server (pingReceived will be triggered if it receives it)
		/// This is not a reliable call
		/// &lt;/summary&gt;
		public override void Ping()
		{
			Send(GeneratePing());
		}

		/// &lt;summary&gt;
		/// A ping was receieved from the server so we need to respond with the pong
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;playerRequesting&quot;&gt;The server&lt;/param&gt;
		/// &lt;param name=&quot;time&quot;&gt;The time that the ping was received for&lt;/param&gt;
		protected override void Pong(NetworkingPlayer playerRequesting, DateTime time)
		{
			Send(GeneratePong(time));
		}

		public override void FireRead(FrameStream frame, NetworkingPlayer currentPlayer)
		{
			if (frame is ConnectionClose)
			{
				CloseConnection();
				return;
			}

            if(frame.GroupId == MessageGroupIds.AUTHENTICATION_CHALLENGE)
            {
                if ((Me != null &amp;&amp; Me.Connected) || authenticator == null)
                    return;

                authenticator.AcceptChallenge(this, frame.StreamData, AuthServer, RejectServer);

                return;
            }

			// Send an event off that a packet has been read
			OnMessageReceived(currentPlayer, frame);
		}

        /// &lt;summary&gt;
        /// Callback for user auth. Sends an authentication response to the server.
        /// &lt;/summary&gt;
        private void AuthServer(BMSByte buffer)
        {
            Send(new Binary(Time.Timestep, false, buffer, Receivers.Server, MessageGroupIds.AUTHENTICATION_RESPONSE, false), true);
        }

        /// &lt;summary&gt;
        /// Callback for user auth. Disconnects the user from an invalid server.
        /// &lt;/summary&gt;
        private void RejectServer()
        {
            Disconnect(true);
        }
    }
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[46,3,46,44,0],[51,3,51,40,0],[56,3,56,42,0],[57,40,57,41,0],[57,42,57,56,0],[57,57,57,58,0],[59,3,59,66,0],[61,3,61,48,0],[66,3,66,4,0],[67,4,67,57,0],[71,4,71,17,0],[72,4,72,5,0],[74,5,74,45,0],[75,5,75,36,0],[76,4,76,5,0],[79,4,79,49,0],[80,3,80,4,0],[90,3,90,4,0],[91,4,91,55,0],[92,4,92,96,0],[93,4,93,30,0],[94,3,94,4,0],[105,3,105,4,0],[106,4,106,17,0],[107,5,107,144,0],[110,4,110,21,0],[111,5,111,24,0],[114,4,114,5,0],[115,5,115,45,0],[118,5,118,28,0],[119,6,119,19,0],[121,14,121,26,0],[122,5,122,6,0],[124,6,124,7,0],[125,7,125,48,0],[126,7,126,13,0],[128,6,128,11,0],[129,6,129,7,0],[130,7,130,21,0],[131,8,131,99,0],[132,6,132,7,0],[133,5,133,6,0],[135,5,135,35,0],[138,5,138,40,0],[139,6,139,60,0],[142,5,142,24,0],[145,5,145,45,0],[148,5,148,74,0],[151,5,151,6,0],[153,6,153,82,0],[154,5,154,6,0],[155,5,155,30,0],[156,5,156,6,0],[157,6,157,39,0],[158,7,158,34,0],[160,6,160,12,0],[164,5,164,29,0],[167,5,167,31,0],[170,5,170,29,0],[173,5,173,25,0],[175,5,175,28,0],[176,5,177,5,0],[177,5,177,6,0],[177,6,179,6,0],[179,6,179,7,0],[179,7,181,7,0],[181,7,181,81,0],[181,81,182,7,0],[182,7,182,26,0],[182,26,183,6,0],[183,6,183,7,0],[183,7,183,8,0],[183,8,183,80,0],[183,80,185,6,0],[185,6,185,42,0],[185,42,186,6,0],[186,6,186,7,0],[186,7,187,7,0],[187,7,187,40,0],[187,40,188,8,0],[188,8,188,35,0],[188,35,189,6,0],[189,6,189,7,0],[189,7,190,5,0],[190,5,190,6,0],[190,6,190,8,0],[176,5,190,8,0],[191,4,191,5,0],[192,4,192,23,0],[193,4,193,5,0],[194,5,194,36,0],[196,5,196,21,0],[198,5,198,93,0],[200,3,200,4,0],[207,3,207,4,0],[208,4,208,23,0],[209,5,209,12,0],[211,4,211,17,0],[212,4,212,5,0],[213,5,213,16,0],[214,6,214,24,0],[216,5,216,6,0],[217,6,217,113,0],[218,6,218,24,0],[219,6,219,40,0],[220,5,220,6,0],[223,5,223,16,0],[226,6,226,27,0],[227,4,227,5,0],[228,3,228,4,0],[235,3,235,4,0],[236,4,236,58,0],[237,4,237,43,0],[240,4,240,5,0],[241,5,241,27,0],[243,5,243,20,0],[244,5,244,6,0],[246,6,246,27,0],[247,7,247,14,0],[250,6,250,7,0],[252,7,252,66,0],[254,7,254,92,0],[255,7,255,8,0],[257,8,257,17,0],[260,7,260,41,0],[261,6,261,7,0],[262,6,262,36,0],[263,6,263,7,0],[266,7,266,24,0],[267,6,267,7,0],[270,6,270,45,0],[271,7,271,16,0],[274,6,275,52,0],[276,6,276,7,0],[277,7,277,106,0],[278,7,278,8,0],[280,7,280,8,0],[281,12,281,174,0],[282,7,282,8,0],[284,8,284,70,0],[285,7,285,8,0],[287,7,287,16,0],[291,6,291,27,0],[292,6,292,7,0],[293,7,293,81,0],[294,7,294,8,0],[295,8,295,31,0],[301,8,301,150,0],[302,7,302,8,0],[303,12,303,50,0],[304,7,304,8,0],[309,8,309,68,0],[311,8,311,71,0],[311,72,311,73,0],[312,9,312,68,0],[314,9,314,18,0],[317,8,317,78,0],[317,79,317,80,0],[318,9,318,87,0],[320,9,320,18,0],[323,29,323,87,0],[323,88,323,89,0],[324,9,324,27,0],[325,9,325,16,0],[329,8,329,25,0],[330,8,330,14,0],[332,12,332,51,0],[333,7,333,8,0],[334,8,334,25,0],[335,8,335,14,0],[338,8,338,17,0],[339,6,339,7,0],[341,6,341,7,0],[342,7,342,44,0],[343,8,343,17,0],[346,7,346,67,0],[350,7,350,42,0],[351,7,351,8,0],[352,8,352,66,0],[353,8,353,9,0],[354,9,354,27,0],[355,9,355,16,0],[358,8,358,52,0],[359,8,359,17,0],[362,25,362,95,0],[363,25,363,26,0],[364,29,364,105,0],[366,29,366,38,0],[370,25,370,96,0],[371,6,371,7,0],[372,5,372,6,0],[373,4,373,5,0],[374,4,374,24,0],[375,4,375,5,0],[376,5,376,37,0],[377,5,377,22,0],[378,4,378,5,0],[379,3,379,4,0],[382,3,382,4,0],[384,4,384,103,0],[386,4,386,19,0],[387,4,387,5,0],[388,5,388,31,0],[392,5,392,32,0],[393,4,393,5,0],[395,5,395,29,0],[396,3,396,4,0],[399,3,399,4,0],[400,4,400,21,0],[402,4,402,23,0],[403,5,403,12,0],[405,4,405,21,0],[408,4,408,19,0],[409,4,409,18,0],[410,3,410,4,0],[417,3,417,4,0],[418,4,418,25,0],[419,3,419,4,0],[427,3,427,4,0],[428,4,428,29,0],[429,3,429,4,0],[432,3,432,4,0],[433,4,433,33,0],[434,4,434,5,0],[435,5,435,23,0],[436,5,436,12,0],[439,13,439,74,0],[440,13,440,14,0],[441,17,441,75,0],[442,21,442,28,0],[444,17,444,97,0],[446,17,446,24,0],[450,4,450,44,0],[451,3,451,4,0],[457,9,457,10,0],[458,13,458,132,0],[459,9,459,10,0],[465,9,465,10,0],[466,13,466,30,0],[467,9,467,10,0]]);
    </script>
  </body>
</html>