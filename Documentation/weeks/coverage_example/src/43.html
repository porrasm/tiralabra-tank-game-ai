<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>p:\stuff\projects\minigamesproject\minigamesproject\assets\_assets\scripts\bearded man studios\scripts\networking\forge\networking\frame\framestream.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
/*-----------------------------+-------------------------------\
|                                                              |
|                         !!!NOTICE!!!                         |
|                                                              |
|  These libraries are under heavy development so they are     |
|  subject to make many changes as development continues.      |
|  For this reason, the libraries may not be well commented.   |
|  THANK YOU for supporting forge with all your feedback       |
|  suggestions, bug reports and comments!                      |
|                                                              |
|                              - The Forge Team                |
|                                Bearded Man Studios, Inc.     |
|                                                              |
|  This source code, project files, and associated files are   |
|  copyrighted by Bearded Man Studios, Inc. (2012-2017) and    |
|  may not be redistributed without written permission.        |
|                                                              |
\------------------------------+------------------------------*/

using System;

namespace BeardedManStudios.Forge.Networking.Frame
{
	public abstract class FrameStream : ICloneable
	{
		/// &lt;summary&gt;
		/// Get the control byte for this frame
		/// &lt;/summary&gt;
		public abstract byte ControlByte { get; }

		/// &lt;summary&gt;
		/// The current raw data for this
		/// &lt;/summary&gt;
		public BMSByte StreamData { get; protected set; }

		/// &lt;summary&gt;
		/// The mask that is used to mask this frame
		/// &lt;/summary&gt;
		protected byte[] mask = new byte[0];

		/// &lt;summary&gt;
		/// Used to track where the payload starts in this frame
		/// &lt;/summary&gt;
		private int payloadStart = 0;

		/// &lt;summary&gt;
		/// This is the time step for this frame in milliseconds
		/// &lt;/summary&gt;
		public ulong TimeStep { get; protected set; }

		/// &lt;summary&gt;
		/// The Unique id for this frame
		/// &lt;/summary&gt;
		public ulong UniqueId { get; protected set; }

		public bool IsReliable { get; private set; }

		private BMSByte reliableCloneData = new BMSByte();

		/// &lt;summary&gt;
		/// The unique reliable id for this frame
		/// &lt;/summary&gt;
		public ulong UniqueReliableId { get; protected set; }

		/// &lt;summary&gt;
		/// This is a user controlled byte that allows binary frames to be routed by the user
		/// &lt;/summary&gt;
		public byte RouterId { get; protected set; }

		/// &lt;summary&gt;
		/// An id to point to where in the code that this message is coming from (unique)
		/// &lt;/summary&gt;
		public int GroupId { get; private set; }

		/// &lt;summary&gt;
		/// The type of receivers for this frame
		/// &lt;/summary&gt;
		public Receivers Receivers { get; private set; }

		/// &lt;summary&gt;
		/// The player that sent the message on the network
		/// &lt;/summary&gt;
		public NetworkingPlayer Sender { get; private set; }

		/// &lt;summary&gt;
		/// This is the unique message id for this message
		/// &lt;/summary&gt;
		public static ulong UniqueMessageIdCounter { get; private set; }

		/// &lt;summary&gt;
		/// A method to assign the sender (only should be done on server)
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;sender&quot;&gt;The sender to be assigned&lt;/param&gt;
		public void SetSender(NetworkingPlayer sender)
		{
			Sender = sender;
		}

		public FrameStream() { }

		/// &lt;summary&gt;
		/// This constructor will take a payload and create a new frame with the appropriate structure
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;timestep&quot;&gt;The timestep that this frame is created within&lt;/param&gt;
		/// &lt;param name=&quot;useMask&quot;&gt;If set to &lt;c&gt;true&lt;/c&gt; a mask will be used to encode the payload.&lt;/param&gt;
		/// &lt;param name=&quot;routerId&quot;&gt;A byte that can be used to route data within a user program&lt;/param&gt;
		public FrameStream(ulong timestep, bool useMask, Receivers receivers, int groupId, bool isStream
			, byte routerId = 0)
		{
			CreateFrame(useMask, timestep, new byte[0], receivers, groupId, routerId, isStream);
		}

		/// &lt;summary&gt;
		/// This constructor will take a payload and create a new frame with the appropriate structure
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;timestep&quot;&gt;The timestep that this frame is created within&lt;/param&gt;
		/// &lt;param name=&quot;useMask&quot;&gt;If set to &lt;c&gt;true&lt;/c&gt; a mask will be used to encode the payload.&lt;/param&gt;
		/// &lt;param name=&quot;payload&quot;&gt;The new frame initial data data&lt;/param&gt;
		/// &lt;param name=&quot;routerId&quot;&gt;A byte that can be used to route data within a user program&lt;/param&gt;
		public FrameStream(ulong timestep, bool useMask, byte[] payload, Receivers receivers, int groupId, bool isStream, byte routerId = 0)
		{
			if (payload == null)
				// TODO:  Throw frame exception
				throw new BaseNetworkException(&quot;The payload for the frame is not allowed to be null, otherwise use other constructor&quot;);

			CreateFrame(useMask, timestep, payload, receivers, groupId, routerId, isStream);
		}

		/// &lt;summary&gt;
		/// This constructor will take a payload and create a new frame with the appropriate structure
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;timestep&quot;&gt;The timestep that this frame is created within&lt;/param&gt;
		/// &lt;param name=&quot;useMask&quot;&gt;If set to &lt;c&gt;true&lt;/c&gt; a mask will be used to encode the payload.&lt;/param&gt;
		/// &lt;param name=&quot;payload&quot;&gt;The new frame initial data data&lt;/param&gt;
		/// &lt;param name=&quot;routerId&quot;&gt;A byte that can be used to route data within a user program&lt;/param&gt;
		public FrameStream(ulong timestep, bool useMask, BMSByte payload, Receivers receivers, int groupId, bool isStream, byte routerId = 0)
		{
			if (payload == null)
				// TODO:  Throw frame exception
				throw new BaseNetworkException(&quot;The payload for the frame is not allowed to be null, otherwise use other constructor&quot;);

			CreateFrame(useMask, timestep, payload.CompressBytes(), receivers, groupId, routerId, isStream);
		}

		/// &lt;summary&gt;
		/// Take an existing byte[] frame and map it to this data type
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;frame&quot;&gt;&lt;/param&gt;
		/// &lt;param name=&quot;payloadStart&quot;&gt;&lt;/param&gt;
		public FrameStream(byte[] frame, int payloadStart, int groupId, NetworkingPlayer sender, byte receivers = 255)
		{
			GroupId = groupId;
			Sender = sender;
			StreamData = new BMSByte();
			ReadFrame(frame, payloadStart, receivers);
		}

		/// &lt;summary&gt;
		/// Take an existing byte[] frame and map it to this data type
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;frame&quot;&gt;The existing frame data&lt;/param&gt;
		/// &lt;param name=&quot;payloadStart&quot;&gt;The index that the payload starts at in the frame byte[]&lt;/param&gt;
		protected virtual void ReadFrame(byte[] frame, int payloadStart, byte receivers)
		{
			// The end of the frame payload is just before the unique id
			int end = frame.Length - (sizeof(ulong) * 2);
            bool isStream = receivers == 255;

            // If the receivers is invalid, pull it from the data
            if (isStream)
			{
                end -= 1;
				Receivers = (Receivers)frame[end];
				//end--;
			}
			else
				Receivers = (Receivers)receivers;

			// If an empty frame was sent, do not copy it to data as data is already empty
			if (frame.Length - payloadStart &gt; end)
				StreamData.BlockCopy(frame, payloadStart, end - payloadStart);

            if (isStream)
                end += 1;

			// Pull the time step for this frame
			TimeStep = BitConverter.ToUInt64(frame, end);

			// Pull the unique id for this frame
			UniqueId = BitConverter.ToUInt64(frame, end + sizeof(ulong));
		}

		/// &lt;summary&gt;
		/// Creates the frame data using the passed in payload
		/// &lt;/summary&gt;
		private void CreateFrame(bool useMask, ulong timestep, byte[] payload, Receivers receivers, int groupId, byte routerId, bool isStream)
		{
			// If we are to use a mask then generate a random mask
			if (useMask)
			{
				mask = new byte[4];
				new Random().NextBytes(mask);
			}

			StreamData = new BMSByte();

			TimeStep = timestep;
			GroupId = groupId;
			RouterId = routerId;
			Receivers = receivers;
			UniqueId = UniqueMessageIdCounter++;

			// Generate the frame identity
			byte[] frame = new byte[10];

			// The first byte of the data is always the control byte, which dictates the message type
			frame[0] = ControlByte;

			int length = payload.Length;

			if (isStream)
				length += 21;  // Group id (4), receivers (1), time step (8), unique id (8)
            else
                length += 16; // time step (8), unique id (8)

            if (frame[0] == Binary.CONTROL_BYTE)
				length += 1;

			// Determine the length of the payload
			int dataStartIndex = 0;
			if (length &lt;= 125)
			{
				frame[1] = (byte)(useMask ? length | 128 : length);
				dataStartIndex = 2;
			}
			else if (length &gt;= 126 &amp;&amp; length &lt;= 65535)
			{
				dataStartIndex = 4;
				frame[1] = (byte)(useMask ? 254 : 126);
			}
			else
			{
				dataStartIndex = 10;
				frame[1] = (byte)(useMask ? 255 : 127);
			}

			// If the payload is greater than a byte (255) then set the order of the bytes for the length
			if (dataStartIndex &gt; 2)
			{
                int i = 0, j = 2, largestBitIndex = (dataStartIndex - 3) * 8;

                // Little endian / Big endian reversal based on mask
                //if (mask.Length == 0)
                //{
                for (i = largestBitIndex; i &gt;= 0; i -= 8)
                    frame[j++] = (byte)((((long) length) &gt;&gt; i) &amp; 255);
                //} else
                //{
                //    for (i = 0; i &lt;= largestBitIndex; i += 8)
                //        frame[j++] = (byte)((payload.Length &gt;&gt; i) &amp; 255);
                //}
            }

			// Prepare the stream data with the size so that it doesn&#39;t have to keep resizing
			StreamData.SetSize(dataStartIndex + mask.Length + length);
			StreamData.Clear();

			// Add the frame bytes
			StreamData.BlockCopy(frame, 0, dataStartIndex);

			// Add the mask bytes
			StreamData.BlockCopy(mask, 0, mask.Length);

			// Setup the int that tracks where the payload begins
			payloadStart = dataStartIndex + mask.Length;

			// If we are on a stream then use groupId
			if (isStream)
			{
				StreamData.BlockCopy(BitConverter.GetBytes(groupId), 0, sizeof(int));
				payloadStart += sizeof(int);
			}

			// Copy the routerId if this is a binary frame
			if (frame[0] == Binary.CONTROL_BYTE)
			{
				StreamData.BlockCopy(new byte[1] { routerId }, 0, sizeof(byte));
				payloadStart += 1;
			}

			// Add the initial payload bytes
			StreamData.BlockCopy(payload, 0, payload.Length);

			if (isStream)
				StreamData.BlockCopy(new byte[1] { (byte)Receivers }, 0, sizeof(byte));

			// Add the time step to the end of the frame
			StreamData.BlockCopy&lt;ulong&gt;(TimeStep, sizeof(ulong));

			// Add the unique message id for this frame just before the timestep frame
			StreamData.BlockCopy&lt;ulong&gt;(UniqueId, sizeof(ulong));

			if (mask.Length &gt; 0)
			{
				for (int i = dataStartIndex + mask.Length, j = 0; i &lt; StreamData.Size; i++, j++)
					StreamData.byteArr[i] = (byte)(StreamData.byteArr[i] ^ mask[j % 4]);
			}
		}

		private void MakeReliable(NetworkingPlayer player)
		{
			UniqueReliableId = player.GetNextReliableId();
			IsReliable = true;
		}

		/// &lt;summary&gt;
		/// Gets the raw data for this frame
		/// &lt;/summary&gt;
		/// &lt;returns&gt;The raw byte data prepared by this frame&lt;/returns&gt;
		public byte[] GetData(bool makeReliable = false, NetworkingPlayer player = null)
		{
			if (makeReliable)
			{
				MakeReliable(player);
				reliableCloneData.Clone(StreamData);

				reliableCloneData.InsertRange(StreamData.Size - (sizeof(ulong) * 2), BitConverter.GetBytes(UniqueReliableId));
				return reliableCloneData.CompressBytes();
			}

			return StreamData.CompressBytes();
		}

		protected FrameStream BaseClone(FrameStream target)
		{
			target.StreamData = new BMSByte();
			target.StreamData.Clone(StreamData);
			target.mask = mask;
			target.payloadStart = payloadStart;
			target.TimeStep = TimeStep;
			target.UniqueId = UniqueId;
			target.RouterId = RouterId;
			target.GroupId = GroupId;
			target.Receivers = Receivers;
			target.Sender = Sender;

			return target;
		}

		public void ExtractReliableId()
		{
			// We&#39;ve already made this frame reliable
			if (IsReliable)
				return;

			int currentIndex = StreamData.StartIndex();
			StreamData.MoveStartIndex((StreamData.Size - currentIndex - sizeof(ulong)));
			UniqueReliableId = ObjectMapper.Instance.Map&lt;ulong&gt;(StreamData);
			StreamData.MoveStartIndex(-StreamData.StartIndex() + currentIndex);
			IsReliable = true;
		}

		public abstract object Clone();
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[34,31,34,35,0],[34,36,34,50,0],[39,3,39,39,0],[39,3,39,39,0],[39,3,39,39,0],[39,3,39,39,0],[39,3,39,39,0],[44,3,44,32,0],[44,3,44,32,0],[44,3,44,32,0],[44,3,44,32,0],[44,3,44,32,0],[49,27,49,31,0],[49,32,49,46,0],[54,27,54,31,0],[54,32,54,46,0],[56,28,56,32,0],[56,33,56,45,0],[58,3,58,53,0],[58,3,58,53,0],[58,3,58,53,0],[58,3,58,53,0],[58,3,58,53,0],[63,35,63,39,0],[63,40,63,54,0],[68,26,68,30,0],[68,31,68,45,0],[73,24,73,28,0],[73,29,73,41,0],[78,32,78,36,0],[78,37,78,49,0],[83,36,83,40,0],[83,41,83,53,0],[88,48,88,52,0],[88,53,88,65,0],[95,3,95,4,0],[96,4,96,20,0],[97,3,97,4,0],[99,3,99,23,0],[99,24,99,25,0],[99,26,99,27,0],[107,3,108,24,0],[109,3,109,4,0],[110,4,110,88,0],[111,3,111,4,0],[120,3,120,135,0],[121,3,121,4,0],[122,4,122,24,0],[124,5,124,124,0],[126,4,126,84,0],[127,3,127,4,0],[136,3,136,136,0],[137,3,137,4,0],[138,4,138,24,0],[140,5,140,124,0],[142,4,142,100,0],[143,3,143,4,0],[150,3,150,113,0],[151,3,151,4,0],[152,4,152,22,0],[153,4,153,20,0],[154,4,154,31,0],[155,4,155,46,0],[156,3,156,4,0],[164,3,164,4,0],[166,4,166,49,0],[167,13,167,46,0],[170,13,170,26,0],[171,4,171,5,0],[172,17,172,26,0],[173,5,173,39,0],[175,4,175,5,0],[177,5,177,38,0],[180,4,180,42,0],[181,5,181,67,0],[183,13,183,26,0],[184,17,184,26,0],[187,4,187,49,0],[190,4,190,65,0],[191,3,191,4,0],[197,3,197,4,0],[199,4,199,16,0],[200,4,200,5,0],[201,5,201,24,0],[202,5,202,34,0],[203,4,203,5,0],[205,4,205,31,0],[207,4,207,24,0],[208,4,208,22,0],[209,4,209,24,0],[210,4,210,26,0],[211,4,211,40,0],[214,4,214,32,0],[217,4,217,27,0],[219,4,219,32,0],[221,4,221,17,0],[222,5,222,18,0],[224,17,224,30,0],[226,13,226,49,0],[227,5,227,17,0],[230,4,230,27,0],[231,4,231,22,0],[232,4,232,5,0],[233,5,233,56,0],[234,5,234,24,0],[235,4,235,5,0],[236,9,236,46,0],[237,4,237,5,0],[238,5,238,24,0],[239,5,239,44,0],[240,4,240,5,0],[242,4,242,5,0],[243,5,243,25,0],[244,5,244,44,0],[245,4,245,5,0],[248,4,248,27,0],[249,4,249,5,0],[250,17,250,26,0],[250,28,250,33,0],[250,35,250,77,0],[255,22,255,41,0],[255,43,255,49,0],[255,51,255,57,0],[256,21,256,71,0],[262,13,262,14,0],[265,4,265,62,0],[266,4,266,23,0],[269,4,269,51,0],[272,4,272,47,0],[275,4,275,48,0],[278,4,278,17,0],[279,4,279,5,0],[280,5,280,74,0],[281,5,281,33,0],[282,4,282,5,0],[285,4,285,40,0],[286,4,286,5,0],[287,5,287,69,0],[288,5,288,23,0],[289,4,289,5,0],[292,4,292,53,0],[294,4,294,17,0],[295,5,295,76,0],[298,4,298,57,0],[301,4,301,57,0],[303,4,303,24,0],[304,4,304,5,0],[305,10,305,46,0],[305,48,305,53,0],[305,55,305,74,0],[305,76,305,79,0],[305,81,305,84,0],[306,6,306,74,0],[307,4,307,5,0],[308,3,308,4,0],[311,3,311,4,0],[312,4,312,50,0],[313,4,313,22,0],[314,3,314,4,0],[321,3,321,4,0],[322,4,322,21,0],[323,4,323,5,0],[324,5,324,26,0],[325,5,325,41,0],[327,5,327,115,0],[328,5,328,46,0],[331,4,331,38,0],[332,3,332,4,0],[335,3,335,4,0],[336,4,336,38,0],[337,4,337,40,0],[338,4,338,23,0],[339,4,339,39,0],[340,4,340,31,0],[341,4,341,31,0],[342,4,342,31,0],[343,4,343,29,0],[344,4,344,33,0],[345,4,345,27,0],[347,4,347,18,0],[348,3,348,4,0],[351,3,351,4,0],[353,4,353,19,0],[354,5,354,12,0],[356,4,356,47,0],[357,4,357,80,0],[358,4,358,68,0],[359,4,359,71,0],[360,4,360,22,0],[361,3,361,4,0]]);
    </script>
  </body>
</html>