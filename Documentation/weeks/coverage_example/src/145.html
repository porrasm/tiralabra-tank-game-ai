<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>p:\stuff\projects\minigamesproject\minigamesproject\assets\_assets\scripts\bearded man studios\scripts\networking\forge\networking\networker.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
/*-----------------------------+-------------------------------\
|                                                              |
|                         !!!NOTICE!!!                         |
|                                                              |
|  These libraries are under heavy development so they are     |
|  subject to make many changes as development continues.      |
|  For this reason, the libraries may not be well commented.   |
|  THANK YOU for supporting forge with all your feedback       |
|  suggestions, bug reports and comments!                      |
|                                                              |
|                              - The Forge Team                |
|                                Bearded Man Studios, Inc.     |
|                                                              |
|  This source code, project files, and associated files are   |
|  copyrighted by Bearded Man Studios, Inc. (2012-2017) and    |
|  may not be redistributed without written permission.        |
|                                                              |
\------------------------------+------------------------------*/

using BeardedManStudios.Forge.Networking.DataStore;
using BeardedManStudios.Forge.Networking.Frame;
using BeardedManStudios.Source.Forge.Networking;
using BeardedManStudios.Threading;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Net.NetworkInformation;
using System.Net.Sockets;
using System.Threading;
using Ping = BeardedManStudios.Forge.Networking.Frame.Ping;

namespace BeardedManStudios.Forge.Networking
{
	public abstract class NetWorker
	{
		public const byte SERVER_BROADCAST_CODE = 42;
		public const byte CLIENT_BROADCAST_CODE = 24;

		public const byte BROADCAST_LISTING_REQUEST_1 = 42;
		public const byte BROADCAST_LISTING_REQUEST_2 = 24;
		public const byte BROADCAST_LISTING_REQUEST_3 = 9;

		public const ushort DEFAULT_PORT = 15937;

		private static List&lt;CachedUdpClient&gt; localListingsClientList = new List&lt;CachedUdpClient&gt;();

		public static IPEndPoint ResolveHost(string host, ushort port)
		{
			// Check for any localhost type addresses
			if (host == &quot;0.0.0.0&quot; || host == &quot;127.0.0.1&quot; || host == &quot;::0&quot;)
				return new IPEndPoint(IPAddress.Parse(host), port);
			else if (host == &quot;localhost&quot;)
				return new IPEndPoint(IPAddress.Parse(&quot;127.0.0.1&quot;), port);

			IPAddress ipAddress;

			if (!IPAddress.TryParse(host, out ipAddress))
			{
				IPHostEntry hostCheck = Dns.GetHostEntry(Dns.GetHostName());
				foreach (IPAddress ip in hostCheck.AddressList)
				{
					if (ip.AddressFamily == AddressFamily.InterNetwork)
					{
						if (ip.ToString() == host)
							return new IPEndPoint(IPAddress.Parse(&quot;127.0.0.1&quot;), port);
					}
				}

				try
				{
					IPHostEntry ipHostInfo = Dns.GetHostEntry(host);
					ipAddress = ipHostInfo.AddressList[0];
				}
				catch
				{
					Logging.BMSLog.Log(&quot;Failed to find host&quot;);
					throw new ArgumentException(&quot;Unable to resolve host&quot;);
				}
			}

			return new IPEndPoint(ipAddress, port);
		}

		public struct BroadcastEndpoints
		{
			public string Address { get; private set; }
			public ushort Port { get; private set; }
			public bool IsServer { get; private set; }

			public BroadcastEndpoints(string address, ushort port, bool isServer) : this()
			{
				this.Address = address;
				this.Port = port;
				this.IsServer = isServer;
			}
		}

		public static List&lt;BroadcastEndpoints&gt; LocalEndpoints { get; private set; }

		public static bool EndingSession { get; private set; }

		#region Delegates
		/// &lt;summary&gt;
		/// A base delegate for any kind of network event
		/// &lt;/summary&gt;
		public delegate void BaseNetworkEvent(NetWorker sender);

		/// &lt;summary&gt;
		/// Used to fire events that relate to a broadcast endpoint
		/// &lt;/summary&gt;
		public delegate void BroadcastEndpointEvent(BroadcastEndpoints endpoint, NetWorker sender);

		/// &lt;summary&gt;
		/// A base delegate for any kind of network ping event
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;ping&quot;&gt;The latency between client and server&lt;/param&gt;
		public delegate void PingEvent(double ping, NetWorker sender);

		/// &lt;summary&gt;
		/// Used for any events that relate to a NetworkingPlayer
		/// &lt;/summary&gt;
		public delegate void PlayerEvent(NetworkingPlayer player, NetWorker sender);

		/// &lt;summary&gt;
		/// Used for any events that relate to a frame and the target player
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;player&quot;&gt;The player the message came from&lt;/param&gt;
		/// &lt;param name=&quot;frame&quot;&gt;The frame data&lt;/param&gt;
		public delegate void FrameEvent(NetworkingPlayer player, FrameStream frame, NetWorker sender);

		/// &lt;summary&gt;
		/// Used for any events that relate to a binary frame and the target player
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;player&quot;&gt;The player the message came from&lt;/param&gt;
		/// &lt;param name=&quot;frame&quot;&gt;The frame data&lt;/param&gt;
		public delegate void BinaryFrameEvent(NetworkingPlayer player, Binary frame, NetWorker sender);

		/// &lt;summary&gt;
		/// Used for any events that relate to a text frame and the target player
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;player&quot;&gt;The player the message came from&lt;/param&gt;
		/// &lt;param name=&quot;frame&quot;&gt;The frame data&lt;/param&gt;
		public delegate void TextFrameEvent(NetworkingPlayer player, Text frame, NetWorker sender);
		#endregion

		#region Events
		/// &lt;summary&gt;
		/// Occurs when a local server has been located by calling the static SetupLocalUdpListings method
		/// &lt;/summary&gt;
		public static event BroadcastEndpointEvent localServerLocated;

		/// &lt;summary&gt;
		/// Occurs when tcp listener has successfully bound
		/// &lt;/summary&gt;
		public event BaseNetworkEvent bindSuccessful;

		/// &lt;summary&gt;
		/// Occurs when tcp listener has failed to bind
		/// &lt;/summary&gt;
		public event BaseNetworkEvent bindFailure;

		/// &lt;summary&gt;
		/// Occurs when the server has accepted this client
		/// &lt;/summary&gt;
		public event BaseNetworkEvent serverAccepted;

		/// &lt;summary&gt;
		/// Occurs when the current socket has completely disconnected
		/// &lt;/summary&gt;
		public event BaseNetworkEvent disconnected;

		/// &lt;summary&gt;
		/// Occurs when the current socket was forcibly disconnected
		/// &lt;/summary&gt;
		public event BaseNetworkEvent forcedDisconnect;

		/// &lt;summary&gt;
		/// Occurs when a player has connected
		/// &lt;/summary&gt;
		public event PlayerEvent playerConnected;

		/// &lt;summary&gt;
		/// Occurs when a player has disconnected
		/// &lt;/summary&gt;
		public event PlayerEvent playerDisconnected;

		/// &lt;summary&gt;
		/// Occurs when a player has timed out
		/// &lt;/summary&gt;
		public event PlayerEvent playerTimeout;

		/// &lt;summary&gt;
		/// Occurs when the player has connected and been validated by the server
		/// &lt;/summary&gt;
		public event PlayerEvent playerAccepted;

		/// &lt;summary&gt;
		/// Occurs when the player has connected and was not able to be validated by the server
		/// &lt;/summary&gt;
		public event PlayerEvent playerRejected;

        /// &lt;summary&gt;
        /// Occurs when the player has connected and been succesfully authenticated
        /// &lt;/summary&gt;
        public event PlayerEvent playerAuthenticated;

        /// &lt;summary&gt;
        /// Occurs when a message is received over the network from a remote machine
        /// &lt;/summary&gt;
        public event FrameEvent messageReceived;

		/// &lt;summary&gt;
		/// Occurs when a binary message is received over the network from a remote machine
		/// &lt;/summary&gt;
		public event BinaryFrameEvent binaryMessageReceived;

		/// &lt;summary&gt;
		/// Occurs when a binary message is received and its router byte is the byte for Rpc
		/// &lt;/summary&gt;
		//public event BinaryFrameEvent rpcMessageReceived;

		/// &lt;summary&gt;
		/// Occurs when a text message is received over the network from a remote machine
		/// &lt;/summary&gt;
		public event TextFrameEvent textMessageReceived;

		/// &lt;summary&gt;
		/// Occurs when a ping is received over the network from a remote machine
		/// &lt;/summary&gt;
		public event PingEvent onPingPong;

		/// &lt;summary&gt;
		/// Called when a player has provided it&#39;s guid, this is useful for waiting until
		/// the player is uniquely identifiable across networkers
		/// &lt;/summary&gt;
		public event PlayerEvent playerGuidAssigned;

		/// &lt;summary&gt;
		/// Occurs when a client get&#39;s an id from the server asynchronously that belongs to this NetworkObject
		/// &lt;/summary&gt;
		public event NetworkObject.CreateEvent objectCreateAttach;



		/// &lt;summary&gt;
		/// Occurs when a network object has been created on the network
		/// &lt;/summary&gt;
		public event NetworkObject.NetworkObjectEvent objectCreated {
			add {
				if (_objectCreated == null || !_objectCreated.GetInvocationList().Contains(value))
					_objectCreated += value;
			}

			remove {
				_objectCreated -= value;
			}
		}
		private NetworkObject.NetworkObjectEvent _objectCreated;

		/// &lt;summary&gt;
		/// TODO: COMMENT
		/// &lt;/summary&gt;
		public event NetworkObject.CreateRequestEvent objectCreateRequested;

		/// &lt;summary&gt;
		/// TODO: COMMENT
		/// &lt;/summary&gt;
		public event NetworkObject.NetworkObjectEvent factoryObjectCreated;
		#endregion

		#region Properties
		/// &lt;summary&gt;
		/// The list of all of the networked players. This is a wrapper around the native network
		/// socket with extra meta-data for each connection
		/// &lt;/summary&gt;
		public List&lt;NetworkingPlayer&gt; Players { get; private set; }

		/// &lt;summary&gt;
		/// A list of all of the players that are to be disconnected. This is useful if a player needs
		/// to disconnect while they are currently locked
		/// &lt;/summary&gt;
		protected List&lt;NetworkingPlayer&gt; DisconnectingPlayers { get; private set; }

		/// &lt;summary&gt;
		/// A list of all of the players that are to be forcibly disconnected.
		/// This is useful if a player needs to disconnect while they are currently locked
		/// &lt;/summary&gt;
		protected List&lt;NetworkingPlayer&gt; ForcedDisconnectingPlayers { get; private set; }

		/// &lt;summary&gt;
		/// Represents the maximum allowed connections to this listener
		/// &lt;/summary&gt;
		/// &lt;value&gt;Gets and sets the max allowed connections connections&lt;/value&gt;
		public int MaxConnections { get; private set; }

		/// &lt;summary&gt;
		/// This is a count for every player that has successfully connected since the start of this server,
		/// this also serves to be the unique id for this connection
		/// &lt;/summary&gt;
		/// &lt;value&gt;The current count of players on the network&lt;/value&gt;
		public uint ServerPlayerCounter { get; protected set; }

		/// &lt;summary&gt;
		/// The port for this networker
		/// &lt;/summary&gt;
		public ushort Port { get; private set; }

		/// &lt;summary&gt;
		/// A helper to determine if this NetWorker is a server
		/// &lt;/summary&gt;
		public bool IsServer { get { return this is IServer; } }

		/// &lt;summary&gt;
		/// A handle to the server cache to make cache requests
		/// &lt;/summary&gt;
		public Cache ServerCache { get; private set; }

		/// &lt;summary&gt;
		/// Used to determine how much bandwidth (in bytes) hass been read
		/// &lt;/summary&gt;
		public ulong BandwidthIn { get; protected set; }

		/// &lt;summary&gt;
		/// Used to determine how much bandwidth (in bytes) hass been written
		/// &lt;/summary&gt;
		public ulong BandwidthOut { get; set; }

		/// &lt;summary&gt;
		/// Used to simulate packet loss, should be a number between 0.0f and 1.0f (percentage)
		/// &lt;/summary&gt;
		public float PacketLossSimulation { get; set; }

		/// &lt;summary&gt;
		/// Used to simulate network latency to test experience at high pings
		/// &lt;/summary&gt;
		public int LatencySimulation { get; set; }

		internal bool ObjectCreatedRegistered { get { return _objectCreated != null; } }

		/// &lt;summary&gt;
		/// A cached BMSByte to prevent large amounts of garbage collection on packet sequences
		/// &lt;/summary&gt;
		public BMSByte PacketSequenceData { get; private set; }
		#endregion

		/// &lt;summary&gt;
		/// The distance from the proximity location in order to receive proximity
		/// messages from other players
		/// &lt;/summary&gt;
		public float ProximityDistance { get; set; }

        /// &lt;summary&gt;
        /// How often a client gets updates if it is outside the proximity range.
		/// 
		/// If set to 0 clients that are too far will never get updated.
        /// &lt;/summary&gt;
        public int ProximityModeUpdateFrequency { get; set; }

        /// &lt;summary&gt;
        /// Allows the newly created network object to be queued for the flush call
        /// &lt;/summary&gt;
        public bool PendCreates { get; set; }

		/// &lt;summary&gt;
		/// A boolean to tell the read thread to stop reading and close
		/// &lt;/summary&gt;
		protected bool readThreadCancel = false;

		/// &lt;summary&gt;
		/// A player reference to the current machine
		/// &lt;/summary&gt;
		public NetworkingPlayer Me { get; protected set; }

		public Dictionary&lt;uint, List&lt;Action&lt;NetworkObject&gt;&gt;&gt; missingObjectBuffer = new Dictionary&lt;uint, List&lt;Action&lt;NetworkObject&gt;&gt;&gt;();

		/// &lt;summary&gt;
		/// Determine whether the socket is connected
		/// &lt;/summary&gt;
		public bool IsConnected
		{
			get
			{
				if (Me != null)
					return Me.Connected;

				return false;
			}
		}

		/// &lt;summary&gt;
		/// A dictionary of all of the network objects indexed by it&#39;s id
		/// &lt;/summary&gt;
		public Dictionary&lt;uint, NetworkObject&gt; NetworkObjects { get; private set; }

		/// &lt;summary&gt;
		/// A list of all of the network objects
		/// &lt;/summary&gt;
		public List&lt;NetworkObject&gt; NetworkObjectList { get; private set; }

		/// &lt;summary&gt;
		/// Used to give a unique id to each of the network objects that are added
		/// &lt;/summary&gt;
		private uint currentNetworkObjectId = 0;

		/// &lt;summary&gt;
		/// This object is to track the time for this networker which is also known
		/// as a &quot;time step&quot; in this system
		/// &lt;/summary&gt;
		public TimeManager Time { get; set; }

		/// &lt;summary&gt;
		/// Used to determine if this networker has been bound yet
		/// &lt;/summary&gt;
		public bool IsBound { get; private set; }

		/// &lt;summary&gt;
		/// Used to determine if this NetWorker has already been disposed to avoid re-connections
		/// &lt;/summary&gt;
		public bool Disposed { get; private set; }

		/// &lt;summary&gt;
		/// The unique GUID that will represent all networkers for this process instance
		/// &lt;/summary&gt;
		public static Guid InstanceGuid { get; private set; }
		private static bool setupInstanceGuid = false;

        /// &lt;summary&gt;
        /// Used to authenticate the client/server connection. If null, does not perform authentication.
        /// &lt;/summary&gt;
        protected IUserAuthenticator authenticator = null;

        /// &lt;summary&gt;
        /// This is the base constructor which is normally used for clients and not classes
        /// acting as hosts
        /// &lt;/summary&gt;
        public NetWorker()
		{
			Initialize();
		}

		/// &lt;summary&gt;
		/// Constructor with a given Maximum allowed connections
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;maxConnections&quot;&gt;The Maximum connections allowed&lt;/param&gt;
		public NetWorker(int maxConnections)
		{
			Initialize();
			MaxConnections = maxConnections;
		}

		/// &lt;summary&gt;
		/// Used to setup any variables and private set properties, time and other 
		/// network critical variables that relate to a worker
		/// &lt;/summary&gt;
		private void Initialize()
		{
			PacketSequenceData = new BMSByte();

			if (!setupInstanceGuid)
			{
				InstanceGuid = Guid.NewGuid();
				setupInstanceGuid = true;
			}

			// Setup the time if it hasn&#39;t been assigned already
			Time = new TimeManager();

			Players = new List&lt;NetworkingPlayer&gt;();
			DisconnectingPlayers = new List&lt;NetworkingPlayer&gt;();
			ForcedDisconnectingPlayers = new List&lt;NetworkingPlayer&gt;();
			NetworkObjects = new Dictionary&lt;uint, NetworkObject&gt;();
			NetworkObjectList = new List&lt;NetworkObject&gt;();

			ServerPlayerCounter = 0;

			ServerCache = new Cache(this);
			EndingSession = false;
		}

		/// &lt;summary&gt;
		/// Called once the network connection has been bound
		/// &lt;/summary&gt;
		protected virtual void NetworkInitialize()
		{
			Task.Queue(() =&gt;
			{
				while (IsBound)
				{
					ulong step = Time.Timestep;
					lock (NetworkObjects)
					{
						foreach (NetworkObject obj in NetworkObjects.Values)
						{
							// Only do the heartbeat (update) on network objects that
							// are owned by the current networker
							if ((obj.IsOwner &amp;&amp; obj.UpdateInterval &gt; 0) || (IsServer &amp;&amp; obj.AuthorityUpdateMode))
								obj.HeartBeat(step);
						}
					}

					Thread.Sleep(10);
				}
			});
		}

		public void CompleteInitialization(NetworkObject networkObject)
		{
			lock (NetworkObjects)
			{
				if (NetworkObjects.ContainsKey(networkObject.NetworkId))
					return;

				NetworkObjects.Add(networkObject.NetworkId, networkObject);
				NetworkObjectList.Add(networkObject);
			}
		}

		public void FlushCreateActions(NetworkObject networkObject)
		{
			List&lt;Action&lt;NetworkObject&gt;&gt; actions = null;
			lock (missingObjectBuffer)
			{
				missingObjectBuffer.TryGetValue(networkObject.NetworkId, out actions);
				missingObjectBuffer.Remove(networkObject.NetworkId);
			}

			if (actions == null)
				return;

			foreach (var action in actions)
				action(networkObject);
		}

        /// &lt;summary&gt;
        /// Iterate over all NetworkingPlayers in a thread-safe manner
        /// &lt;/summary&gt;
        public void IteratePlayers(Action&lt;NetworkingPlayer&gt; expression)
		{
			lock (Players)
			{
				for (int i = 0; i &lt; Players.Count; i++)
					expression(Players[i]);
			}
		}

        /// &lt;summary&gt;
        /// Iterate over all NetworkObjects in a thread-safe manner
        /// &lt;/summary&gt;
        public void IterateNetworkObjects(Action&lt;NetworkObject&gt; expression)
		{
			lock (NetworkObjectList)
			{
				for (int i = 0; i &lt; NetworkObjectList.Count; i++)
					expression(NetworkObjectList[i]);
			}
		}

        /// &lt;summary&gt;
        /// Retrieve a NetworkingPlayer by NetworkId
        /// &lt;/summary&gt;
        /// &lt;returns&gt;
        /// The NetworkingPlayer with NetworkId equal to id
        /// &lt;/returns&gt;
        /// &lt;param name=&quot;id&quot;&gt;The NetworkId of the NetworkingPlayer&lt;/param&gt;
        public NetworkingPlayer GetPlayerById(uint id)
		{
			lock (Players)
			{
				for (int i = 0; i &lt; Players.Count; i++)
				{
					if (Players[i].NetworkId == id)
						return Players[i];
				}
			}

			return null;
		}

        /// &lt;summary&gt;
        /// Retrieve a NetworkingPlayer based on an expression
        /// &lt;/summary&gt;
        /// &lt;returns&gt;
        /// The first NetworkingPlayer to match the provided expression, or null if no matches are found
        /// &lt;/returns&gt;
        /// &lt;param name=&quot;expression&quot;&gt;The expression on which to match&lt;/param&gt;
        public NetworkingPlayer FindPlayer(Func&lt;NetworkingPlayer, bool&gt; expression)
		{
			lock (Players)
			{
				return Players.FirstOrDefault(expression);
			}
		}

        /// &lt;summary&gt;
        /// Retrieve a NetworkingPlayer which matches the provided NetworkingPlayer by Ip and InstanceGuid
        /// &lt;/summary&gt;
        /// &lt;returns&gt;
        /// The first NetworkingPlayer to match the provided expression, or null if no matches are found
        /// &lt;/returns&gt;
        /// &lt;param name=&quot;expression&quot;&gt;The expression on which to match&lt;/param&gt;
        public NetworkingPlayer FindMatchingPlayer(NetworkingPlayer other)
		{
			if (other.Networker == this)
				return other;

			lock (Players)
			{
				for (int i = 0; i &lt; Players.Count; i++)
				{
					if (Players[i].Ip == other.Ip &amp;&amp; Players[i].InstanceGuid == other.InstanceGuid)
						return Players[i];
				}
			}

			return null;
		}

		/// &lt;summary&gt;
		/// Register a networked object with this networker
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;networkObject&quot;&gt;The object that is to be registered with this networker&lt;/param&gt;
		/// &lt;returns&gt;&lt;c&gt;true&lt;/c&gt; if the object was registered successfully, else &lt;c&gt;false&lt;/c&gt; if it has already been registered&lt;/returns&gt;
		public bool RegisterNetworkObject(NetworkObject networkObject, uint forceId = 0)
		{
			uint id = currentNetworkObjectId;

			lock (NetworkObjects)
			{
				// If we are forcing this object
				if (forceId != 0)
				{
					if (NetworkObjects.ContainsKey(forceId))
						return false;

					id = forceId;

					if (!networkObject.RegisterOnce(id))
						throw new BaseNetworkException(&quot;The supplied network object has already been assigned to a networker and has an id&quot;);

					//AddNetworkObject(forceId, networkObject);
					//NetworkObjectList.Add(networkObject);
				}
				else
				{
					do
					{
						if (NetworkObjects.ContainsKey(++currentNetworkObjectId))
							continue;

						if (!networkObject.RegisterOnce(currentNetworkObjectId))
						{
							// Backtrack since the next call to this method will increment before checking
							currentNetworkObjectId--;

							throw new BaseNetworkException(&quot;The supplied network object has already been assigned to a networker and has an id&quot;);
						}

						//AddNetworkObject(currentNetworkObjectId, networkObject);
						//NetworkObjectList.Add(networkObject);
						break;
					} while (IsBound);
				}
			}

			// Assign the network id to the network object
			networkObject.RegisterOnce(id);

			// When this object is destroyed it needs to remove itself from the list
			networkObject.onDestroy += (NetWorker sender) =&gt;
			{
				lock (NetworkObjects)
				{
					NetworkObjects.Remove(networkObject.NetworkId);
					NetworkObjectList.Remove(networkObject);
				}
			};

			return true;
		}

		/// &lt;summary&gt;
		/// Disconnect this client from the server
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;forced&quot;&gt;Used to tell if this disconnect was intentional &lt;c&gt;false&lt;/c&gt; or caused by an exception &lt;c&gt;true&lt;/c&gt;&lt;/param&gt;
		public abstract void Disconnect(bool forced);

		/// &lt;summary&gt;
		/// Reads the frame stream as if it were read on the network
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;frame&quot;&gt;The target frame stream to be read&lt;/param&gt;
		public abstract void FireRead(FrameStream frame, NetworkingPlayer currentPlayer);

		/// &lt;summary&gt;
		/// Goes through all of the pending disconnect players and disconnects them
		/// Pending disconnects are always forced
		/// &lt;/summary&gt;
		protected void DisconnectPending(Action&lt;NetworkingPlayer, bool&gt; disconnectMethod)
		{
			if (DisconnectingPlayers.Count == 0 &amp;&amp; ForcedDisconnectingPlayers.Count == 0)
				return;

			lock (Players)
			{
				for (int i = DisconnectingPlayers.Count - 1; i &gt;= 0; --i)
					disconnectMethod(DisconnectingPlayers[i], false);

				for (int i = ForcedDisconnectingPlayers.Count - 1; i &gt;= 0; --i)
					disconnectMethod(ForcedDisconnectingPlayers[i], true);
			}
		}

		/// &lt;summary&gt;
		/// A wrapper for the bindSuccessful event call that chindren of this calls can call
		/// &lt;/summary&gt;
		protected void OnBindSuccessful()
		{
			IsBound = true;
			NetworkInitialize();
			if (bindSuccessful != null)
				bindSuccessful(this);
		}

		/// &lt;summary&gt;
		/// A wrapper for the bindFailure event call that children of this can call
		/// &lt;/summary&gt;
		protected void OnBindFailure()
		{
			if (bindFailure != null)
				bindFailure(this);
		}

		/// &lt;summary&gt;
		/// A wrapper for the playerDisconnected event call that chindren of this can call.
		/// This also is responsible for adding the player to the lookup
		/// &lt;/summary&gt;
		protected void OnPlayerConnected(NetworkingPlayer player)
		{
			if (Players.Contains(player))
				throw new BaseNetworkException(&quot;Cannot add player because it already exists in the list&quot;);

			// Removal of clients can be from any thread
			lock (Players)
			{
				Players.Add(player);
			}

			if (playerConnected != null)
				playerConnected(player, this);
		}

		internal void OnObjectCreated(NetworkObject target)
		{
			if (_objectCreated != null)
                _objectCreated(target);
		}

		internal void OnObjectCreateAttach(int identity, int hash, uint id, FrameStream frame)
		{
			if (objectCreateAttach != null)
				objectCreateAttach(identity, hash, id, frame);
		}

		internal void OnObjectCreateRequested(int identity, uint id, FrameStream frame, Action&lt;NetworkObject&gt; callback)
		{
			if (objectCreateRequested != null)
				objectCreateRequested(this, identity, id, frame, callback);
		}

		internal void OnFactoryObjectCreated(NetworkObject obj)
		{
			if (factoryObjectCreated != null)
				factoryObjectCreated(obj);
		}

		/// &lt;summary&gt;
		/// A wrapper for the bindFailure event call that chindren of this can call.
		/// This also is responsible for removing the player from the lookup
		/// &lt;/summary&gt;
		protected void OnPlayerDisconnected(NetworkingPlayer player)
		{
			// Removal of clients can be from any thread
			lock (Players)
			{
				Players.Remove(player);
			}

			player.OnDisconnect();

			if (playerDisconnected != null)
				playerDisconnected(player, this);
		}

		protected void OnPlayerTimeout(NetworkingPlayer player)
		{
			if (playerTimeout != null)
				playerTimeout(player, this);
		}

		/// &lt;summary&gt;
		/// A wrapper for the playerAccepted event call that chindren of this can call
		/// &lt;/summary&gt;
		protected void OnPlayerAccepted(NetworkingPlayer player)
		{
			player.Accepted = true;
			player.PendingAccepted = false;

			NetworkObject[] currentObjects;
			lock (NetworkObjects)
			{
				currentObjects = NetworkObjects.Values.ToArray();
			}

			NetworkObject.PlayerAccepted(player, currentObjects);

			if (playerAccepted != null)
				playerAccepted(player, this);
		}

		/// &lt;summary&gt;
		/// A wrapper for the playerAccepted event call that chindren of this can call
		/// &lt;/summary&gt;
		protected void OnPlayerRejected(NetworkingPlayer player)
		{
			player.Accepted = false;
            player.Authenticated = false;

			if (playerRejected != null)
				playerRejected(player, this);
		}

        /// &lt;summary&gt;
        /// If the player is authenticated, 
        /// &lt;/summary&gt;
        protected void OnPlayerAuthenticated(NetworkingPlayer player)
        {
            player.Authenticated = true;

            if (playerAuthenticated != null)
                playerAuthenticated(player, this);
        }

		/// &lt;summary&gt;
		/// Set the port for the networker
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;port&quot;&gt;&lt;/param&gt;
		protected void SetPort(ushort port)
		{
			this.Port = port;
		}

		/// &lt;summary&gt;
		/// A wrapper for the pingReceived event call that children of this can call
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;ping&quot;&gt;&lt;/param&gt;
		protected void OnPingRecieved(double ping, NetworkingPlayer player)
		{
			if (onPingPong != null)
				onPingPong(ping, this);

			player.RoundTripLatency = (int)ping;
		}

		/// &lt;summary&gt;
		/// A wrapper for the messageReceived event call that chindren of this can call
		/// &lt;/summary&gt;
		protected void OnMessageReceived(NetworkingPlayer player, FrameStream frame)
		{
			if (frame.GroupId == MessageGroupIds.NETWORK_ID_REQUEST &amp;&amp; this is IClient)
			{
				Time.SetStartTime(frame.TimeStep);
				Me = new NetworkingPlayer(frame.StreamData.GetBasicType&lt;uint&gt;(), &quot;0.0.0.0&quot;, false, null, this);
				Me.AssignPort(Port);
				OnServerAccepted();
				return;
			}

			if (frame.GroupId == MessageGroupIds.PING || frame.GroupId == MessageGroupIds.PONG)
			{
				long receivedTimestep = frame.StreamData.GetBasicType&lt;long&gt;();
				DateTime received = new DateTime(receivedTimestep);
				TimeSpan ms = DateTime.UtcNow - received;

				if (frame.GroupId == MessageGroupIds.PING)
					Pong(player, received);
				else
					OnPingRecieved(ms.TotalMilliseconds, player);

				return;
			}

			if (frame is Binary)
			{
				byte routerId = ((Binary)frame).RouterId;
				if (routerId == RouterIds.RPC_ROUTER_ID || routerId == RouterIds.BINARY_DATA_ROUTER_ID || routerId == RouterIds.CREATED_OBJECT_ROUTER_ID)
				{
					uint id = frame.StreamData.GetBasicType&lt;uint&gt;();
					NetworkObject targetObject = null;

					lock (NetworkObjects)
					{
						NetworkObjects.TryGetValue(id, out targetObject);
					}

					if (targetObject == null)
					{
						lock (missingObjectBuffer)
						{
							if (!missingObjectBuffer.ContainsKey(id))
								missingObjectBuffer.Add(id, new List&lt;Action&lt;NetworkObject&gt;&gt;());

							missingObjectBuffer[id].Add((networkObject) =&gt;
							{
								ExecuteRouterAction(routerId, networkObject, (Binary)frame, player);
							});
						}

						// TODO:  If the server is missing an object, it should have a timed buffer
						// that way useless messages are not setting around in memory

						return;
					}

					ExecuteRouterAction(routerId, targetObject, (Binary)frame, player);
				}
				else if (routerId == RouterIds.NETWORK_OBJECT_ROUTER_ID)
				{
					NetworkObject.CreateNetworkObject(this, player, (Binary)frame);
				}
				else if (routerId == RouterIds.ACCEPT_MULTI_ROUTER_ID)
					NetworkObject.CreateMultiNetworkObject(this, player, (Binary)frame);
				else if (binaryMessageReceived != null)
					binaryMessageReceived(player, (Binary)frame, this);
			}
			else if (frame is Text &amp;&amp; textMessageReceived != null)
				textMessageReceived(player, (Text)frame, this);

			if (messageReceived != null)
				messageReceived(player, frame, this);
		}

		private void ExecuteRouterAction(byte routerId, NetworkObject networkObject, Binary frame, NetworkingPlayer player)
		{
			if (routerId == RouterIds.RPC_ROUTER_ID)
				networkObject.InvokeRpc(player, frame.TimeStep, frame.StreamData, frame.Receivers);
			else if (routerId == RouterIds.BINARY_DATA_ROUTER_ID)
				networkObject.ReadBinaryData(frame);
			else if (routerId == RouterIds.CREATED_OBJECT_ROUTER_ID)
				networkObject.CreateConfirmed(player);
		}

		/// &lt;summary&gt;
		/// When this socket has been disconnected
		/// &lt;/summary&gt;
		protected void OnDisconnected()
		{
			IsBound = false;

			if (Me != null)
			{
				Me.Connected = false;

				if (!(this is IServer))
					Me.OnDisconnect();
			}

			if (disconnected != null)
				disconnected(this);

			Disposed = true;
		}

		/// &lt;summary&gt;
		/// When this socket has been forcibly disconnected
		/// &lt;/summary&gt;
		protected void OnForcedDisconnect()
		{
			IsBound = false;

			if (forcedDisconnect != null)
				forcedDisconnect(this);

			Disposed = true;
		}

		/// &lt;summary&gt;
		/// A wrapper around calling the serverAccepted event from child classes
		/// &lt;/summary&gt;
		protected void OnServerAccepted()
		{
			Me.Connected = true;

			if (serverAccepted != null)
				serverAccepted(this);
		}

		/// &lt;summary&gt;
		/// A wrapper around calling the playerGuidAssigned event from child classes
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;player&quot;&gt;The player which the guid was assigned to&lt;/param&gt;
		protected void OnPlayerGuidAssigned(NetworkingPlayer player)
		{
			if (playerGuidAssigned != null)
				playerGuidAssigned(player, this);
		}

		/// &lt;summary&gt;
		/// A wrapper around calling the playerGuidAssigned event from child classes
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;player&quot;&gt;The player which the guid was assigned to&lt;/param&gt;
		/// &lt;param name=&quot;rejected&quot;&gt;Returns whether the player was rejected during the handling of the event&lt;/param&gt;
		protected void OnPlayerGuidAssigned(NetworkingPlayer player, out bool rejected)
		{
			OnPlayerGuidAssigned(player);

			// Return if the player was rejected during the handling of the event.
			rejected = (player.IsDisconnecting || DisconnectingPlayers.Contains(player) || ForcedDisconnectingPlayers.Contains(player));
		}

        /// &lt;summary&gt;
        /// Used to set the user authenticator. NetWorker must not already be connected.
        /// &lt;/summary&gt;
        public void SetUserAuthenticator(IUserAuthenticator authenticator)
        {
            if (IsConnected)
                throw new BaseNetworkException(&quot;The NetWorker is already connected&quot;);

            this.authenticator = authenticator;
        }

        /// &lt;summary&gt;
        /// Used to bind to a port then unbind to trigger any operating system firewall requests
        /// &lt;/summary&gt;
        public static void PingForFirewall(ushort port = 0)
		{
			if (port &lt; 1)
			{
				port = DEFAULT_PORT - 1;
			}
			Task.Queue(() =&gt;
			{
				try
				{
					//IPAddress ipAddress = Dns.GetHostEntry(Dns.GetHostName()).AddressList[0];
					//IPEndPoint ipLocalEndPoint = new IPEndPoint(ipAddress, 15937);
					IPEndPoint ipLocalEndPoint = new IPEndPoint(IPAddress.Parse(&quot;127.0.0.1&quot;), port);

					TcpListener t = new TcpListener(ipLocalEndPoint);
					t.Start();
					t.Stop();
				}
				catch (Exception ex)
				{
					Logging.BMSLog.LogException(ex);
				}
			});
		}

		public static void EndSession()
		{
			EndingSession = true;
			CloseLocalListingsClient();

			// Reset the ending session after 1000ms so that we know all the threads have cleaned up
			// for any remaining threads that may be going for this previous process
			Task.Queue(() =&gt;
			{
				EndingSession = false;
			}, 1000);
		}

		public Ping GeneratePing()
		{
			BMSByte payload = new BMSByte();
			long ticks = DateTime.UtcNow.Ticks;
			payload.BlockCopy&lt;long&gt;(ticks, sizeof(long));
			return new Ping(Time.Timestep, this is TCPClient, payload, Receivers.Server, MessageGroupIds.PING, this is BaseTCP);
		}

		protected Pong GeneratePong(DateTime time)
		{
			BMSByte payload = new BMSByte();
			long ticks = time.Ticks;
			payload.BlockCopy&lt;long&gt;(ticks, sizeof(long));
			return new Pong(Time.Timestep, this is TCPClient, payload, Receivers.Target, MessageGroupIds.PONG, this is BaseTCP);
		}

		/// &lt;summary&gt;
		/// Request the ping from the server (pingReceived will be triggered if it receives it)
		/// This is not a reliable call in UDP
		/// &lt;/summary&gt;
		public abstract void Ping();

		protected abstract void Pong(NetworkingPlayer playerRequesting, DateTime time);

		private static void CloseLocalListingsClient()
		{
			lock (localListingsClientList) {
				foreach (CachedUdpClient cachedUdpClient in localListingsClientList) {
					cachedUdpClient.Client.Close();
				}
				localListingsClientList.Clear();
			}
		}

		/// &lt;summary&gt;
		/// Collects all local IPs of every NIC that is currently in operational status &lt;c&gt;Up&lt;/c&gt; (active).
		/// Note: Only NICs of type &lt;c&gt;Wireless80211&lt;/c&gt; and &lt;c&gt;Ethernet&lt;/c&gt; are considered.
		/// &lt;/summary&gt;
		/// &lt;returns&gt;An array of local IPs for every active NIC&lt;/returns&gt;
		private static IPAddress[] GetLocalIPs() {
			List&lt;IPAddress&gt; ipList = new List&lt;IPAddress&gt;();

			foreach (NetworkInterface nic in NetworkInterface.GetAllNetworkInterfaces()) {
				switch (nic.NetworkInterfaceType) {
					case NetworkInterfaceType.Wireless80211:
					case NetworkInterfaceType.Ethernet:
						break;
					default:
						continue;
				}

				if (nic.OperationalStatus != OperationalStatus.Up) continue;

				foreach (UnicastIPAddressInformation ip in nic.GetIPProperties().UnicastAddresses) {
					if (ip.Address.AddressFamily == AddressFamily.InterNetwork) {
						ipList.Add(ip.Address);
					}
				}
			}

			return ipList.ToArray();
		}

		/// &lt;summary&gt;
		/// A method to find all of the local UDP servers and clients on the network
		/// &lt;/summary&gt;
		public static void RefreshLocalUdpListings(ushort portNumber = DEFAULT_PORT, int responseBuffer = 1000)
		{
			lock (localListingsClientList) {
				foreach (CachedUdpClient cachedUdpClient in localListingsClientList) {
					cachedUdpClient.Client.Close();
				}
				localListingsClientList.Clear();
			}

			// Initialize the list to hold all of the local network endpoints that respond to the request
			if (LocalEndpoints == null)
				LocalEndpoints = new List&lt;BroadcastEndpoints&gt;();

			// Make sure to clear out the existing endpoints
			lock (LocalEndpoints)
			{
				LocalEndpoints.Clear();
			}

			foreach (IPAddress ipAddress in GetLocalIPs())
			{
				// Create a client to write on the network and discover other clients and servers
				CachedUdpClient localListingsClient = new CachedUdpClient(new IPEndPoint(ipAddress, 19375));
				localListingsClient.EnableBroadcast = true;
				lock (localListingsClientList) {
					localListingsClientList.Add(localListingsClient);
				}
				Task.Queue(() =&gt; { CloseLocalListingsClient(); }, responseBuffer);

				Task.Queue(() =&gt;
				{
					IPEndPoint groupEp = default(IPEndPoint);
					string endpoint = string.Empty;

					localListingsClient.Send(new byte[] {BROADCAST_LISTING_REQUEST_1, BROADCAST_LISTING_REQUEST_2, BROADCAST_LISTING_REQUEST_3}, 3,
						new IPEndPoint(IPAddress.Parse(&quot;255.255.255.255&quot;), portNumber));

					try
					{
						while (localListingsClient != null &amp;&amp; !EndingSession)
						{
							var data = localListingsClient.Receive(ref groupEp, ref endpoint);

							if (data.Size != 1)
								continue;

							string[] parts = endpoint.Split(&#39;+&#39;);
							string address = parts[0];
							ushort port = ushort.Parse(parts[1]);
							if (data[0] == SERVER_BROADCAST_CODE)
							{
								var ep = new BroadcastEndpoints(address, port, true);
								LocalEndpoints.Add(ep);

								if (localServerLocated != null)
									localServerLocated(ep, null);
							} else if (data[0] == CLIENT_BROADCAST_CODE)
								LocalEndpoints.Add(new BroadcastEndpoints(address, port, false));
						}
					} catch
					{ }
				});
			}
		}
	}
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[46,3,46,94,0],[49,3,49,4,0],[51,4,51,66,0],[52,5,52,56,0],[53,9,53,33,0],[54,5,54,63,0],[58,4,58,49,0],[59,4,59,5,0],[60,5,60,65,0],[61,5,61,12,0],[61,14,61,26,0],[61,27,61,29,0],[61,30,61,51,0],[62,5,62,6,0],[63,6,63,57,0],[64,6,64,7,0],[65,7,65,33,0],[66,8,66,66,0],[67,6,67,7,0],[68,5,68,6,0],[71,5,71,6,0],[72,6,72,54,0],[73,6,73,44,0],[74,5,74,6,0],[75,5,75,10,0],[76,5,76,6,0],[77,6,77,48,0],[78,6,78,60,0],[80,4,80,5,0],[82,4,82,43,0],[83,3,83,4,0],[87,28,87,32,0],[87,33,87,45,0],[88,25,88,29,0],[88,30,88,42,0],[89,27,89,31,0],[89,32,89,44,0],[91,76,91,82,0],[92,4,92,5,0],[93,5,93,28,0],[94,5,94,22,0],[95,5,95,30,0],[96,4,96,5,0],[99,59,99,63,0],[99,64,99,76,0],[101,38,101,42,0],[101,43,101,55,0],[250,8,250,9,0],[251,5,251,87,0],[252,6,252,30,0],[253,4,253,5,0],[255,11,255,12,0],[256,5,256,29,0],[257,4,257,5,0],[277,43,277,47,0],[277,48,277,60,0],[283,59,283,63,0],[283,64,283,76,0],[289,65,289,69,0],[289,70,289,82,0],[295,31,295,35,0],[295,36,295,48,0],[302,37,302,41,0],[302,42,302,56,0],[307,24,307,28,0],[307,29,307,41,0],[312,30,312,31,0],[312,32,312,55,0],[312,56,312,57,0],[317,30,317,34,0],[317,35,317,47,0],[322,30,322,34,0],[322,35,322,49,0],[327,31,327,35,0],[327,36,327,40,0],[332,39,332,43,0],[332,44,332,48,0],[337,34,337,38,0],[337,39,337,43,0],[339,47,339,48,0],[339,49,339,79,0],[339,80,339,81,0],[344,39,344,43,0],[344,44,344,56,0],[351,36,351,40,0],[351,41,351,45,0],[358,51,358,55,0],[358,56,358,60,0],[363,35,363,39,0],[363,40,363,44,0],[368,3,368,43,0],[368,3,368,43,0],[373,32,373,36,0],[373,37,373,51,0],[375,3,375,130,0],[375,3,375,130,0],[383,4,383,5,0],[384,5,384,20,0],[385,6,385,26,0],[387,5,387,18,0],[388,4,388,5,0],[394,59,394,63,0],[394,64,394,76,0],[399,50,399,54,0],[399,55,399,67,0],[404,3,404,43,0],[404,3,404,43,0],[410,29,410,33,0],[410,34,410,38,0],[415,25,415,29,0],[415,30,415,42,0],[420,26,420,30,0],[420,31,420,43,0],[425,37,425,41,0],[425,42,425,54,0],[426,3,426,49,0],[431,9,431,59,0],[431,9,431,59,0],[437,9,437,27,0],[438,3,438,4,0],[439,4,439,17,0],[440,3,440,4,0],[446,3,446,39,0],[447,3,447,4,0],[448,4,448,17,0],[449,4,449,36,0],[450,3,450,4,0],[457,3,457,4,0],[458,4,458,39,0],[460,4,460,27,0],[461,4,461,5,0],[462,5,462,35,0],[463,5,463,30,0],[464,4,464,5,0],[467,4,467,29,0],[469,4,469,43,0],[470,4,470,56,0],[471,4,471,62,0],[472,4,472,59,0],[473,4,473,50,0],[475,4,475,28,0],[477,4,477,34,0],[478,4,478,26,0],[479,3,479,4,0],[485,3,485,4,0],[486,4,487,4,0],[487,4,487,5,0],[487,5,488,5,0],[488,5,488,20,0],[488,20,489,5,0],[489,5,489,6,0],[489,6,490,6,0],[490,6,490,33,0],[490,33,491,6,0],[491,6,491,27,0],[491,27,492,6,0],[492,6,492,7,0],[492,7,493,7,0],[493,7,493,14,0],[493,14,493,16,0],[493,16,493,33,0],[493,33,493,34,0],[493,34,493,36,0],[493,36,493,37,0],[493,37,493,58,0],[493,58,494,7,0],[494,7,494,8,0],[494,8,497,8,0],[497,8,497,93,0],[497,93,498,9,0],[498,9,498,29,0],[498,29,499,7,0],[499,7,499,8,0],[499,8,500,6,0],[500,6,500,7,0],[500,7,502,6,0],[502,6,502,23,0],[502,23,503,5,0],[503,5,503,6,0],[503,6,504,4,0],[504,4,504,5,0],[504,5,504,7,0],[486,4,504,7,0],[505,3,505,4,0],[508,3,508,4,0],[509,4,509,25,0],[510,4,510,5,0],[511,5,511,61,0],[512,6,512,13,0],[514,5,514,64,0],[515,5,515,42,0],[516,4,516,5,0],[517,3,517,4,0],[520,3,520,4,0],[521,4,521,47,0],[522,4,522,30,0],[523,4,523,5,0],[524,5,524,75,0],[525,5,525,57,0],[526,4,526,5,0],[528,4,528,24,0],[529,5,529,12,0],[531,4,531,11,0],[531,13,531,23,0],[531,24,531,26,0],[531,27,531,34,0],[532,5,532,27,0],[533,3,533,4,0],[539,3,539,4,0],[540,4,540,18,0],[541,4,541,5,0],[542,10,542,19,0],[542,21,542,38,0],[542,40,542,43,0],[543,6,543,29,0],[544,4,544,5,0],[545,3,545,4,0],[551,3,551,4,0],[552,4,552,28,0],[553,4,553,5,0],[554,10,554,19,0],[554,21,554,48,0],[554,50,554,53,0],[555,6,555,39,0],[556,4,556,5,0],[557,3,557,4,0],[567,3,567,4,0],[568,4,568,18,0],[569,4,569,5,0],[570,10,570,19,0],[570,21,570,38,0],[570,40,570,43,0],[571,5,571,6,0],[572,6,572,37,0],[573,7,573,25,0],[574,5,574,6,0],[575,4,575,5,0],[577,4,577,16,0],[578,3,578,4,0],[588,3,588,4,0],[589,4,589,18,0],[590,4,590,5,0],[591,5,591,47,0],[593,3,593,4,0],[603,3,603,4,0],[604,4,604,32,0],[605,5,605,18,0],[607,4,607,18,0],[608,4,608,5,0],[609,10,609,19,0],[609,21,609,38,0],[609,40,609,43,0],[610,5,610,6,0],[611,6,611,85,0],[612,7,612,25,0],[613,5,613,6,0],[614,4,614,5,0],[616,4,616,16,0],[617,3,617,4,0],[625,3,625,4,0],[626,4,626,37,0],[628,4,628,25,0],[629,4,629,5,0],[631,5,631,22,0],[632,5,632,6,0],[633,6,633,46,0],[634,7,634,20,0],[636,6,636,19,0],[638,6,638,42,0],[639,7,639,124,0],[643,5,643,6,0],[645,5,645,6,0],[647,6,647,7,0],[648,7,648,64,0],[649,8,649,17,0],[651,7,651,63,0],[652,7,652,8,0],[654,8,654,33,0],[656,8,656,125,0],[661,7,661,13,0],[662,8,662,24,0],[663,5,663,6,0],[664,4,664,5,0],[667,4,667,35,0],[670,4,671,4,0],[671,4,671,5,0],[671,5,672,5,0],[672,5,672,26,0],[672,26,673,5,0],[673,5,673,6,0],[673,6,674,6,0],[674,6,674,53,0],[674,53,675,6,0],[675,6,675,46,0],[675,46,676,5,0],[676,5,676,6,0],[676,6,677,4,0],[677,4,677,5,0],[677,5,677,6,0],[670,4,677,6,0],[679,4,679,16,0],[680,3,680,4,0],[699,3,699,4,0],[700,4,700,81,0],[701,5,701,12,0],[703,4,703,18,0],[704,4,704,5,0],[705,10,705,48,0],[705,50,705,56,0],[705,58,705,61,0],[706,6,706,55,0],[708,10,708,54,0],[708,56,708,62,0],[708,64,708,67,0],[709,6,709,60,0],[710,4,710,5,0],[711,3,711,4,0],[717,3,717,4,0],[718,4,718,19,0],[719,4,719,24,0],[720,4,720,31,0],[721,5,721,26,0],[722,3,722,4,0],[728,3,728,4,0],[729,4,729,28,0],[730,5,730,23,0],[731,3,731,4,0],[738,3,738,4,0],[739,4,739,33,0],[740,5,740,95,0],[743,4,743,18,0],[744,4,744,5,0],[745,5,745,25,0],[746,4,746,5,0],[748,4,748,32,0],[749,5,749,35,0],[750,3,750,4,0],[753,3,753,4,0],[754,4,754,31,0],[755,17,755,40,0],[756,3,756,4,0],[759,3,759,4,0],[760,4,760,35,0],[761,5,761,51,0],[762,3,762,4,0],[765,3,765,4,0],[766,4,766,38,0],[767,5,767,64,0],[768,3,768,4,0],[771,3,771,4,0],[772,4,772,37,0],[773,5,773,31,0],[774,3,774,4,0],[781,3,781,4,0],[783,4,783,18,0],[784,4,784,5,0],[785,5,785,28,0],[786,4,786,5,0],[788,4,788,26,0],[790,4,790,35,0],[791,5,791,38,0],[792,3,792,4,0],[795,3,795,4,0],[796,4,796,30,0],[797,5,797,33,0],[798,3,798,4,0],[804,3,804,4,0],[805,4,805,27,0],[806,4,806,35,0],[809,4,809,25,0],[810,4,810,5,0],[811,5,811,54,0],[812,4,812,5,0],[814,4,814,57,0],[816,4,816,31,0],[817,5,817,34,0],[818,3,818,4,0],[824,3,824,4,0],[825,4,825,28,0],[826,13,826,42,0],[828,4,828,31,0],[829,5,829,34,0],[830,3,830,4,0],[836,9,836,10,0],[837,13,837,41,0],[839,13,839,45,0],[840,17,840,51,0],[841,9,841,10,0],[848,3,848,4,0],[849,4,849,21,0],[850,3,850,4,0],[857,3,857,4,0],[858,4,858,27,0],[859,5,859,28,0],[861,4,861,40,0],[862,3,862,4,0],[868,3,868,4,0],[869,4,869,79,0],[870,4,870,5,0],[871,5,871,39,0],[872,5,872,100,0],[873,5,873,25,0],[874,5,874,24,0],[875,5,875,12,0],[878,4,878,87,0],[879,4,879,5,0],[880,5,880,67,0],[881,5,881,56,0],[882,5,882,46,0],[884,5,884,47,0],[885,6,885,29,0],[887,6,887,51,0],[889,5,889,12,0],[892,4,892,24,0],[893,4,893,5,0],[894,5,894,46,0],[895,5,895,142,0],[896,5,896,6,0],[897,6,897,54,0],[898,6,898,40,0],[900,6,900,27,0],[901,6,901,7,0],[902,7,902,56,0],[903,6,903,7,0],[905,6,905,31,0],[906,6,906,7,0],[907,7,907,33,0],[908,7,908,8,0],[909,8,909,49,0],[910,9,910,72,0],[912,8,913,8,0],[913,8,913,9,0],[913,9,914,9,0],[914,9,914,77,0],[914,77,915,8,0],[915,8,915,9,0],[915,9,915,11,0],[912,8,915,11,0],[916,7,916,8,0],[921,7,921,14,0],[924,6,924,73,0],[925,5,925,6,0],[926,10,926,61,0],[927,5,927,6,0],[928,6,928,69,0],[929,5,929,6,0],[930,10,930,59,0],[931,6,931,74,0],[932,10,932,44,0],[933,6,933,57,0],[934,4,934,5,0],[935,9,935,58,0],[936,5,936,52,0],[938,4,938,32,0],[939,5,939,42,0],[940,3,940,4,0],[943,3,943,4,0],[944,4,944,44,0],[945,5,945,88,0],[946,9,946,57,0],[947,5,947,41,0],[948,9,948,60,0],[949,5,949,43,0],[950,3,950,4,0],[956,3,956,4,0],[957,4,957,20,0],[959,4,959,19,0],[960,4,960,5,0],[961,5,961,26,0],[963,5,963,28,0],[964,6,964,24,0],[965,4,965,5,0],[967,4,967,29,0],[968,5,968,24,0],[970,4,970,20,0],[971,3,971,4,0],[977,3,977,4,0],[978,4,978,20,0],[980,4,980,33,0],[981,5,981,28,0],[983,4,983,20,0],[984,3,984,4,0],[990,3,990,4,0],[991,4,991,24,0],[993,4,993,31,0],[994,5,994,26,0],[995,3,995,4,0],[1002,3,1002,4,0],[1003,4,1003,35,0],[1004,5,1004,38,0],[1005,3,1005,4,0],[1013,3,1013,4,0],[1014,4,1014,33,0],[1017,4,1017,128,0],[1018,3,1018,4,0],[1024,9,1024,10,0],[1025,13,1025,29,0],[1026,17,1026,86,0],[1028,13,1028,48,0],[1029,9,1029,10,0],[1035,3,1035,4,0],[1036,4,1036,17,0],[1037,4,1037,5,0],[1038,5,1038,29,0],[1039,4,1039,5,0],[1040,4,1041,4,0],[1041,4,1041,5,0],[1041,5,1043,5,0],[1043,5,1043,6,0],[1043,6,1046,6,0],[1046,6,1046,86,0],[1046,86,1048,6,0],[1048,6,1048,55,0],[1048,55,1049,6,0],[1049,6,1049,16,0],[1049,16,1050,6,0],[1050,6,1050,15,0],[1050,15,1051,5,0],[1051,5,1051,6,0],[1051,6,1052,5,0],[1052,5,1052,25,0],[1052,25,1053,5,0],[1053,5,1053,6,0],[1053,6,1054,6,0],[1054,6,1054,38,0],[1054,38,1055,5,0],[1055,5,1055,6,0],[1055,6,1056,4,0],[1056,4,1056,5,0],[1056,5,1056,7,0],[1040,4,1056,7,0],[1057,3,1057,4,0],[1060,3,1060,4,0],[1061,4,1061,25,0],[1062,4,1062,31,0],[1066,4,1067,4,0],[1067,4,1067,5,0],[1067,5,1068,5,0],[1068,5,1068,27,0],[1068,27,1069,4,0],[1069,4,1069,5,0],[1069,5,1069,13,0],[1066,4,1069,13,0],[1070,3,1070,4,0],[1073,3,1073,4,0],[1074,4,1074,36,0],[1075,4,1075,39,0],[1076,4,1076,49,0],[1077,4,1077,120,0],[1078,3,1078,4,0],[1081,3,1081,4,0],[1082,4,1082,36,0],[1083,4,1083,28,0],[1084,4,1084,49,0],[1085,4,1085,120,0],[1086,3,1086,4,0],[1097,3,1097,4,0],[1098,4,1098,34,0],[1098,35,1098,36,0],[1099,5,1099,12,0],[1099,14,1099,45,0],[1099,46,1099,48,0],[1099,49,1099,72,0],[1099,74,1099,75,0],[1100,6,1100,37,0],[1101,5,1101,6,0],[1102,5,1102,37,0],[1103,4,1103,5,0],[1104,3,1104,4,0],[1111,44,1111,45,0],[1112,4,1112,51,0],[1114,4,1114,11,0],[1114,13,1114,33,0],[1114,34,1114,36,0],[1114,37,1114,79,0],[1114,81,1114,82,0],[1115,5,1115,38,0],[1118,7,1118,13,0],[1120,7,1120,16,0],[1123,5,1123,55,0],[1123,56,1123,65,0],[1125,5,1125,12,0],[1125,14,1125,44,0],[1125,45,1125,47,0],[1125,48,1125,86,0],[1125,88,1125,89,0],[1126,6,1126,65,0],[1126,66,1126,67,0],[1127,7,1127,30,0],[1128,6,1128,7,0],[1129,5,1129,6,0],[1130,4,1130,5,0],[1132,4,1132,28,0],[1133,3,1133,4,0],[1139,3,1139,4,0],[1140,4,1140,34,0],[1140,35,1140,36,0],[1141,5,1141,12,0],[1141,14,1141,45,0],[1141,46,1141,48,0],[1141,49,1141,72,0],[1141,74,1141,75,0],[1142,6,1142,37,0],[1143,5,1143,6,0],[1144,5,1144,37,0],[1145,4,1145,5,0],[1148,4,1148,31,0],[1149,5,1149,53,0],[1152,4,1152,25,0],[1153,4,1153,5,0],[1154,5,1154,28,0],[1155,4,1155,5,0],[1157,4,1157,11,0],[1157,13,1157,32,0],[1157,33,1157,35,0],[1157,36,1157,49,0],[1158,4,1158,5,0],[1160,5,1160,97,0],[1161,5,1161,48,0],[1162,5,1162,35,0],[1162,36,1162,37,0],[1163,6,1163,55,0],[1164,5,1164,6,0],[1165,5,1165,22,0],[1165,22,1165,23,0],[1165,23,1165,24,0],[1165,24,1165,51,0],[1165,51,1165,52,0],[1165,52,1165,53,0],[1165,53,1165,71,0],[1165,5,1165,71,0],[1167,5,1168,5,0],[1168,5,1168,6,0],[1168,6,1169,6,0],[1169,6,1169,47,0],[1169,47,1170,6,0],[1170,6,1170,37,0],[1170,37,1172,6,0],[1172,6,1173,71,0],[1173,71,1176,6,0],[1176,6,1176,7,0],[1176,7,1177,7,0],[1177,7,1177,60,0],[1177,60,1178,7,0],[1178,7,1178,8,0],[1178,8,1179,8,0],[1179,8,1179,74,0],[1179,74,1181,8,0],[1181,8,1181,27,0],[1181,27,1182,9,0],[1182,9,1182,18,0],[1182,18,1184,8,0],[1184,8,1184,45,0],[1184,45,1185,8,0],[1185,8,1185,34,0],[1185,34,1186,8,0],[1186,8,1186,45,0],[1186,45,1187,8,0],[1187,8,1187,45,0],[1187,45,1188,8,0],[1188,8,1188,9,0],[1188,9,1189,9,0],[1189,9,1189,62,0],[1189,62,1190,9,0],[1190,9,1190,32,0],[1190,32,1192,9,0],[1192,9,1192,40,0],[1192,40,1193,10,0],[1193,10,1193,39,0],[1193,39,1194,8,0],[1194,8,1194,9,0],[1194,9,1194,15,0],[1194,15,1194,52,0],[1194,52,1195,9,0],[1195,9,1195,74,0],[1195,74,1196,7,0],[1196,7,1196,8,0],[1196,8,1197,6,0],[1197,6,1197,7,0],[1197,7,1197,8,0],[1197,8,1197,13,0],[1197,13,1198,6,0],[1198,6,1198,7,0],[1198,7,1198,8,0],[1198,8,1198,9,0],[1198,9,1199,5,0],[1199,5,1199,6,0],[1199,6,1199,8,0],[1167,5,1199,8,0],[1200,4,1200,5,0],[1201,3,1201,4,0]]);
    </script>
  </body>
</html>