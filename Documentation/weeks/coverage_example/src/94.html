<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>p:\stuff\projects\minigamesproject\minigamesproject\assets\_assets\scripts\bearded man studios\scripts\networking\forge\networking\udppacketsequence.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
/*-----------------------------+-------------------------------\
|                                                              |
|                         !!!NOTICE!!!                         |
|                                                              |
|  These libraries are under heavy development so they are     |
|  subject to make many changes as development continues.      |
|  For this reason, the libraries may not be well commented.   |
|  THANK YOU for supporting forge with all your feedback       |
|  suggestions, bug reports and comments!                      |
|                                                              |
|                              - The Forge Team                |
|                                Bearded Man Studios, Inc.     |
|                                                              |
|  This source code, project files, and associated files are   |
|  copyrighted by Bearded Man Studios, Inc. (2012-2017) and    |
|  may not be redistributed without written permission.        |
|                                                              |
\------------------------------+------------------------------*/

using System.Collections.Generic;

namespace BeardedManStudios.Forge.Networking
{
	public class UDPPacketSequence
	{
		/// &lt;summary&gt;
		/// Determines if this sequence of packets are reliable
		/// &lt;/summary&gt;
		public bool Reliable { get; private set; }

		/// &lt;summary&gt;
		/// The id of the last packet in this sequence when found
		/// &lt;/summary&gt;
		public int End { get; private set; }


		public Receivers Receivers { get; private set; }

		/// &lt;summary&gt;
		/// The list of packets that make up this sequence
		/// &lt;/summary&gt;
		Dictionary&lt;int, UDPPacket&gt; packets = new Dictionary&lt;int, UDPPacket&gt;();

		/// &lt;summary&gt;
		/// Used to determine if this sequence is complete
		/// &lt;/summary&gt;
		public bool Done { get; private set; }

		/// &lt;summary&gt;
		/// Adds the packet to the sequence
		/// &lt;/summary&gt;
		/// &lt;returns&gt;&lt;c&gt;true&lt;/c&gt;, if packet copmelted the sequence, &lt;c&gt;false&lt;/c&gt; otherwise.&lt;/returns&gt;
		/// &lt;param name=&quot;packet&quot;&gt;The packet to be added&lt;/param&gt;
		public bool AddPacket(UDPPacket packet)
		{
			// If there are no packets then this is the first packet, so we need
			// to do any initialization here related to the packets coming in
			if (packets.Count == 0)
				Reliable = packet.reliable;

			// Check to see if the packet has already been read
			if (packets.ContainsKey(packet.orderId))
				return false;

			// Check to see if this is the last packet in the list, if so store it
			// so that when other packets come in we can determine when to complete
			if (packet.endPacket)
			{
				End = packet.orderId + 1;
				Receivers = packet.receivers;
			}

			packets.Add(packet.orderId, packet);

			// Check to see if the end packet was received
			if (End != 0)
			{
				// If this dictionary has the same amount of packets as the end packet order id we are done
				if (packets.Count == End)
				{
					Done = true;
					return true;
				}
			}

			// This packet sequence is still incomplete
			return false;
		}

		/// &lt;summary&gt;
		/// Collect all of the data from all of the packets in this sequence and return it
		/// &lt;/summary&gt;
		/// &lt;returns&gt;The complete packet sequence data&lt;/returns&gt;
		public BMSByte GetData(NetWorker networker)
		{
			networker.PacketSequenceData.Clear();

			for (int i = 0; i &lt; End; i++)
				networker.PacketSequenceData.BlockCopy(packets[i].rawBytes, 0, packets[i].rawBytes.Length);

			return networker.PacketSequenceData;
		}
	}
}
    </pre>
    <script type="text/javascript">
      highlightRanges([[29,26,29,30,0],[29,31,29,43,0],[34,20,34,24,0],[34,25,34,37,0],[37,32,37,36,0],[37,37,37,49,0],[42,3,42,73,0],[47,22,47,26,0],[47,27,47,39,0],[55,3,55,4,0],[58,4,58,27,0],[59,5,59,32,0],[62,4,62,44,0],[63,5,63,18,0],[67,4,67,25,0],[68,4,68,5,0],[69,5,69,30,0],[70,5,70,34,0],[71,4,71,5,0],[73,4,73,40,0],[76,4,76,17,0],[77,4,77,5,0],[79,5,79,30,0],[80,5,80,6,0],[81,6,81,18,0],[82,6,82,18,0],[84,4,84,5,0],[87,4,87,17,0],[88,3,88,4,0],[95,3,95,4,0],[96,4,96,41,0],[98,9,98,18,0],[98,20,98,27,0],[98,29,98,32,0],[99,5,99,96,0],[101,4,101,40,0],[102,3,102,4,0]]);
    </script>
  </body>
</html>