<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <title>p:\stuff\projects\minigamesproject\minigamesproject\assets\_assets\scripts\bearded man studios\scripts\networking\forge\networking\networkingplayer.cs</title>
    <script type="text/javascript" src="../js/dotcover.sourceview.js"></script>
    <link rel="stylesheet" type="text/css" href="../css/dotcover.report.css" />
  </head>
  <body>
    <pre id="content" class="source-code">
/*-----------------------------+-------------------------------\
|                                                              |
|                         !!!NOTICE!!!                         |
|                                                              |
|  These libraries are under heavy development so they are     |
|  subject to make many changes as development continues.      |
|  For this reason, the libraries may not be well commented.   |
|  THANK YOU for supporting forge with all your feedback       |
|  suggestions, bug reports and comments!                      |
|                                                              |
|                              - The Forge Team                |
|                                Bearded Man Studios, Inc.     |
|                                                              |
|  This source code, project files, and associated files are   |
|  copyrighted by Bearded Man Studios, Inc. (2012-2017) and    |
|  may not be redistributed without written permission.        |
|                                                              |
\------------------------------+------------------------------*/

using BeardedManStudios.Forge.Networking.Frame;
using BeardedManStudios.Threading;
#if STEAMWORKS
using Steamworks;
#endif
using System.Collections.Generic;
using System.Linq;
using System.Net;

#if WINDOWS_UWP
using Windows.Networking.Sockets;
#else
using System.Net.Sockets;
#endif

namespace BeardedManStudios.Forge.Networking
{
	public class NetworkingPlayer
	{
		private const uint PLAYER_TIMEOUT_DISCONNECT = 30000;
		private const int DEFAULT_PING_INTERVAL = 5000;

		/// &lt;summary&gt;
		/// An event that is called whenever this player has disconnected
		/// &lt;/summary&gt;
		public event NetWorker.BaseNetworkEvent disconnected;

		/// &lt;summary&gt;
		/// The socket to the Networking player
		/// &lt;/summary&gt;
		public object SocketEndpoint { get; private set; }

		/// &lt;summary&gt;
		/// A reference to the raw tcp listener for this player (only used on server)
		/// &lt;/summary&gt;
#if WINDOWS_UWP
		public StreamSocketListener TcpListenerHandle { get; private set; }
#else
		public TcpListener TcpListenerHandle { get; private set; }
#endif

		/// &lt;summary&gt;
		/// A reference to the raw tcp client for this player
		/// &lt;/summary&gt;
#if WINDOWS_UWP
		public StreamSocket TcpClientHandle { get; private set; }
#else
		public TcpClient TcpClientHandle { get; private set; }
#endif

		/// &lt;summary&gt;
		/// A reference to the IPEndPoint for this player
		/// &lt;/summary&gt;
		public IPEndPoint IPEndPointHandle { get; private set; }

		/// &lt;summary&gt;
		/// The NetworkID the NetworkingPlayer is
		/// &lt;/summary&gt;
		public uint NetworkId { get; private set; }

		/// &lt;summary&gt;
		/// IP address of the NetworkingPlayer
		/// &lt;/summary&gt;
		public string Ip { get; private set; }

		/// &lt;summary&gt;
		/// Port number of this NetworkingPlayer
		/// &lt;/summary&gt;
		public ushort Port { get; private set; }

		/// &lt;summary&gt;
		/// Name of the NetworkingPlayer
		/// &lt;/summary&gt;
		public string Name { get; set; }

		/// &lt;summary&gt;
		/// Determines if the player has been accepted for the connection by the server
		/// &lt;/summary&gt;
		public bool Accepted { get; set; }

		/// &lt;summary&gt;
		/// Determines if the player has been sent an accept request but the server
		/// is still waiting on a confirmation of the acceptance
		/// &lt;/summary&gt;
		public bool PendingAccepted { get; set; }

        /// &lt;summary&gt;
        /// Determines if the player has been authenticated by the server
        /// &lt;/summary&gt;
        public bool Authenticated { get; set; }

        /// &lt;summary&gt;
        /// Determines if the player is currently connected
        /// &lt;/summary&gt;
        public bool Connected { get; set; }

		/// &lt;summary&gt;
		/// Is set once a disconnection happens
		/// &lt;/summary&gt;
		public bool Disconnected { get; private set; }

		/// &lt;summary&gt;
		/// This is the message group that this particular player is a part of
		/// &lt;/summary&gt;
		public ushort MessageGroup { get; private set; }

		/// &lt;summary&gt;
		/// Last ping sent to the NetworkingPlayer
		/// &lt;/summary&gt;
		public ulong LastPing { get; private set; }

		/// &lt;summary&gt;
		/// Whether this player is the one hosting
		/// &lt;/summary&gt;
		public bool IsHost { get; private set; }

		/// &lt;summary&gt;
		/// Used to determine if this player is in the process of disconnecting
		/// &lt;/summary&gt;
		public bool IsDisconnecting { get; set; }

		/// &lt;summary&gt;
		/// Whether we are locked
		/// &lt;/summary&gt;
		public object MutexLock = new object();

		/// &lt;summary&gt;
		/// Keep a list of all of the composers that are reliable so that they are sent in order
		/// &lt;/summary&gt;
		private List&lt;BasePacketComposer&gt; reliableComposers = new List&lt;BasePacketComposer&gt;();

		/// &lt;summary&gt;
		/// Should be used for matching this networking player with another networking player reference
		/// on a different networker.
		/// &lt;/summary&gt;
		public string InstanceGuid { get; set; }

		/// &lt;summary&gt;
		/// The amount of time in seconds to disconnect this player if no messages are sent
		/// &lt;/summary&gt;
		public uint TimeoutMilliseconds { get; set; }

		private bool composerReady = false;

		private int currentPingWait = 0;
		public int PingInterval { get; set; }

		/// &lt;summary&gt;
		/// The amount of time it took for a ping to happen
		/// &lt;/summary&gt;
		public int RoundTripLatency { get; set; }

		public NetWorker Networker { get; private set; }

		/// &lt;summary&gt;
		/// This is used for proximity based updates, this should update with
		/// the player location to properly be used with the NetWorker::ProximityDistance
		/// &lt;/summary&gt;
		public Vector ProximityLocation { get; set; }

        public GridLocation gridPosition { get; set; }

        /// &lt;summary&gt;
        /// Used to match players proximity status against each player, to know how many times
        ///  updating him has been skipped - used with the NetWorker::ProximityDistance
        /// &lt;/summary&gt;
        public Dictionary&lt;string, int&gt; PlayersProximityUpdateCounters = new Dictionary&lt;string, int&gt;();


        private ulong currentReliableId = 0;
		public Dictionary&lt;ulong, FrameStream&gt; reliablePending = new Dictionary&lt;ulong, FrameStream&gt;();

		public ulong UniqueReliableMessageIdCounter { get; private set; }

#if STEAMWORKS
        /// &lt;summary&gt;
        /// This is used for steam networking API calls;
        /// this is the steam ID of this networked player.
        /// &lt;/summary&gt;
        public CSteamID SteamID { get; protected set; }

        public void AssignOwnSteamId()
        {
            SteamID = SteamUser.GetSteamID();
        }
#endif

        private Queue&lt;ulong&gt; reliableComposersToRemove = new Queue&lt;ulong&gt;();

        /// &lt;summary&gt;
        /// Constructor for the NetworkingPlayer
        /// &lt;/summary&gt;
        /// &lt;param name=&quot;networkId&quot;&gt;NetworkId set for the NetworkingPlayer&lt;/param&gt;
        /// &lt;param name=&quot;ip&quot;&gt;IP address of the NetworkingPlayer&lt;/param&gt;
        /// &lt;param name=&quot;socketEndpoint&quot;&gt;The socket to the Networking player&lt;/param&gt;
        /// &lt;param name=&quot;name&quot;&gt;Name of the NetworkingPlayer&lt;/param&gt;
        public NetworkingPlayer(uint networkId, string ip, bool isHost, object socketEndpoint, NetWorker networker)
		{
			Networker = networker;
			NetworkId = networkId;
			Ip = ip.Split(&#39;+&#39;)[0];
			IsHost = isHost;
			SocketEndpoint = socketEndpoint;
			LastPing = networker.Time.Timestep;
			TimeoutMilliseconds = PLAYER_TIMEOUT_DISCONNECT;
			PingInterval = DEFAULT_PING_INTERVAL;

			if (SocketEndpoint != null)
			{
#if WINDOWS_UWP
				// Check to see if the supplied socket endpoint is TCP, if so
				// assign it to the TcpClientHandle for ease of access
				if (socketEndpoint is StreamSocket)
				{
					TcpClientHandle = (StreamSocket)socketEndpoint;
					IPEndPointHandle = (IPEndPoint)TcpClientHandle.Client.RemoteEndPoint;
				}
				else if (socketEndpoint is StreamSocketListener)
				{
					TcpListenerHandle = (StreamSocketListener)socketEndpoint;
					IPEndPointHandle = (IPEndPoint)TcpListenerHandle.LocalEndpoint;
				}
				else if (SocketEndpoint is IPEndPoint)
					IPEndPointHandle = (IPEndPoint)SocketEndpoint;
#else
				// Check to see if the supplied socket endpoint is TCP, if so
				// assign it to the TcpClientHandle for ease of access
				if (socketEndpoint is TcpClient)
				{
					TcpClientHandle = (TcpClient)socketEndpoint;
					IPEndPointHandle = (IPEndPoint)TcpClientHandle.Client.RemoteEndPoint;
				}
				else if (socketEndpoint is TcpListener)
				{
					TcpListenerHandle = (TcpListener)socketEndpoint;
					IPEndPointHandle = (IPEndPoint)TcpListenerHandle.LocalEndpoint;
				}
				else if (SocketEndpoint is IPEndPoint)
					IPEndPointHandle = (IPEndPoint)SocketEndpoint;
#endif

				Port = (ushort)IPEndPointHandle.Port;
			}
		}

#if STEAMWORKS
        public NetworkingPlayer(uint networkId, CSteamID steamId, bool isHost, NetWorker networker)
        {
            SteamID = steamId;
            Networker = networker;
            NetworkId = networkId;
            IsHost = isHost;
            LastPing = networker.Time.Timestep;
            TimeoutMilliseconds = PLAYER_TIMEOUT_DISCONNECT;
            PingInterval = DEFAULT_PING_INTERVAL;
        }
#endif

        public void AssignPort(ushort port)
		{
			// Only allow to be assigned once
			if (Port != 0)
				return;

			Port = port;
		}

		/// &lt;summary&gt;
		/// Ping the NetworkingPlayer
		/// &lt;/summary&gt;
		public void Ping()
		{
			LastPing = Networker.Time.Timestep;
		}

		/// &lt;summary&gt;
		/// Called by the server to check and see if this player has timed out
		/// &lt;/summary&gt;
		/// &lt;returns&gt;True if the player has timed out&lt;/returns&gt;
		public bool TimedOut()
		{
			return LastPing + TimeoutMilliseconds &lt;= Networker.Time.Timestep;
		}

		/// &lt;summary&gt;
		/// Assigns the message group for this player
		/// &lt;/summary&gt;
		/// &lt;param name=&quot;messageGroup&quot;&gt;The numerical identifier of the message group&lt;/param&gt;
		public void SetMessageGroup(ushort messageGroup)
		{
			MessageGroup = messageGroup;
		}

		public void OnDisconnect()
		{
			Disconnected = true;
			Connected = false;

			StopComposers();

			if (disconnected != null)
				disconnected(Networker);
		}

        public void QueueComposer(BasePacketComposer composer)
        {
			if (Disconnected)
				return;

			lock (reliableComposers)
			{
				reliableComposers.Add(composer);
			}

			// Start the reliable send thread on this composer
			NextComposerInQueue();
		}

		/// &lt;summary&gt;
		/// Star the next composer available composer
		/// &lt;/summary&gt;
		private void NextComposerInQueue()
		{
			// If there are not currently any queued composers then we can stop here
			if (reliableComposers.Count == 0)
				return;

			if (!composerReady &amp;&amp; Networker.IsBound &amp;&amp; !NetWorker.EndingSession)
			{
				composerReady = true;

				// Run this on a separate thread so that it doesn&#39;t interfere with the reading thread
				Task.Queue(() =&gt;
				{
					int waitTime = 10, composerCount = 0;
					while (Networker.IsBound &amp;&amp; !Disconnected)
					{
						lock (reliableComposers)
						{
							composerCount = reliableComposers.Count;
						}

						if (composerCount == 0)
						{
							Task.Sleep(waitTime);
							currentPingWait += waitTime;

							if (!(Networker is IServer) &amp;&amp; currentPingWait &gt;= PingInterval)
							{
								currentPingWait = 0;
								Networker.Ping();
							}

							continue;
						}

						do
						{
							// If there are too many packets to send, be sure to only send
							// a few to not clog the network.
							int counter = UDPPacketComposer.PACKET_SIZE;

							// Send all the packets that are pending
							lock (reliableComposers)
							{
								for (int i = 0; i &lt; reliableComposers.Count; i++)
									reliableComposers[i].ResendPackets(Networker.Time.Timestep, ref counter);
							}

							Task.Sleep(10);

							// Check if we have some composers queued to remove
							lock (reliableComposersToRemove)
							{
								while (reliableComposersToRemove.Count &gt; 0)
								{
									// Remove 
									lock (reliableComposers)
									{
										ulong id = reliableComposersToRemove.Dequeue();
										reliableComposers.Remove(reliableComposers.First(r =&gt; r.Frame.UniqueId == id));
									}
								}
							}

							lock (reliableComposers)
							{
								composerCount = reliableComposers.Count;
							}
						} while (composerCount &gt; 0 &amp;&amp; Networker.IsBound &amp;&amp; !NetWorker.EndingSession);
						currentPingWait = 0;
					}
				});
			}
		}

		/// &lt;summary&gt;
		/// Cleans up the current composer and prepares to start up the next in the queue
		/// &lt;/summary&gt;
		public void CleanupComposer(ulong uniqueId)
		{
			lock (reliableComposers)
			{
				reliableComposers.Remove(reliableComposers.First(r =&gt; r.Frame.UniqueId == uniqueId));
			}
		}

		/// &lt;summary&gt;
		/// Add composer to the queue, so it will be removed by sending thread
		/// &lt;/summary&gt;
		public void EnqueueComposerToRemove(ulong uniqueId)
		{
			lock (reliableComposersToRemove)
			{
				reliableComposersToRemove.Enqueue(uniqueId);
			}
		}

		/// &lt;summary&gt;
		/// Go through and stop all of the reliable composers for this player to prevent
		/// them from being sent
		/// &lt;/summary&gt;
		public void StopComposers()
		{
			lock (reliableComposers)
			{
				reliableComposers.Clear();
			}
		}

		public void WaitReliable(FrameStream frame)
		{
			if (!frame.IsReliable)
				return;

			if (frame.UniqueReliableId == currentReliableId)
			{
				Networker.FireRead(frame, this);
				currentReliableId++;

				FrameStream next = null;
				while (true)
				{
					if (!reliablePending.TryGetValue(currentReliableId, out next))
						break;

					reliablePending.Remove(currentReliableId++);
					Networker.FireRead(next, this);
				}
			}
			else if (frame.UniqueReliableId &gt; currentReliableId)
				reliablePending.Add(frame.UniqueReliableId, frame);
		}

		public ulong GetNextReliableId()
		{
			return UniqueReliableMessageIdCounter++;
		}
	}
}

    </pre>
    <script type="text/javascript">
      highlightRanges([[50,34,50,38,0],[50,39,50,51,0],[58,42,58,46,0],[58,47,58,59,0],[67,38,67,42,0],[67,43,67,55,0],[73,40,73,44,0],[73,45,73,57,0],[78,27,78,31,0],[78,32,78,44,0],[83,22,83,26,0],[83,27,83,39,0],[88,24,88,28,0],[88,29,88,41,0],[93,24,93,28,0],[93,29,93,33,0],[98,26,98,30,0],[98,31,98,35,0],[104,33,104,37,0],[104,38,104,42,0],[109,37,109,41,0],[109,42,109,46,0],[114,33,114,37,0],[114,38,114,42,0],[119,30,119,34,0],[119,35,119,47,0],[124,32,124,36,0],[124,37,124,49,0],[129,27,129,31,0],[129,32,129,44,0],[134,24,134,28,0],[134,29,134,41,0],[139,33,139,37,0],[139,38,139,42,0],[144,3,144,42,0],[149,3,149,87,0],[155,32,155,36,0],[155,37,155,41,0],[160,37,160,41,0],[160,42,160,46,0],[162,3,162,38,0],[164,3,164,35,0],[165,29,165,33,0],[165,34,165,38,0],[170,33,170,37,0],[170,38,170,42,0],[172,32,172,36,0],[172,37,172,49,0],[178,37,178,41,0],[178,42,178,46,0],[180,44,180,48,0],[180,49,180,53,0],[186,9,186,103,0],[189,9,189,45,0],[190,3,190,96,0],[192,49,192,53,0],[192,54,192,66,0],[207,9,207,77,0],[216,9,216,116,0],[217,3,217,4,0],[218,4,218,26,0],[219,4,219,26,0],[220,4,220,26,0],[221,4,221,20,0],[222,4,222,36,0],[223,4,223,39,0],[224,4,224,52,0],[225,4,225,41,0],[227,4,227,31,0],[228,4,228,5,0],[247,5,247,37,0],[248,5,248,6,0],[249,6,249,50,0],[250,6,250,75,0],[251,5,251,6,0],[252,10,252,44,0],[253,5,253,6,0],[254,6,254,54,0],[255,6,255,69,0],[256,5,256,6,0],[257,10,257,43,0],[258,6,258,52,0],[261,5,261,42,0],[262,4,262,5,0],[263,3,263,4,0],[279,3,279,4,0],[281,4,281,18,0],[282,5,282,12,0],[284,4,284,16,0],[285,3,285,4,0],[291,3,291,4,0],[292,4,292,39,0],[293,3,293,4,0],[300,3,300,4,0],[301,4,301,69,0],[302,3,302,4,0],[309,3,309,4,0],[310,4,310,32,0],[311,3,311,4,0],[314,3,314,4,0],[315,4,315,24,0],[316,4,316,22,0],[318,4,318,20,0],[320,4,320,29,0],[321,5,321,29,0],[322,3,322,4,0],[325,9,325,10,0],[326,4,326,21,0],[327,5,327,12,0],[329,4,329,28,0],[330,4,330,5,0],[331,5,331,37,0],[332,4,332,5,0],[335,4,335,26,0],[336,3,336,4,0],[342,3,342,4,0],[344,4,344,37,0],[345,5,345,12,0],[347,4,347,72,0],[348,4,348,5,0],[349,5,349,26,0],[352,5,353,5,0],[353,5,353,6,0],[353,6,354,6,0],[354,6,354,23,0],[354,23,354,25,0],[354,25,354,42,0],[354,42,355,6,0],[355,6,355,48,0],[355,48,356,6,0],[356,6,356,7,0],[356,7,357,7,0],[357,7,357,31,0],[357,31,358,7,0],[358,7,358,8,0],[358,8,359,8,0],[359,8,359,48,0],[359,48,360,7,0],[360,7,360,8,0],[360,8,362,7,0],[362,7,362,30,0],[362,30,363,7,0],[363,7,363,8,0],[363,8,364,8,0],[364,8,364,29,0],[364,29,365,8,0],[365,8,365,36,0],[365,36,367,8,0],[367,8,367,71,0],[367,71,368,8,0],[368,8,368,9,0],[368,9,369,9,0],[369,9,369,29,0],[369,29,370,9,0],[370,9,370,26,0],[370,26,371,8,0],[371,8,371,9,0],[371,9,373,8,0],[373,8,373,17,0],[373,17,377,7,0],[377,7,377,8,0],[377,8,380,8,0],[380,8,380,52,0],[380,52,383,8,0],[383,8,383,32,0],[383,32,384,8,0],[384,8,384,9,0],[384,9,385,14,0],[385,14,385,23,0],[385,23,385,25,0],[385,25,385,52,0],[385,52,385,54,0],[385,54,385,57,0],[385,57,386,10,0],[386,10,386,83,0],[386,83,387,8,0],[387,8,387,9,0],[387,9,389,8,0],[389,8,389,23,0],[389,23,392,8,0],[392,8,392,40,0],[392,40,393,8,0],[393,8,393,9,0],[393,9,394,9,0],[394,9,394,52,0],[394,52,395,9,0],[395,9,395,10,0],[395,10,397,10,0],[397,10,397,34,0],[397,34,398,10,0],[398,10,398,11,0],[398,11,399,11,0],[399,11,399,58,0],[399,58,400,11,0],[400,11,400,65,0],[400,65,400,87,0],[400,87,400,90,0],[400,11,400,90,0],[400,90,401,10,0],[401,10,401,11,0],[401,11,402,9,0],[402,9,402,10,0],[402,10,403,8,0],[403,8,403,9,0],[403,9,405,8,0],[405,8,405,32,0],[405,32,406,8,0],[406,8,406,9,0],[406,9,407,9,0],[407,9,407,49,0],[407,49,408,8,0],[408,8,408,9,0],[408,9,409,7,0],[409,7,409,8,0],[409,8,409,9,0],[409,9,409,84,0],[409,84,410,7,0],[410,7,410,27,0],[410,27,411,6,0],[411,6,411,7,0],[411,7,412,5,0],[412,5,412,6,0],[412,6,412,8,0],[352,5,412,8,0],[413,4,413,5,0],[414,3,414,4,0],[420,3,420,4,0],[421,4,421,28,0],[422,4,422,5,0],[423,5,423,59,0],[423,59,423,87,0],[423,87,423,90,0],[423,5,423,90,0],[424,4,424,5,0],[425,3,425,4,0],[431,3,431,4,0],[432,4,432,36,0],[433,4,433,5,0],[434,5,434,49,0],[435,4,435,5,0],[436,3,436,4,0],[443,3,443,4,0],[444,4,444,28,0],[445,4,445,5,0],[446,5,446,31,0],[447,4,447,5,0],[448,3,448,4,0],[451,3,451,4,0],[452,4,452,26,0],[453,5,453,12,0],[455,4,455,52,0],[456,4,456,5,0],[457,5,457,37,0],[458,5,458,25,0],[460,5,460,29,0],[461,5,461,17,0],[462,5,462,6,0],[463,6,463,68,0],[464,7,464,13,0],[466,6,466,50,0],[467,6,467,37,0],[468,5,468,6,0],[469,4,469,5,0],[470,9,470,56,0],[471,5,471,56,0],[472,3,472,4,0],[475,3,475,4,0],[476,4,476,44,0],[477,3,477,4,0]]);
    </script>
  </body>
</html>